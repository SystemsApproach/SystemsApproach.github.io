
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>4.3 Multiprotocol Label Switching Â· Computer Networks: A Systems Approach</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-katex/katex.min.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-block-align/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-smart-nav-collapse/smart-nav-collapse.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
        <link rel="stylesheet" href="../styles/website.css">
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="mobile-ip.html" />
    
    
    <link rel="prev" href="multicast.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Preface
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../foundation/problem.html">
            
                <a href="../foundation/problem.html">
            
                    
                    Chapter 1: Foundation
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="../foundation/applications.html">
            
                <a href="../foundation/applications.html">
            
                    
                    1.1 Applications
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="../foundation/requirements.html">
            
                <a href="../foundation/requirements.html">
            
                    
                    1.2 Requirements
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="../foundation/architecture.html">
            
                <a href="../foundation/architecture.html">
            
                    
                    1.3 Architecture
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.4" data-path="../foundation/software.html">
            
                <a href="../foundation/software.html">
            
                    
                    1.4 Software
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.5" data-path="../foundation/performance.html">
            
                <a href="../foundation/performance.html">
            
                    
                    1.5 Performance
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.6" data-path="../foundation/summary.html">
            
                <a href="../foundation/summary.html">
            
                    
                    1.6 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../direct/problem.html">
            
                <a href="../direct/problem.html">
            
                    
                    Chapter 2: Direct Connections
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="../direct/perspective.html">
            
                <a href="../direct/perspective.html">
            
                    
                    2.1 Technology Landscape
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="../direct/encoding.html">
            
                <a href="../direct/encoding.html">
            
                    
                    2.2 Encoding
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3" data-path="../direct/framing.html">
            
                <a href="../direct/framing.html">
            
                    
                    2.3 Framing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4" data-path="../direct/error.html">
            
                <a href="../direct/error.html">
            
                    
                    2.4 Error Detection
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.5" data-path="../direct/reliable.html">
            
                <a href="../direct/reliable.html">
            
                    
                    2.5 Reliable Transmission
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.6" data-path="../direct/ethernet.html">
            
                <a href="../direct/ethernet.html">
            
                    
                    2.6 Multi-Access Networks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.7" data-path="../direct/wireless.html">
            
                <a href="../direct/wireless.html">
            
                    
                    2.7 Wireless Networks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.8" data-path="../direct/access.html">
            
                <a href="../direct/access.html">
            
                    
                    2.8 Access Networks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.9" data-path="../direct/summary.html">
            
                <a href="../direct/summary.html">
            
                    
                    2.9 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="../internetworking/problem.html">
            
                <a href="../internetworking/problem.html">
            
                    
                    Chapter 3: Internetworking
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="../internetworking/switching.html">
            
                <a href="../internetworking/switching.html">
            
                    
                    3.1 Switching and Bridging
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="../internetworking/basic-ip.html">
            
                <a href="../internetworking/basic-ip.html">
            
                    
                    3.2 Basic Internetworking
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3" data-path="../internetworking/routing.html">
            
                <a href="../internetworking/routing.html">
            
                    
                    3.3 Routing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4" data-path="../internetworking/impl.html">
            
                <a href="../internetworking/impl.html">
            
                    
                    3.4 Implementation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.5" data-path="../internetworking/summary.html">
            
                <a href="../internetworking/summary.html">
            
                    
                    3.5 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="problem.html">
            
                <a href="problem.html">
            
                    
                    Chapter 4: Advanced Internetworking
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.1" data-path="global.html">
            
                <a href="global.html">
            
                    
                    4.1 Global Internet
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.2" data-path="multicast.html">
            
                <a href="multicast.html">
            
                    
                    4.2 Multicast
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.5.3" data-path="mpls.html">
            
                <a href="mpls.html">
            
                    
                    4.3 Multiprotocol Label Switching
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.4" data-path="mobile-ip.html">
            
                <a href="mobile-ip.html">
            
                    
                    4.4 Routing Among Mobile Devices
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.5" data-path="summary.html">
            
                <a href="summary.html">
            
                    
                    4.5 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="../e2e/problem.html">
            
                <a href="../e2e/problem.html">
            
                    
                    Chapter 5: End-to-End Protocols
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.6.1" data-path="../e2e/udp.html">
            
                <a href="../e2e/udp.html">
            
                    
                    5.1 Simple Demultiplexor (UDP)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2" data-path="../e2e/tcp.html">
            
                <a href="../e2e/tcp.html">
            
                    
                    5.2 Reliable Byte Stream (TCP)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.3" data-path="../e2e/rpc.html">
            
                <a href="../e2e/rpc.html">
            
                    
                    5.3 Remote Procedure Call
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.4" data-path="../e2e/rtp.html">
            
                <a href="../e2e/rtp.html">
            
                    
                    5.4 Transport for Real-Time Applications (RTP)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.5" data-path="../e2e/summary.html">
            
                <a href="../e2e/summary.html">
            
                    
                    5.5 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="../congestion/problem.html">
            
                <a href="../congestion/problem.html">
            
                    
                    Chapter 6: Congestion Control and Resource Allocation
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.1" data-path="../congestion/issues.html">
            
                <a href="../congestion/issues.html">
            
                    
                    6.1 Issues in Resource Allocation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.2" data-path="../congestion/queuing.html">
            
                <a href="../congestion/queuing.html">
            
                    
                    6.2 Queuing Disciplines
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.3" data-path="../congestion/tcpcc.html">
            
                <a href="../congestion/tcpcc.html">
            
                    
                    6.3 TCP Congestion Control
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4" data-path="../congestion/avoidance.html">
            
                <a href="../congestion/avoidance.html">
            
                    
                    6.4 Congestion-Avoidance Mechanisms
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.5" data-path="../congestion/qos.html">
            
                <a href="../congestion/qos.html">
            
                    
                    6.5 Quality of Service
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.6" data-path="../congestion/summary.html">
            
                <a href="../congestion/summary.html">
            
                    
                    6.6 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="../data/problem.html">
            
                <a href="../data/problem.html">
            
                    
                    Chapter 7: End-to-End Data
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.8.1" data-path="../data/presentation.html">
            
                <a href="../data/presentation.html">
            
                    
                    7.1 Presentation Formatting
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.2" data-path="../data/multimedia.html">
            
                <a href="../data/multimedia.html">
            
                    
                    7.2 Multimedia Data
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.3" data-path="../data/summary.html">
            
                <a href="../data/summary.html">
            
                    
                    7.3 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="../security/problem.html">
            
                <a href="../security/problem.html">
            
                    
                    Chapter 8: Network Security
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.9.1" data-path="../security/crypto.html">
            
                <a href="../security/crypto.html">
            
                    
                    8.1 Cryptographic Building Blocks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2" data-path="../security/key-distro.html">
            
                <a href="../security/key-distro.html">
            
                    
                    8.2 Key Predistribution
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.3" data-path="../security/authentication.html">
            
                <a href="../security/authentication.html">
            
                    
                    8.3 Authentication Protocols
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.4" data-path="../security/systems.html">
            
                <a href="../security/systems.html">
            
                    
                    8.4 Example Systems
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.5" data-path="../security/summary.html">
            
                <a href="../security/summary.html">
            
                    
                    8.5 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="../applications/problem.html">
            
                <a href="../applications/problem.html">
            
                    
                    Chapter 9: Applications
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.10.1" data-path="../applications/traditional.html">
            
                <a href="../applications/traditional.html">
            
                    
                    9.1 Traditional Applications
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.2" data-path="../applications/multimedia.html">
            
                <a href="../applications/multimedia.html">
            
                    
                    9.2 Multimedia Applications
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.3" data-path="../applications/infrastructure.html">
            
                <a href="../applications/infrastructure.html">
            
                    
                    9.3 Infrastructure Applications
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.4" data-path="../applications/overlays.html">
            
                <a href="../applications/overlays.html">
            
                    
                    9.4 Overlay Networks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.5" data-path="../applications/summary.html">
            
                <a href="../applications/summary.html">
            
                    
                    9.5 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >4.3 Multiprotocol Label Switching</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="43-multiprotocol-label-switching">4.3 Multiprotocol Label Switching</h1>
<p>We continue our discussion of enhancements to IP by describing an
addition to the Internet architecture that is very widely used but
largely hidden from end users. The enhancement, called <em>Multiprotocol
Label Switching</em> (MPLS), combines some of the properties of virtual
circuits with the flexibility and robustness of datagrams. On the one
hand, MPLS is very much associated with the Internet Protocol&apos;s
datagram-based architecture&#x2014;it relies on IP addresses and IP routing
protocols to do its job. On the other hand, MPLS-enabled routers also
forward packets by examining relatively short, fixed-length labels, and
these labels have local scope, just like in a virtual circuit network.
It is perhaps this marriage of two seemingly opposed technologies that
has caused MPLS to have a somewhat mixed reception in the Internet
engineering community.</p>
<p>Before looking at how MPLS works, it is reasonable to ask &quot;what is it
good for?&quot; Many claims have been made for MPLS, but there are three main
things that it is used for today:</p>
<ul>
<li><p>To enable IP capabilities on devices that do not have the capability
 to forward IP datagrams in the normal manner</p>
</li>
<li><p>To forward IP packets along explicit routes&#x2014;precalculated routes
 that don&apos;t necessarily match those that normal IP routing protocols
 would select</p>
</li>
<li><p>To support certain types of virtual private network services</p>
</li>
</ul>
<p>It is worth noting that one of the original goals&#x2014;improving
performance&#x2014;is not on the list. This has a lot to do with the advances
that have been made in forwarding algorithms for IP routers in recent
years and with the complex set of factors beyond header processing that
determine performance.</p>
<p>The best way to understand how MPLS works is to look at some examples of
its use. In the next three sections, we will look at examples to
illustrate the three applications of MPLS mentioned above.</p>
<h2 id="destination-based-forwarding">Destination-Based Forwarding</h2>
<p>One of the earliest publications to introduce the idea of attaching
labels to IP packets was a paper by Chandranmenon and Vargese that
described an idea called <em>threaded indices</em>. A very similar idea is now
implemented in MPLS-enabled routers. The following example shows how
this idea works.</p>
<figure class="line">
    <a id="mpls-dest"></a>
    <img src="figures/f04-18-9780123850591.png" width="500px">
    <figcaption>Routing tables in example network.</figcaption>
</figure>

<p>Consider the network in <a href="#mpls-dest">Figure 1</a>. Each of the two routers
on the far right (R3 and R4) has one connected network, with prefixes
<code>18.1.1/24</code> and <code>18.3.3/24</code>. The remaining routers (R1 and R2) have
routing tables that indicate which outgoing interface each router would
use when forwarding packets to one of those two networks.</p>
<p>When MPLS is enabled on a router, the router allocates a label for each
prefix in its routing table and advertises both the label and the prefix
that it represents to its neighboring routers. This advertisement is
carried in the Label Distribution Protocol. This is illustrated in
<a href="#label-dist">Figure 2</a>. Router R2 has allocated the label value <code>15</code>
for the prefix <code>18.1.1</code> and the label value <code>16</code> for the prefix
<code>18.3.3</code>. These labels can be chosen at the convenience of the
allocating router and can be thought of as indices into the routing
table. After allocating the labels, R2 advertises the label bindings to
its neighbors; in this case, we see R2 advertising a binding between the
label <code>15</code> and the prefix <code>18.1.1</code> to R1. The meaning of such an
advertisement is that R2 has said, in effect, &quot;Please attach the label
<code>15</code> to all packets sent to me that are destined to prefix
<code>18.1.1</code>.&quot; R1 stores the label in a table alongside the prefix that it
represents as the remote or outgoing label for any packets that it sends
to that prefix.</p>
<p>In <a href="#label-dist">Figure 2(c)</a>, we see another label advertisement from
router R3 to R2 for the prefix <code>18.1.1</code>, and R2 places the remote
label that it learned from R3 in the appropriate place in its table.</p>
<figure class="line">
    <a id="label-dist"></a>
    <img src="figures/f04-19-9780123850591.png" width="500px">
    <figcaption>(a) R2 allocates labels and advertises bindings to
    R1. (b) R1 stores the received labels in a table. (c) R3
    advertises another binding, and R2 stores the received label in a
    table.</figcaption>
</figure>

<p>At this point, we can look at what happens when a packet is forwarded in
this network. Suppose a packet destined to the IP address <code>18.1.1.5</code>
arrives from the left to router R1. R1 in this case is referred to as a
<em>Label Edge Router</em> (LER); an LER performs a complete IP lookup on
arriving IP packets and then applies labels to them as a result of the
lookup. In this case, R1 would see that <code>18.1.1.5</code> matches the prefix
<code>18.1.1</code> in its forwarding table and that this entry contains both an
outgoing interface and a remote label value. R1 therefore attaches the
remote label <code>15</code> to the packet before sending it.</p>
<p>When the packet arrives at R2, R2 looks only at the label in the packet,
not the IP address. The forwarding table at R2 indicates that packets
arriving with a label value of <code>15</code> should be sent out interface 1 and
that they should carry the label value <code>24</code>, as advertised by router
R3. R2 therefore rewrites, or swaps, the label and forwards it on to R3.</p>
<p>What has been accomplished by all this application and swapping of
labels? Observe that when R2 forwarded the packet in this example it
never actually needed to examine the IP address. Instead, R2 looked only
at the incoming label. Thus, we have replaced the normal IP destination
address lookup with a label lookup. To understand why this is
significant, it helps to recall that, although IP addresses are always
the same length, IP prefixes are of variable length, and the IP
destination address lookup algorithm needs to find the <em>longest match</em>&#x2014;the
longest prefix that matches the high order bits in the IP address of the
packet being forwarded. By contrast, the label forwarding mechanism just
described is an <em>exact match</em> algorithm. It is possible to implement a
very simple exact match algorithm, for example, by using the label as an
index into an array, where each element in the array is one line in the
forwarding table.</p>
<p>Note that, while the forwarding algorithm has been changed from longest
match to exact match, the routing algorithm can be any standard IP
routing algorithm (e.g., OSPF). The path that a packet will follow in
this environment is the exact same path that it would have followed if
MPLS were not involved: the path chosen by the IP routing algorithms.
All that has changed is the forwarding algorithm.</p>
<p>An important fundamental concept of MPLS is illustrated by this example.
Every MPLS label is associated with a <em>forwarding equivalence class</em>
(FEC)&#x2014;a set of packets that are to receive the same forwarding
treatment in a particular router. In this example, each prefix in the
routing table is an FEC; that is, all packets that match the prefix
18.1.1&#x2014;no matter what the low order bits of the IP address are&#x2014;get
forwarded along the same path. Thus, each router can allocate one label
that maps to 18.1.1, and any packet that contains an IP address whose
high order bits match that prefix can be forwarded using that label.</p>
<p>As we will see in the subsequent examples, FECs are a very powerful and
flexible concept. FECs can be formed using almost any criteria; for
example, all the packets corresponding to a particular customer could be
considered to be in the same FEC.</p>
<p>Returning to the example at hand, we observe that changing the
forwarding algorithm from normal IP forwarding to label swapping has an
important consequence: Devices that previously didn&apos;t know how to
forward IP packets can be used to forward IP traffic in an MPLS network.
The most notable early application of this result was to ATM switches,
which can support MPLS without any changes to their forwarding hardware.
ATM switches support the label-swapping forwarding algorithm just
described, and by providing these switches with IP routing protocols and
a method to distribute label bindings they could be turned into <em>Label
Switching Routers</em> (LSRs)&#x2014;devices that run IP control protocols but
use the label switching forwarding algorithm. More recently, the same
idea has been applied to optical switches.</p>
<p>Before we consider the purported benefits of turning an ATM switch into
an LSR, we should tie up some loose ends. We have said that labels are
&quot;attached&quot; to packets, but where exactly are they attached? The answer
depends on the type of link on which packets are carried. Two common
methods for carrying labels on packets are shown in
<a href="#labels">Figure 3</a>. When IP packets are carried as complete frames, as
they are on most link types including Ethernet and PPP, the label is
inserted as a &quot;shim&quot; between the layer 2 header and the IP (or other
layer 3) header, as shown in the lower part of the figure. However, if
an ATM switch is to function as an MPLS LSR, then the label needs to be
in a place where the switch can use it, and that means it needs to be in
the ATM cell header, exactly where one would normally find the virtual
circuit identifier (VCI) and virtual path identifier (VPI) fields.</p>
<figure class="line">
    <a id="labels"></a>
    <img src="figures/f04-20-9780123850591.png" width="600px">
    <figcaption>(a) Label on an ATM-encapsulated packet; (b) label on
    a frame-encapsulated packet.</figcaption>
</figure>

<figure class="line">
    <a id="overlay"></a>
    <img src="figures/f04-21-9780123850591.png" width="400px">
    <figcaption>(a) Routers connect to each other using an overlay of
    virtual circuits. (b) Routers peer directly with LSRs.</figcaption>
</figure>

<p>Having now devised a scheme by which an ATM switch can function as an
LSR, what have we gained? One thing to note is that we could now build a
network that uses a mixture of conventional IP routers, label edge
routers, and ATM switches functioning as LSRs, and they would all use
the same routing protocols. To understand the benefits of using the same
protocols, consider the alternative. In <a href="#overlay">Figure 4(a)</a>, we
see a set of routers interconnected by virtual circuits over an ATM
network, a configuration called an <em>overlay</em> network. At one point in
time, networks of this type were often built because commercially
available ATM switches supported higher total throughput than routers.
Today, networks like this are less common because routers have caught up
with and even surpassed ATM switches. However, these networks still
exist because of the significant installed base of ATM switches in
network backbones, which in turn is partly a result of ATM&apos;s ability to
support a range of capabilities such as circuit emulation and virtual
circuit services.</p>
<p>In an overlay network, each router would potentially be connected to
each of the other routers by a virtual circuit, but in this case for
clarity we have just shown the circuits from R1 to all of its peer
routers. R1 has five routing neighbors and needs to exchange routing
protocol messages with all of them&#x2014;we say that R1 has five routing
adjacencies. By contrast, in <a href="#overlay">Figure 4(b)</a>, the ATM switches
have been replaced with LSRs. There are no longer virtual circuits
interconnecting the routers. Thus, R1 has only one adjacency, with LSR1.
In large networks, running MPLS on the switches leads to a significant
reduction in the number of adjacencies that each router must maintain
and can greatly reduce the amount of work that the routers have to do to
keep each other informed of topology changes.</p>
<p>A second benefit of running the same routing protocols on edge routers
and on the LSRs is that the edge routers now have a full view of the
topology of the network. This means that if some link or node fails
inside the network, the edge routers will have a better chance of
picking a good new path than if the ATM switches rerouted the affected
VCs without the knowledge of the edge routers.</p>
<p>Note that the step of &quot;replacing&quot; ATM switches with LSRs is actually
achieved by changing the protocols running on the switches, but
typically no change to the forwarding hardware is needed; that is, an
ATM switch can often be converted to an MPLS LSR by upgrading only its
software. Furthermore, an MPLS LSR might continue to support standard
ATM capabilities at the same time as it runs the MPLS control protocols,
in what is referred to as &quot;ships in the night&quot; mode.</p>
<p>The idea of running IP control protocols on devices that
are unable to forward IP packets natively has been extended to
Wavelength Division Multiplexing (WDM) and Time Division Multiplexing
(TDM) networks (e.g., SONET). This is known as <em>Generalized MPLS</em>
(GMPLS). Part of the motivation for GMPLS was to provide routers with
topological knowledge of an optical network, just as in the ATM
case. Even more important was the fact that there were no standard
protocols for controlling optical devices, so MPLS proved to be a
natural fit for that job.</p>
<h2 id="explicit-routing">Explicit Routing</h2>
<p>IP has a source routing option, but it is not widely used for several
reasons, including the fact that only a limited number of hops can be
specified and because it is usual processed outside the &quot;fast path&quot; on
most routers.</p>
<p>MPLS provides a convenient way to add capabilities similar to
source-routing to IP networks, although the capability is more often
referred to as <em>explicit routing</em> rather than <em>source routing</em>. One
reason for the distinction is that it usually isn&apos;t the real source of
the packet that picks the route. More often it is one of the routers
inside a service provider&apos;s network. <a href="#fish">Figure 5</a> shows an example
of how the explicit routing capability of MPLS might be applied. This
sort of network is often called a <em>fish</em> network because of its shape
(the routers R1 and R2 form the tail; R7 is at the head).</p>
<figure class="line">
    <a id="fish"></a>
    <img src="figures/f04-22-9780123850591.png" width="450px">
    <figcaption>A network requiring explicit routing.</figcaption>
</figure>

<p>Suppose that the operator of the network in <a href="#fish">Figure 5</a> has
determined that any traffic flowing from R1 to R7 should follow the path
R1-R3-R6-R7 and that any traffic going from R2 to R7 should follow the
path R2-R3-R4-R5-R7. One reason for such a choice would be to make good
use of the capacity available along the two distinct paths from R3 to
R7. We can think of the R1-to-R7 traffic as constituting one forwarding
equivalence class, and the R2-to-R7 traffic constitutes a second FEC.
Forwarding traffic in these two classes along different paths is
difficult with normal IP routing, because R3 doesn&apos;t normally look at
where traffic came from in making its forwarding decisions.</p>
<p>Because MPLS uses label swapping to forward packets, it is easy enough
to achieve the desired routing if the routers are MPLS enabled. If R1
and R2 attach distinct labels to packets before sending them to
R3&#x2014;thus identifying them as being in different FECs&#x2014;then R3 can forward
packets from R1 and R2 along different paths. The question that then
arises is how do all the routers in the network agree on what labels to
use and how to forward packets with particular labels? Clearly, we can&apos;t
use the same procedures as described in the preceding section to
distribute labels, because those procedures establish labels that cause
packets to follow the normal paths picked by IP routing, which is
exactly what we are trying to avoid. Instead, a new mechanism is needed.
It turns out that the protocol used for this task is the Resource
Reservation Protocol (RSVP). For now it suffices to say that it is
possible to send an RSVP message along an explicitly specified path
(e.g., R1-R3-R6-R7) and use it to set up label forwarding table entries
all along that path. This is very similar to the process of establishing
a virtual circuit.</p>
<p>One of the applications of explicit routing is <em>traffic engineering</em>,
which refers to the task of ensuring that sufficient resources are
available in a network to meet the demands placed on it. Controlling
exactly which paths the traffic flows on is an important part of traffic
engineering. Explicit routing can also help to make networks more
resilient in the face of failure, using a capability called <em>fast
reroute</em>. For example, it is possible to precalculate a path from router
A to router B that explicitly avoids a certain link L. In the event that
link L fails, router A could send all traffic destined to B down the
precalculated path. The combination of precalculation of the backup path
and the explicit routing of packets along the path means that A doesn&apos;t
need to wait for routing protocol packets to make their way across the
network or for routing algorithms to be executed by various other nodes
in the network. In certain circumstances, this can significantly reduce
the time taken to reroute packets around a point of failure.</p>
<p>One final point to note about explicit routing is that explicit routes
need not be calculated by a network operator as in the above example.
Routers can use various algorithms to calculate explicit routes
automatically. The most common of these is <em>constrained shortest path
first</em> (CSPF), which is a link-state algorithm, but which also takes
various <em>constraints</em> into account. For example, if it was required to
find a path from R1 to R7 that could carry an offered load of 100 Mbps,
we could say that the constraint is that each link must have at least
100 Mbps of available capacity. CSPF addresses this sort of problem.</p>
<h2 id="virtual-private-networks-and-tunnels">Virtual Private Networks and Tunnels</h2>
<p>One way to build virtual private networks (VPNs) is to use tunnels. It
turns out that MPLS can be thought of as a way to build tunnels, and
this makes it suitable for building VPNs of various types.</p>
<p>The simplest form of MPLS VPN to understand is a layer 2 VPN. In this
type of VPN, MPLS is used to tunnel layer 2 data (such as Ethernet
frames or ATM cells) across a network of MPLS-enabled routers. One
reason for tunnels is to provide some sort of network service (such as
multicast) that is not supported by some routers in the network. The
same logic applies here: IP routers are not ATM switches, so you cannot
provide an ATM virtual circuit service across a network of conventional
routers. However, if you had a pair of routers interconnected by a
tunnel, they could send ATM cells across the tunnel and emulate an ATM
circuit. The term for this technique within the IETF is <em>pseudowire
emulation</em>. <a href="#atm-tunnel">Figure 6</a> illustrates the idea.</p>
<figure class="line">
    <a id="atm-tunnel"></a>
    <img src="figures/f04-23-9780123850591.png" width="600px">
    <figcaption>An ATM circuit is emulated by a tunnel.</figcaption>
</figure>

<p>We have already seen how IP tunnels are built: The router at the
entrance of the tunnel wraps the data to be tunneled in an IP header
(the <em>tunnel header</em>), which represents the address of the router at the
far end of the tunnel and sends the data like any other IP packet. The
receiving router receives the packet with its own address in the header,
strips the tunnel header, and finds the data that was tunneled, which it
then processes. Exactly what it does with that data depends on what it
is. For example, if it were another IP packet, it would then be
forwarded on like a normal IP packet. However, it need not be an IP
packet, as long as the receiving router knows what to do with non-IP
packets. We&apos;ll return to the issue of how to handle non-IP data in a
moment.</p>
<p>An MPLS tunnel is not too different from an IP tunnel, except that the
tunnel header consists of an MPLS header rather than an IP header.
Looking back to our first example, in <a href="#label-dist">Figure 2</a>, we saw
that router R1 attached a label (<code>15</code>) to every packet that it sent
towards prefix 18.1.1. Such a packet would then follow the path
R1-R2-R3, with each router in the path examining only the MPLS label.
Thus, we observe that there was no requirement that R1 only send IP
packets along this path&#x2014;any data could be wrapped up in the MPLS
header and it would follow the same path, because the intervening
routers never look beyond the MPLS header. In this regard, an MPLS
header is just like an IP tunnel header (excpet only 4 bytes long
intead of 20 bytes). The only issue with sending
non-IP traffic along a tunnel, MPLS or otherwise, is what to do with
non-IP traffic when it reaches the end of the tunnel. The general
solution is to carry some sort of demultiplexing identifier in the
tunnel payload that tells the router at the end of the tunnel what to
do. It turns out that an MPLS label is a perfect fit for such an
identifier. An example will make this clear.</p>
<p>Let&apos;s assume we want to tunnel ATM cells from one router to another
across a network of MPLS-enabled routers, as in
<a href="#atm-tunnel">Figure 6</a>. Further, we assume that the goal is to emulate
an ATM virtual circuit; that is, cells arrive at the entrance, or head,
of the tunnel on a certain input port with a certain VCI and should
leave the tail end of the tunnel on a certain output port and
potentially different VCI. This can be accomplished by configuring the
head and tail routers as follows:</p>
<ul>
<li><p>The head router needs to be configured with the incoming port, the
  incoming VCI, the demultiplexing label for this emulated circuit,
  and the address of the tunnel end router.</p>
</li>
<li><p>The tail router needs to be configured with the outgoing port, the
  outgoing VCI, and the demultiplexing label.</p>
</li>
</ul>
<p>Once the routers are provided with this information, we can see how an
ATM cell would be forwarded. <a href="#pw-eg">Figure 7</a> illustrates the steps.</p>
<ol>
<li><p>An ATM cell arrives on the designated input port with the
 appropriate VCI value (101 in this example).</p>
</li>
<li><p>The head router attaches the demultiplexing label that identifies
 the emulated circuit.</p>
</li>
<li><p>The head router then attaches a second label, which is the tunnel
 label that will get the packet to the tail router. This label is
 learned by mechanisms just like those described elsewhere in this
 section.</p>
</li>
<li><p>Routers between the head and tail forward the packet using only the
 tunnel label.</p>
</li>
<li><p>The tail router removes the tunnel label, finds the demultiplexing
 label, and recognizes the emulated circuit.</p>
</li>
<li><p>The tail router modifies the ATM VCI to the correct value (202 in
 this case) and sends it out the correct port.</p>
</li>
</ol>
<figure class="line">
    <a id="pw-eg"></a>
    <img src="figures/f04-24-9780123850591.png" width="600px">
    <figcaption>Forward ATM cells along a tunnel.</figcaption>
</figure>

<p>One item in this example that might be surprising is that the packet has
two labels attached to it. This is one of the interesting features of
MPLS&#x2014;labels may be stacked on a packet to any depth. This provides
some useful scaling capabilities. In this example, it allows a single
tunnel to carry a potentially large number of emulated circuits.</p>
<p>The same techniques described here can be applied to emulate many other
layer 2 services, including Frame Relay and Ethernet. It is worth noting
that virtually identical capabilities can be provided using IP tunnels;
the main advantage of MPLS here is the shorter tunnel header.</p>
<figure class="line">
    <a id="mpls-vpn"></a>
    <img src="figures/f04-25-9780123850591.png" width="600px">
    <figcaption>Example of a layer 3 VPN. Customers A and B each
    obtain a virtually private IP service from a single
    provider.</figcaption>
</figure>

<p>Before MPLS was used to tunnel layer 2 services, it was also being used
to support layer 3 VPNs. We won&apos;t go into the details of layer 3 VPNs,
which are quite complex, but we will note that they represent one of the
most popular uses of MPLS today. Layer 3 VPNs also use stacks of MPLS
labels to tunnel packets across an IP network. However, the packets that
are tunneled are themselves IP packets&#x2014;hence, the name <em>layer 3</em> VPNs.
In a layer 3 VPN, a single service provider operates a network of
MPLS-enabled routers and provides a &quot;virtually private&quot; IP network
service to any number of distinct customers. That is, each customer of
the provider has some number of sites, and the service provider creates
the illusion for each customer that there are no other customers on the
network. The customer sees an IP network interconnecting his own sites
and no other sites. This means that each customer is isolated from all
other customers in terms of both routing and addressing. Customer A
can&apos;t sent packets directly to customer B, and <em>vice versa</em>.
Customer A can even use IP addresses that have also been used by
customer B. The basic idea is illustrated in <a href="#mpls-vpn">Figure 8</a>. As
in layer 2 VPNs, MPLS is used to tunnel packets from one site to
another; however, the configuration of the tunnels is performed
automatically by some fairly elaborate use of BGP, which is beyond the
scope of this book.</p>
<blockquote>
<p>Customer A in fact usually <em>can</em> send data to customer B in some 
restricted way. Most likely, both customer A and customer B have 
some connection to the global Internet, and thus it is probably 
possible for customer A to send email messages, for example, to the 
mail server inside customer B&apos;s network. The &quot;privacy&quot; offered by a 
VPN prevents customer A from having unrestricted access to all the 
machines and subnets inside customer B&apos;s network.</p>
</blockquote>
<p>In summary, MPLS is a rather versatile tool that has been applied to a
wide range of different networking problems. It combines the
label-swapping forwarding mechanism that is normally associated with
virtual circuit networks with the routing and control protocols of IP
datagram networks to produce a class of network that is somewhere
between the two conventional extremes. This extends the capabilities of
IP networks to enable, among other things, more precise control of
routing and the support of a range of VPN services.</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="multicast.html" class="navigation navigation-prev " aria-label="Previous page: 4.2 Multicast">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="mobile-ip.html" class="navigation navigation-next " aria-label="Next page: 4.4 Routing Among Mobile Devices">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"4.3 Multiprotocol Label Switching","level":"1.5.3","depth":2,"next":{"title":"4.4 Routing Among Mobile Devices","level":"1.5.4","depth":2,"path":"scaling/mobile-ip.md","ref":"scaling/mobile-ip.md","articles":[]},"previous":{"title":"4.2 Multicast","level":"1.5.2","depth":2,"path":"scaling/multicast.md","ref":"scaling/multicast.md","articles":[]},"dir":"ltr"},"config":{"plugins":["anchorjs","katex","block-align","sequence-diagrams","creativecommons","custom-favicon","smart-nav-collapse"],"root":".","styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css"},"pluginsConfig":{"block-align":{},"search":{},"sequence-diagrams":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"katex":{},"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"favicon":"bridge.ico","custom-favicon":{},"creativecommons":{},"smart-nav-collapse":{},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false},"anchorjs":{}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{"branch":"master"},"title":"Computer Networks: A Systems Approach","gitbook":"*"},"file":{"path":"scaling/mpls.md","mtime":"2018-09-10T22:00:41.000Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2018-09-10T22:04:53.604Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.1.1/anchor.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-anchorjs/anchor-style.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-smart-nav-collapse/smart-nav-collapse.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

