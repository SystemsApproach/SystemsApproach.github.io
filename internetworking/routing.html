
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>3.3 Routing Â· Computer Networks: A Systems Approach</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-katex/katex.min.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-block-align/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-smart-nav-collapse/smart-nav-collapse.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
        <link rel="stylesheet" href="../styles/website.css">
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="impl.html" />
    
    
    <link rel="prev" href="basic-ip.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Preface
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../foundation/problem.html">
            
                <a href="../foundation/problem.html">
            
                    
                    Chapter 1: Foundation
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="../foundation/applications.html">
            
                <a href="../foundation/applications.html">
            
                    
                    1.1 Applications
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="../foundation/requirements.html">
            
                <a href="../foundation/requirements.html">
            
                    
                    1.2 Requirements
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="../foundation/architecture.html">
            
                <a href="../foundation/architecture.html">
            
                    
                    1.3 Architecture
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.4" data-path="../foundation/software.html">
            
                <a href="../foundation/software.html">
            
                    
                    1.4 Software
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.5" data-path="../foundation/performance.html">
            
                <a href="../foundation/performance.html">
            
                    
                    1.5 Performance
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.6" data-path="../foundation/summary.html">
            
                <a href="../foundation/summary.html">
            
                    
                    1.6 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../direct/problem.html">
            
                <a href="../direct/problem.html">
            
                    
                    Chapter 2: Direct Connections
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="../direct/perspective.html">
            
                <a href="../direct/perspective.html">
            
                    
                    2.1 Technology Landscape
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="../direct/encoding.html">
            
                <a href="../direct/encoding.html">
            
                    
                    2.2 Encoding
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3" data-path="../direct/framing.html">
            
                <a href="../direct/framing.html">
            
                    
                    2.3 Framing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4" data-path="../direct/error.html">
            
                <a href="../direct/error.html">
            
                    
                    2.4 Error Detection
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.5" data-path="../direct/reliable.html">
            
                <a href="../direct/reliable.html">
            
                    
                    2.5 Reliable Transmission
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.6" data-path="../direct/ethernet.html">
            
                <a href="../direct/ethernet.html">
            
                    
                    2.6 Multi-Access Networks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.7" data-path="../direct/wireless.html">
            
                <a href="../direct/wireless.html">
            
                    
                    2.7 Wireless Networks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.8" data-path="../direct/access.html">
            
                <a href="../direct/access.html">
            
                    
                    2.8 Access Networks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.9" data-path="../direct/summary.html">
            
                <a href="../direct/summary.html">
            
                    
                    2.9 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="problem.html">
            
                <a href="problem.html">
            
                    
                    Chapter 3: Internetworking
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="switching.html">
            
                <a href="switching.html">
            
                    
                    3.1 Switching and Bridging
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="basic-ip.html">
            
                <a href="basic-ip.html">
            
                    
                    3.2 Basic Internetworking
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.4.3" data-path="routing.html">
            
                <a href="routing.html">
            
                    
                    3.3 Routing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4" data-path="impl.html">
            
                <a href="impl.html">
            
                    
                    3.4 Implementation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.5" data-path="summary.html">
            
                <a href="summary.html">
            
                    
                    3.5 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="../scaling/problem.html">
            
                <a href="../scaling/problem.html">
            
                    
                    Chapter 4: Advanced Internetworking
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.1" data-path="../scaling/global.html">
            
                <a href="../scaling/global.html">
            
                    
                    4.1 Global Internet
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.2" data-path="../scaling/multicast.html">
            
                <a href="../scaling/multicast.html">
            
                    
                    4.2 Multicast
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.3" data-path="../scaling/mpls.html">
            
                <a href="../scaling/mpls.html">
            
                    
                    4.3 Multiprotocol Label Switching
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.4" data-path="../scaling/mobile-ip.html">
            
                <a href="../scaling/mobile-ip.html">
            
                    
                    4.4 Routing Among Mobile Devices
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.5" data-path="../scaling/summary.html">
            
                <a href="../scaling/summary.html">
            
                    
                    4.5 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="../e2e/problem.html">
            
                <a href="../e2e/problem.html">
            
                    
                    Chapter 5: End-to-End Protocols
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.6.1" data-path="../e2e/udp.html">
            
                <a href="../e2e/udp.html">
            
                    
                    5.1 Simple Demultiplexor (UDP)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2" data-path="../e2e/tcp.html">
            
                <a href="../e2e/tcp.html">
            
                    
                    5.2 Reliable Byte Stream (TCP)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.3" data-path="../e2e/rpc.html">
            
                <a href="../e2e/rpc.html">
            
                    
                    5.3 Remote Procedure Call
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.4" data-path="../e2e/rtp.html">
            
                <a href="../e2e/rtp.html">
            
                    
                    5.4 Transport for Real-Time (RTP)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.5" data-path="../e2e/summary.html">
            
                <a href="../e2e/summary.html">
            
                    
                    5.5 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="../congestion/problem.html">
            
                <a href="../congestion/problem.html">
            
                    
                    Chapter 6: Congestion Control
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.1" data-path="../congestion/issues.html">
            
                <a href="../congestion/issues.html">
            
                    
                    6.1 Issues in Resource Allocation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.2" data-path="../congestion/queuing.html">
            
                <a href="../congestion/queuing.html">
            
                    
                    6.2 Queuing Disciplines
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.3" data-path="../congestion/tcpcc.html">
            
                <a href="../congestion/tcpcc.html">
            
                    
                    6.3 TCP Congestion Control
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4" data-path="../congestion/avoidance.html">
            
                <a href="../congestion/avoidance.html">
            
                    
                    6.4 Congestion-Avoidance
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.5" data-path="../congestion/qos.html">
            
                <a href="../congestion/qos.html">
            
                    
                    6.5 Quality of Service
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.6" data-path="../congestion/summary.html">
            
                <a href="../congestion/summary.html">
            
                    
                    6.6 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="../data/problem.html">
            
                <a href="../data/problem.html">
            
                    
                    Chapter 7: End-to-End Data
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.8.1" data-path="../data/presentation.html">
            
                <a href="../data/presentation.html">
            
                    
                    7.1 Presentation Formatting
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.2" data-path="../data/multimedia.html">
            
                <a href="../data/multimedia.html">
            
                    
                    7.2 Multimedia Data
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.3" data-path="../data/summary.html">
            
                <a href="../data/summary.html">
            
                    
                    7.3 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="../security/problem.html">
            
                <a href="../security/problem.html">
            
                    
                    Chapter 8: Network Security
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.9.1" data-path="../security/crypto.html">
            
                <a href="../security/crypto.html">
            
                    
                    8.1 Cryptographic Building Blocks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2" data-path="../security/key-distro.html">
            
                <a href="../security/key-distro.html">
            
                    
                    8.2 Key Predistribution
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.3" data-path="../security/authentication.html">
            
                <a href="../security/authentication.html">
            
                    
                    8.3 Authentication Protocols
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.4" data-path="../security/systems.html">
            
                <a href="../security/systems.html">
            
                    
                    8.4 Example Systems
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.5" data-path="../security/summary.html">
            
                <a href="../security/summary.html">
            
                    
                    8.5 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="../applications/problem.html">
            
                <a href="../applications/problem.html">
            
                    
                    Chapter 9: Applications
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.10.1" data-path="../applications/traditional.html">
            
                <a href="../applications/traditional.html">
            
                    
                    9.1 Traditional Applications
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.2" data-path="../applications/multimedia.html">
            
                <a href="../applications/multimedia.html">
            
                    
                    9.2 Multimedia Applications
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.3" data-path="../applications/infrastructure.html">
            
                <a href="../applications/infrastructure.html">
            
                    
                    9.3 Infrastructure Applications
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.4" data-path="../applications/overlays.html">
            
                <a href="../applications/overlays.html">
            
                    
                    9.4 Overlay Networks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.5" data-path="../applications/summary.html">
            
                <a href="../applications/summary.html">
            
                    
                    9.5 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >3.3 Routing</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="33-routing">3.3 Routing</h1>
<p>So far in this chapter we have assumed that the switches and routers
have enough knowledge of the network topology so they can choose the
right port onto which each packet should be output. In the case of
virtual circuits, routing is an issue only for the connection request
packet; all subsequent packets follow the same path as the request. In
datagram networks, including IP networks, routing is an issue for every
packet. In either case, a switch or router needs to be able to look at a
destination address and then to determine which of the output ports is
the best choice to get a packet to that address. As we saw in an earlier
section, the switch makes this decision by consulting a forwarding
table. The fundamental problem of routing is how switches and routers
acquire the information in their forwarding tables.</p>
<p>We restate an important distinction, which is often neglected, between
<em>forwarding</em> and <em>routing</em>. Forwarding consists of taking a packet,
looking at its destination address, consulting a table, and sending the
packet in a direction determined by that table. We saw several examples
of forwarding in the preceding section. Routing is the process by which
forwarding tables are built. We also note that forwarding is a
relatively simple and well-defined process performed locally at a node,
whereas routing depends on complex distributed algorithms that have
continued to evolve throughout the history of networking.</p>
<p>While the terms <em>forwarding table</em> and <em>routing table</em> are sometimes 
used interchangeably, we will make a distinction between them here. The
forwarding table is used when a packet is being forwarded and so must
contain enough information to accomplish the forwarding function. This
means that a row in the forwarding table contains the mapping from a
network prefix to an outgoing interface and some MAC information, such
as the Ethernet address of the next hop. The routing table, on the other
hand, is the table that is built up by the routing algorithms as a
precursor to building the forwarding table. It generally contains
mappings from network prefixes to next hops. It may also contain
information about how this information was learned, so that the router
will be able to decide when it should discard some information.</p>
<p>Whether the routing table and forwarding table are actually separate
data structures is something of an implementation choice, but there are
numerous reasons to keep them separate. For example, the forwarding
table needs to be structured to optimize the process of looking up an
address when forwarding a packet, while the routing table needs to be
optimized for the purpose of calculating changes in topology. In many
cases, the forwarding table may even be implemented in specialized
hardware, whereas this is rarely if ever done for the routing table.
<a href="#rtab-ftab">Table 1</a> below provides an example of a row from each sort
of table. In this case, the routing table tells us that network prefix 18/8
is to be reached by a next hop router with the IP address 171.69.245.10,
while the forwarding table contains the information about exactly how to
forward a packet to that next hop: Send it out interface number 0 with a
MAC address of 8:0:2b:e4:b:1:2. Note that the last piece of information
is provided by the Address Resolution Protocol.</p>
<p><a id="rtab-ftab"></a></p>
<p>(a)</p>
<table>
<thead>
<tr>
<th style="text-align:center">Prefix/Length</th>
<th style="text-align:center">Next Hop</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">18/8</td>
<td style="text-align:center">171.69.245.10</td>
</tr>
</tbody>
</table>
<p>(b)</p>
<table>
<thead>
<tr>
<th style="text-align:center">Prefix/Length</th>
<th style="text-align:center">Interface</th>
<th style="text-align:center">MAC Address</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">18/8</td>
<td style="text-align:center">if0</td>
<td style="text-align:center">8:0:2b:e4:b:1:2</td>
</tr>
</tbody>
</table>
<div class="ba-center"><p><em>Table 1. Example Rows from (a) Routing and (b) Forwarding Tables.</em></p></div>

<p>Before getting into the details of routing, we need to remind ourselves
of the key question we should be asking anytime we try to build a
mechanism for the Internet: &quot;Does this solution scale?&quot; The answer for
the algorithms and protocols described in this section is &quot;not so much.&quot;
They are designed for networks of fairly modest size&#x2014;up to a few
hundred nodes, in practice. However, the solutions we describe do serve
as a building block for a hierarchical routing infrastructure that is
used in the Internet today. Specifically, the protocols described in
this section are collectively known as <em>intradomain</em> routing protocols,
or <em>interior gateway protocols</em> (IGPs). To understand these terms, we
need to define a routing <em>domain</em>. A good working definition is an
internetwork in which all the routers are under the same administrative
control (e.g., a single university campus, or the network of a single
Internet Service Provider). The relevance of this definition will become
apparent in the next chapter when we look at <em>interdomain</em> routing
protocols. For now, the important thing to keep in mind is that we are
considering the problem of routing in the context of small to midsized
networks, not for a network the size of the Internet.</p>
<h2 id="network-as-a-graph">Network as a Graph</h2>
<p>Routing is, in essence, a problem of graph theory.
<a href="#graph-route">Figure 1</a> shows a graph representing a network.
The nodes of the graph, labeled A through F, may be hosts, switches,
routers, or networks. For our initial discussion, we will focus on the
case where the nodes are routers. The edges of the graph correspond to
the network links. Each edge has an associated <em>cost</em>, which gives some
indication of the desirability of sending traffic over that link. A
discussion of how edge costs are assigned is given in a later
section.</p>
<blockquote>
<p>In the example networks (graphs) used throughout this chapter, we 
use undirected edges and assign each edge a single cost. This is 
actually a slight simplification. It is more accurate to make the 
edges directed, which typically means that there would be a pair of 
edges between each node&#x2014;one flowing in each direction, and each 
with its own edge cost. </p>
</blockquote>
<figure class="line">
    <a id="graph-route"></a>
    <img src="figures/f03-28-9780123850591.png" width="400px">
    <figcaption>Network represented as a graph.</figcaption>
</figure>

<p>The basic problem of routing is to find the lowest-cost path between any
two nodes, where the cost of a path equals the sum of the costs of all
the edges that make up the path. For a simple network like the one in
<a href="#graph-route">Figure 1</a>, you could imagine just calculating all the
shortest paths and loading them into some nonvolatile storage on each
node. Such a static approach has several shortcomings:</p>
<ul>
<li><p>It does not deal with node or link failures.</p>
</li>
<li><p>It does not consider the addition of new nodes or links.</p>
</li>
<li><p>It implies that edge costs cannot change, even though we might
  reasonably wish to have link costs change over time (e.g., assigning
  high cost to a link that is heavily loaded).</p>
</li>
</ul>
<p>For these reasons, routing is achieved in most practical networks by
running routing protocols among the nodes. These protocols provide a
distributed, dynamic way to solve the problem of finding the lowest-cost
path in the presence of link and node failures and changing edge costs.
Note the word <em>distributed</em> in the previous sentence; it is difficult to
make centralized solutions scalable, so all the widely used routing
protocols use distributed algorithms.</p>
<p>The distributed nature of routing algorithms is one of the main reasons
why this has been such a rich field of research and development&#x2014;there
are a lot of challenges in making distributed algorithms work well. For
example, distributed algorithms raise the possibility that two routers
will at one instant have different ideas about the shortest path to some
destination. In fact, each one may think that the other one is closer to
the destination and decide to send packets to the other one. Clearly,
such packets will be stuck in a loop until the discrepancy between the
two routers is resolved, and it would be good to resolve it as soon as
possible. This is just one example of the type of problem routing
protocols must address.</p>
<p>To begin our analysis, we assume that the edge costs in the network are
known. We will examine the two main classes of routing protocols:
<em>distance vector</em> and <em>link state</em>. In a later section, we return to the
problem of calculating edge costs in a meaningful way.</p>
<h2 id="distance-vector-rip">Distance-Vector (RIP)</h2>
<p>The idea behind the distance-vector algorithm is suggested by its
name. (The other common name for this class of algorithm is
Bellman-Ford, after its inventors.) Each node constructs a
one-dimensional array (a vector) containing the &quot;distances&quot; (costs) to
all other nodes and distributes that vector to its immediate
neighbors. The starting assumption for distance-vector routing is that
each node knows the cost of the link to each of its directly connected
neighbors. These costs may be provided when the router is configured
by a network manager. A link that is down is assigned an infinite cost.</p>
<figure class="line">
    <a id="dvroute"></a>
    <img src="figures/f03-29-9780123850591.png" width="400px">
    <figcaption>Distance-vector routing: an example network.</figcaption>
</figure>

<p><a id="dvtab1"></a></p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">C</th>
<th style="text-align:center">D</th>
<th style="text-align:center">E</th>
<th style="text-align:center">F</th>
<th style="text-align:center">G</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">&#x221E;</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">&#x221E;</span></span></span></span></td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">&#x221E;</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">&#x221E;</span></span></span></span></td>
</tr>
<tr>
<td style="text-align:center">B</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">&#x221E;</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">&#x221E;</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">&#x221E;</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">&#x221E;</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">&#x221E;</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">&#x221E;</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">&#x221E;</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">&#x221E;</span></span></span></span></td>
</tr>
<tr>
<td style="text-align:center">C</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">&#x221E;</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">&#x221E;</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">&#x221E;</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">&#x221E;</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">&#x221E;</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">&#x221E;</span></span></span></span></td>
</tr>
<tr>
<td style="text-align:center">D</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">&#x221E;</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">&#x221E;</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">&#x221E;</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">&#x221E;</span></span></span></span></td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">&#x221E;</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">&#x221E;</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">&#x221E;</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">&#x221E;</span></span></span></span></td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">E</td>
<td style="text-align:center">1</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">&#x221E;</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">&#x221E;</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">&#x221E;</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">&#x221E;</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">&#x221E;</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">&#x221E;</span></span></span></span></td>
<td style="text-align:center">0</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">&#x221E;</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">&#x221E;</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">&#x221E;</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">&#x221E;</span></span></span></span></td>
</tr>
<tr>
<td style="text-align:center">F</td>
<td style="text-align:center">1</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">&#x221E;</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">&#x221E;</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">&#x221E;</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">&#x221E;</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">&#x221E;</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">&#x221E;</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">&#x221E;</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">&#x221E;</span></span></span></span></td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">G</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">&#x221E;</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">&#x221E;</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">&#x221E;</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">&#x221E;</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">&#x221E;</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">&#x221E;</span></span></span></span></td>
<td style="text-align:center">1</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">&#x221E;</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">&#x221E;</span></span></span></span></td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
<div class="ba-center"><p><em>Table 2. Initial Distances Stored at Each Node (Global View).</em></p></div>

<p>To see how a distance-vector routing algorithm works, it is easiest to
consider an example like the one depicted in
<a href="#dvroute">Figure 2</a>. In this example, the cost of each link is set to 1,
so that a least-cost path is simply the one with the fewest
hops. (Since all edges have the same cost, we do not show the costs in
the graph.) We can represent each node&apos;s knowledge about the distances
to all other nodes as a table like <a href="#dvtab1">Table 2</a>. Note that each
node knows only the information in one row of the table (the one that
bears its name in the left column). The global view that is presented
here is not available at any single point in the network.</p>
<p>We may consider each row in <a href="#dvtab1">Table 2</a> as a list of distances
from one node to all other nodes, representing the current beliefs of
that node. Initially, each node sets a cost of 1 to its directly connected
neighbors and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">&#x221E;</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">&#x221E;</span></span></span></span> to all other nodes. Thus, A initially believes
that it can reach B in one hop and that D is unreachable. The routing
table stored at A reflects this set of beliefs and includes the name of
the next hop that A would use to reach any reachable node. Initially,
then, A&apos;s routing table would look like <a href="#dvtab2">Table 3</a>.</p>
<p><a id="dvtab2"></a></p>
<table>
<thead>
<tr>
<th style="text-align:center">Destination</th>
<th style="text-align:center">Cost</th>
<th style="text-align:center">NextHop</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">B</td>
<td style="text-align:center">1</td>
<td style="text-align:center">B</td>
</tr>
<tr>
<td style="text-align:center">C</td>
<td style="text-align:center">1</td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">D</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">&#x221E;</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">&#x221E;</span></span></span></span></td>
<td style="text-align:center">&#x2014;</td>
</tr>
<tr>
<td style="text-align:center">E</td>
<td style="text-align:center">1</td>
<td style="text-align:center">E</td>
</tr>
<tr>
<td style="text-align:center">F</td>
<td style="text-align:center">1</td>
<td style="text-align:center">F</td>
</tr>
<tr>
<td style="text-align:center">G</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">&#x221E;</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">&#x221E;</span></span></span></span></td>
<td style="text-align:center">&#x2014;</td>
</tr>
</tbody>
</table>
<div class="ba-center"><p><em>Table 3. Initial Routing Table at Node A.</em></p></div>

<p>The next step in distance-vector routing is that every node sends a
message to its directly connected neighbors containing its personal list
of distances. For example, node F tells node A that it can reach node G
at a cost of 1; A also knows it can reach F at a cost of 1, so it adds
these costs to get the cost of reaching G by means of F. This total cost
of 2 is less than the current cost of infinity, so A records that it can
reach G at a cost of 2 by going through F. Similarly, A learns from C
that D can be reached from C at a cost of 1; it adds this to the cost of
reaching C (1) and decides that D can be reached via C at a cost of 2,
which is better than the old cost of infinity. At the same time, A
learns from C that B can be reached from C at a cost of 1, so it
concludes that the cost of reaching B via C is 2. Since this is worse
than the current cost of reaching B (1), this new information is
ignored.</p>
<p>At this point, A can update its routing table with costs and next hops
for all nodes in the network. The result is shown in
<a href="#dvtab3">Table 4</a>.</p>
<p><a id="dvtab3"></a></p>
<table>
<thead>
<tr>
<th style="text-align:center">Destination</th>
<th style="text-align:center">Cost</th>
<th style="text-align:center">NextHop</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">B</td>
<td style="text-align:center">1</td>
<td style="text-align:center">B</td>
</tr>
<tr>
<td style="text-align:center">C</td>
<td style="text-align:center">1</td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">D</td>
<td style="text-align:center">2</td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">E</td>
<td style="text-align:center">1</td>
<td style="text-align:center">E</td>
</tr>
<tr>
<td style="text-align:center">F</td>
<td style="text-align:center">1</td>
<td style="text-align:center">F</td>
</tr>
<tr>
<td style="text-align:center">G</td>
<td style="text-align:center">2</td>
<td style="text-align:center">F</td>
</tr>
</tbody>
</table>
<div class="ba-center"><p><em>Table 4. Final Routing Table at Node A.</em></p></div>

<p><a id="dvtab4"></a></p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">C</th>
<th style="text-align:center">D</th>
<th style="text-align:center">E</th>
<th style="text-align:center">F</th>
<th style="text-align:center">G</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">B</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">C</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">D</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">3</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">E</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">F</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">G</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">3</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
<div class="ba-center"><p><em>Table 5. Final Distances Stored at Each Node (Global View).</em></p></div>

<p>In the absence of any topology changes, it takes only a few exchanges of
information between neighbors before each node has a complete routing
table. The process of getting consistent routing information to all the
nodes is called <em>convergence</em>.  <a href="#dvtab4">Table 5</a> shows the final set
of costs from each node to all other nodes when routing has converged.
We must stress that there is no one node in the network that has all the
information in this table&#x2014;each node only knows about the contents of
its own routing table. The beauty of a distributed algorithm like this
is that it enables all nodes to achieve a consistent view of the network
in the absence of any centralized authority.</p>
<p>There are a few details to fill in before our discussion of
distance-vector routing is complete. First we note that there are two
different circumstances under which a given node decides to send a
routing update to its neighbors. One of these circumstances is the
<em>periodic</em> update. In this case, each node automatically sends an update
message every so often, even if nothing has changed. This serves to let
the other nodes know that this node is still running. It also makes sure
that they keep getting information that they may need if their current
routes become unviable. The frequency of these periodic updates varies
from protocol to protocol, but it is typically on the order of several
seconds to several minutes. The second mechanism, sometimes called a
<em>triggered</em> update, happens whenever a node notices a link failure or
receives an update from one of its neighbors that causes it to change
one of the routes in its routing table. Whenever a node&apos;s routing table
changes, it sends an update to its neighbors, which may lead to a change
in their tables, causing them to send an update to their neighbors.</p>
<p>Now consider what happens when a link or node fails. The nodes that
notice first send new lists of distances to their neighbors, and
normally the system settles down fairly quickly to a new state. As to
the question of how a node detects a failure, there are a couple of
different answers. In one approach, a node continually tests the link to
another node by sending a control packet and seeing if it receives an
acknowledgment. In another approach, a node determines that the link (or
the node at the other end of the link) is down if it does not receive
the expected periodic routing update for the last few update cycles.</p>
<p>To understand what happens when a node detects a link failure, consider
what happens when F detects that its link to G has failed. First, F sets
its new distance to G to infinity and passes that information along
to A. Since A knows that its 2-hop path to G is through F, A would also
set its distance to G to infinity. However, with the next update from C,
A would learn that C has a 2-hop path to G. Thus, A would know that it
could reach G in 3 hops through C, which is less than infinity, and so A
would update its table accordingly. When it advertises this to F, node F
would learn that it can reach G at a cost of 4 through A, which is less
than infinity, and the system would again become stable.</p>
<p>Unfortunately, slightly different circumstances can prevent the network
from stabilizing. Suppose, for example, that the link from A to E goes
down. In the next round of updates, A advertises a distance of infinity
to E, but B and C advertise a distance of 2 to E. Depending on the exact
timing of events, the following might happen: Node B, upon hearing that
E can be reached in 2 hops from C, concludes that it can reach E in
3 hops and advertises this to A; node A concludes that it can reach E in
4 hops and advertises this to C; node C concludes that it can reach E in
5 hops; and so on. This cycle stops only when the distances reach some
number that is large enough to be considered infinite. In the meantime,
none of the nodes actually knows that E is unreachable, and the routing
tables for the network do not stabilize. This situation is known as the
<em>count to infinity</em> problem.</p>
<p>There are several partial solutions to this problem. The first one is to
use some relatively small number as an approximation of infinity. For
example, we might decide that the maximum number of hops to get across a
certain network is never going to be more than 16, and so we could pick
16 as the value that represents infinity. This at least bounds the
amount of time that it takes to count to infinity. Of course, it could
also present a problem if our network grew to a point where some nodes
were separated by more than 16 hops.</p>
<p>One technique to improve the time to stabilize routing is called <em>split
horizon</em>. The idea is that when a node sends a routing update to its
neighbors, it does not send those routes it learned from each neighbor
back to that neighbor. For example, if B has the route (E, 2, A) in
its table, then it knows it must have learned this route from A, and so
whenever B sends a routing update to A, it does not include the route
(E, 2) in that update. In a stronger variation of split horizon,
called <em>split horizon with poison reverse</em>, B actually sends that route
back to A, but it puts negative information in the route to ensure that
A will not eventually use B to get to E. For example, B sends the route
(E, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">&#x221E;</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">&#x221E;</span></span></span></span>) to A. The problem with both of these techniques is that
they only work for routing loops that involve two nodes. For larger
routing loops, more drastic measures are called for. Continuing the
above example, if B and C had waited for a while after hearing of the
link failure from A before advertising routes to E, they would have
found that neither of them really had a route to E. Unfortunately, this
approach delays the convergence of the protocol; speed of convergence is
one of the key advantages of its competitor, link-state routing, the
subject of a later section.</p>
<h3 id="implementation">Implementation</h3>
<p>The code that implements this algorithm is very straightforward; we give
only some of the basics here. Structure <code>Route</code> defines each entry in
the routing table, and constant <code>MAX_TTL</code> specifies how long an entry
is kept in the table before it is discarded.</p>
<pre><code class="lang-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_ROUTES      128     <span class="hljs-comment">/* maximum size of routing table */</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_TTL         120     <span class="hljs-comment">/* time (in seconds) until route expires */</span></span>

<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> {
    NodeAddr  Destination;    <span class="hljs-comment">/* address of destination */</span>
    NodeAddr  NextHop;        <span class="hljs-comment">/* address of next hop */</span>
    <span class="hljs-keyword">int</span>        Cost;          <span class="hljs-comment">/* distance metric */</span>
    u_short   TTL;            <span class="hljs-comment">/* time to live */</span>
} Route;

<span class="hljs-keyword">int</span>      numRoutes = <span class="hljs-number">0</span>;
Route    routingTable[MAX_ROUTES];
</code></pre>
<p>The routine that updates the local node&apos;s routing table based on a new
route is given by <code>mergeRoute</code>. Although not shown, a timer function
periodically scans the list of routes in the node&apos;s routing table,
decrements the <code>TTL</code> (time to live) field of each route, and discards
any routes that have a time to live of 0. Notice, however, that the
<code>TTL</code> field is reset to <code>MAX_TTL</code> any time the route is reconfirmed by
an update message from a neighboring node.</p>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">mergeRoute</span> <span class="hljs-params">(Route *new)</span>
</span>{
    <span class="hljs-keyword">int</span> i;

    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; numRoutes; ++i)
    {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span>-&gt;Destination == routingTable[i].Destination)
        {
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span>-&gt;Cost + <span class="hljs-number">1</span> &lt; routingTable[i].Cost)
            {
                <span class="hljs-comment">/* found a better route: */</span>
                <span class="hljs-keyword">break</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span>-&gt;NextHop == routingTable[i].NextHop) {
                <span class="hljs-comment">/* metric for current next-hop may have changed: */</span>
                <span class="hljs-keyword">break</span>;
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">/* route is uninteresting---just ignore it */</span>
                <span class="hljs-keyword">return</span>;
            }
        }
    }
    <span class="hljs-keyword">if</span> (i == numRoutes)
    {
        <span class="hljs-comment">/* this is a completely new route; is there room for it? */</span>
        <span class="hljs-keyword">if</span> (numRoutes &lt; MAXROUTES)
        {
            ++numRoutes;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">/* can`t fit this route in table so give up */</span>
            <span class="hljs-keyword">return</span>;
        }
    }
    routingTable[i] = *<span class="hljs-keyword">new</span>;
    <span class="hljs-comment">/* reset TTL */</span>
    routingTable[i].TTL = MAX_TTL;
    <span class="hljs-comment">/* account for hop to get to next node */</span>
    ++routingTable[i].Cost;
}
</code></pre>
<p>Finally, the procedure <code>updateRoutingTable</code> is the main routine that
calls <code>mergeRoute</code> to incorporate all the routes contained in a routing
update that is received from a neighboring node.</p>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">updateRoutingTable</span> <span class="hljs-params">(Route *newRoute, <span class="hljs-keyword">int</span> numNewRoutes)</span>
</span>{
    <span class="hljs-keyword">int</span> i;

    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i &lt; numNewRoutes; ++i)
    {
        mergeRoute(&amp;newRoute[i]);
    }
}
</code></pre>
<h3 id="routing-information-protocol-rip">Routing Information Protocol (RIP)</h3>
<p>One of the more widely used routing protocols in IP networks is the
Routing Information Protocol (RIP). Its widespread use in the early days
of IP was due in no small part to the fact that it was distributed along
with the popular Berkeley Software Distribution (BSD) version of Unix,
from which many commercial versions of Unix were derived. It is also
extremely simple. RIP is the canonical example of a routing protocol
built on the distance-vector algorithm just described.</p>
<p>Routing protocols in internetworks differ very slightly from the
idealized graph model described above. In an internetwork, the goal of
the routers is to learn how to forward packets to various <em>networks</em>.
Thus, rather than advertising the cost of reaching other routers, the
routers advertise the cost of reaching networks. For example, in
<a href="#rip-eg">Figure 3</a>, router C would advertise to router A the fact
that it can reach networks 2 and 3 (to which it is directly connected)
at a cost of 0, networks 5 and 6 at cost 1, and network 4 at cost 2.</p>
<figure class="line">
    <a id="rip-eg"></a>
    <img src="figures/f03-30-9780123850591.png" width="300px">
    <figcaption>Example network running RIP.</figcaption>
</figure>

<figure class="line">
    <a id="rip"></a>
    <img src="figures/f03-31-9780123850591.png" width="300px">
    <figcaption>RIPv2 packet format.</figcaption>
</figure>

<p>We can see evidence of this in the RIP (version 2) packet format in
<a href="#rip">Figure 4</a>. The majority of the packet is taken up with
<code>(address, mask, distance)</code> triples. However, the
principles of the routing algorithm are just the same. For example, if
router A learns from router B that network X can be reached at a lower
cost via B than via the existing next hop in the routing table, A
updates the cost and next hop information for the network number
accordingly.</p>
<p>RIP is in fact a fairly straightforward implementation of
distance-vector routing. Routers running RIP send their advertisements
every 30 seconds; a router also sends an update message whenever an
update from another router causes it to change its routing table. One
point of interest is that it supports multiple address families, not
just IP&#x2014;that is the reason for the <code>Family</code> part of the
advertisements. RIP version 2 (RIPv2) also introduced the subnet masks
described in an earlier section, whereas RIP version 1 worked with the
old classful addresses of IP.</p>
<p>As we will see below, it is possible to use a range of different metrics
or costs for the links in a routing protocol. RIP takes the simplest
approach, with all link costs being equal to 1, just as in our example
above. Thus, it always tries to find the minimum hop route. Valid
distances are 1 through 15, with 16 representing infinity. This also
limits RIP to running on fairly small networks&#x2014;those with no paths
longer than 15 hops.</p>
<h2 id="link-state-ospf">Link State (OSPF)</h2>
<p>Link-state routing is the second major class of intradomain routing
protocol. The starting assumptions for link-state routing are rather
similar to those for distance-vector routing. Each node is assumed to be
capable of finding out the state of the link to its neighbors (up or
down) and the cost of each link. Again, we want to provide each node
with enough information to enable it to find the least-cost path to any
destination. The basic idea behind link-state protocols is very simple:
Every node knows how to reach its directly connected neighbors, and if
we make sure that the totality of this knowledge is disseminated to
every node, then every node will have enough knowledge of the network to
build a complete map of the network. This is clearly a sufficient
condition (although not a necessary one) for finding the shortest path
to any point in the network. Thus, link-state routing protocols rely on
two mechanisms: reliable dissemination of link-state information, and
the calculation of routes from the sum of all the accumulated link-state
knowledge.</p>
<h3 id="reliable-flooding">Reliable Flooding</h3>
<p><em>Reliable flooding</em> is the process of making sure that all the nodes
participating in the routing protocol get a copy of the link-state
information from all the other nodes. As the term <em>flooding</em> suggests,
the basic idea is for a node to send its link-state information out on
all of its directly connected links; each node that receives this
information then forwards it out on all of <em>its</em> links. This process
continues until the information has reached all the nodes in the
network.</p>
<p>More precisely, each node creates an update packet, also called a
<em>link-state packet</em> (LSP), which contains the following information:</p>
<ul>
<li><p>The ID of the node that created the LSP</p>
</li>
<li><p>A list of directly connected neighbors of that node, with the cost
  of the link to each one</p>
</li>
<li><p>A sequence number</p>
</li>
<li><p>A time to live for this packet</p>
</li>
</ul>
<p>The first two items are needed to enable route calculation; the last two
are used to make the process of flooding the packet to all nodes
reliable. Reliability includes making sure that you have the most recent
copy of the information, since there may be multiple, contradictory LSPs
from one node traversing the network. Making the flooding reliable has
proven to be quite difficult. (For example, an early version of
link-state routing used in the ARPANET caused that network to fail in
1981.)</p>
<p>Flooding works in the following way. First, the transmission of LSPs
between adjacent routers is made reliable using acknowledgments and
retransmissions just as in the reliable link-layer protocol. However,
several more steps are necessary to reliably flood an LSP to all nodes
in a network.</p>
<p>Consider a node X that receives a copy of an LSP that originated at some
other node Y. Note that Y may be any other router in the same routing
domain as X. X checks to see if it has already stored a copy of an LSP
from Y. If not, it stores the LSP. If it already has a copy, it compares
the sequence numbers; if the new LSP has a larger sequence number, it is
assumed to be the more recent, and that LSP is stored, replacing the old
one. A smaller (or equal) sequence number would imply an LSP older (or
not newer) than the one stored, so it would be discarded and no further
action would be needed. If the received LSP was the newer one, X then
sends a copy of that LSP to all of its neighbors except the neighbor
from which the LSP was just received. The fact that the LSP is not sent
back to the node from which it was received helps to bring an end to the
flooding of an LSP. Since X passes the LSP on to all its neighbors, who
then turn around and do the same thing, the most recent copy of the LSP
eventually reaches all nodes.</p>
<figure class="line">
    <a id="flood"></a>
    <img src="figures/f03-32-9780123850591.png" width="500px">
    <figcaption>Flooding of link-state packets: (a) LSP arrives at
    node X; (b) X floods LSP to A and C; (c) A and C flood LSP to B
    (but not X); (d) flooding is complete.</figcaption>
</figure>

<p><a href="#flood">Figure 5</a> shows an LSP being flooded in a small
network. Each node becomes shaded as it stores the new LSP. In
<a href="#flood">Figure 5(a)</a> the LSP arrives at node X, which sends it to
neighbors A and C in <a href="#flood">Figure 5(b)</a>. A and C do not send it back
to X, but send it on to B. Since B receives two identical copies of
the LSP, it will accept whichever arrived first and ignore the second
as a duplicate. It then passes the LSP onto D, which has no neighbors
to flood it to, and the process is complete.</p>
<p>Just as in RIP, each node generates LSPs under two circumstances. Either
the expiry of a periodic timer or a change in topology can cause a node
to generate a new LSP. However, the only topology-based reason for a
node to generate an LSP is if one of its directly connected links or
immediate neighbors has gone down. The failure of a link can be detected
in some cases by the link-layer protocol. The demise of a neighbor or
loss of connectivity to that neighbor can be detected using periodic
&quot;hello&quot; packets. Each node sends these to its immediate neighbors at
defined intervals. If a sufficiently long time passes without receipt of
a &quot;hello&quot; from a neighbor, the link to that neighbor will be declared
down, and a new LSP will be generated to reflect this fact.</p>
<p>One of the important design goals of a link-state protocol&apos;s flooding
mechanism is that the newest information must be flooded to all nodes as
quickly as possible, while old information must be removed from the
network and not allowed to circulate. In addition, it is clearly
desirable to minimize the total amount of routing traffic that is sent
around the network; after all, this is just overhead from the
perspective of those who actually use the network for their
applications. The next few paragraphs describe some of the ways that
these goals are accomplished.</p>
<p>One easy way to reduce overhead is to avoid generating LSPs unless
absolutely necessary. This can be done by using very long timers&#x2014;often
on the order of hours&#x2014;for the periodic generation of LSPs. Given that
the flooding protocol is truly reliable when topology changes, it is
safe to assume that messages saying &quot;nothing has changed&quot; do not need to
be sent very often.</p>
<p>To make sure that old information is replaced by newer information, LSPs
carry sequence numbers. Each time a node generates a new LSP, it
increments the sequence number by 1. Unlike most sequence numbers used
in protocols, these sequence numbers are not expected to wrap, so the
field needs to be quite large (say, 64 bits). If a node goes down and
then comes back up, it starts with a sequence number of 0. If the node
was down for a long time, all the old LSPs for that node will have timed
out (as described below); otherwise, this node will eventually receive a
copy of its own LSP with a higher sequence number, which it can then
increment and use as its own sequence number. This will ensure that its
new LSP replaces any of its old LSPs left over from before the node went
down.</p>
<p>LSPs also carry a time to live. This is used to ensure that old
link-state information is eventually removed from the network. A node
always decrements the TTL of a newly received LSP before flooding it to
its neighbors. It also &quot;ages&quot; the LSP while it is stored in the node.
When the TTL reaches 0, the node refloods the LSP with a TTL of 0, which
is interpreted by all the nodes in the network as a signal to delete
that LSP.</p>
<h3 id="route-calculation">Route Calculation</h3>
<p>Once a given node has a copy of the LSP from every other node, it is
able to compute a complete map for the topology of the network, and from
this map it is able to decide the best route to each destination. The
question, then, is exactly how it calculates routes from this
information. The solution is based on a well-known algorithm from graph
theory&#x2014;Dijkstra&apos;s shortest-path algorithm.</p>
<p>We first define Dijkstra&apos;s algorithm in graph-theoretic terms. Imagine
that a node takes all the LSPs it has received and constructs a
graphical representation of the network, in which N denotes the set of
nodes in the graph, l(i,j) denotes the nonnegative cost (weight)
associated with the edge between nodes i, j in N and l(i, j) = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">&#x221E;</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">&#x221E;</span></span></span></span>
if no edge connects i and j. In the following description, we let
s in N denote this node, that is, the node executing the algorithm to
find the shortest path to all the other nodes in N. Also, the
algorithm maintains the following two variables: M denotes the set of
nodes incorporated so far by the algorithm, and C(n) denotes the cost
of the path from s to each node n. Given these definitions, the
algorithm is defined as follows:</p>
<pre><code class="lang-pseudo">M = {s}
for each n in N - {s}
    C(n) = l(s,n)
while (N != M)
    M = M + {w} such that C(w) is the minimum for all w in (N-M)
    for each n in (N-M)
    C(n) = MIN(C(n), C(w)+l(w,n))
</code></pre>
<p>Basically, the algorithm works as follows. We start with M containing
this node s and then initialize the table of costs (the C(n)s) to
other nodes using the known costs to directly connected nodes. We then
look for the node that is reachable at the lowest cost (w) and add it
to M. Finally, we update the table of costs by considering the cost of
reaching nodes through w. In the last line of the algorithm, we choose
a new route to node n that goes through node w if the total cost of
going from the source to w and then following the link from w to n
is less than the old route we had to n. This procedure is repeated
until all nodes are incorporated in M.</p>
<p>In practice, each switch computes its routing table directly from the
LSPs it has collected using a realization of Dijkstra&apos;s algorithm called
the <em>forward search</em> algorithm. Specifically, each switch maintains two
lists, known as <code>Tentative</code> and <code>Confirmed</code>. Each of these lists
contains a set of entries of the form <code>(Destination, Cost, NextHop)</code>.
The algorithm works as follows:</p>
<ol>
<li><p>Initialize the <code>Confirmed</code> list with an entry for myself; this entry
 has a cost of 0.</p>
</li>
<li><p>For the node just added to the <code>Confirmed</code> list in the previous
 step, call it node <code>Next</code> and select its LSP.</p>
</li>
<li><p>For each neighbor (<code>Neighbor</code>) of <code>Next</code>, calculate the cost
 (<code>Cost</code>) to reach this <code>Neighbor</code> as the sum of the cost from myself
 to <code>Next</code> and from <code>Next</code> to <code>Neighbor</code>.</p>
<ol>
<li><p>If <code>Neighbor</code> is currently on neither the <code>Confirmed</code> nor the
<code>Tentative</code> list, then add <code>(Neighbor, Cost, NextHop)</code> to the
<code>Tentative</code> list, where <code>NextHop</code> is the direction I go to
reach <code>Next</code>.</p>
</li>
<li><p>If <code>Neighbor</code> is currently on the <code>Tentative</code> list, and the
<code>Cost</code> is less than the currently listed cost for <code>Neighbor</code>,
then replace the current entry with <code>(Neighbor, Cost, NextHop)</code>,
where <code>NextHop</code> is the direction I go to reach <code>Next</code>.</p>
</li>
</ol>
</li>
<li><p>If the <code>Tentative</code> list is empty, stop. Otherwise, pick the entry
 from the <code>Tentative</code> list with the lowest cost, move it to the
 <code>Confirmed</code> list, and return to step 2.</p>
</li>
</ol>
<figure class="line">
    <a id="lsroute"></a>
    <img src="figures/f03-33-9780123850591.png" width="350px">
    <figcaption>Link-state routing: an example network.</figcaption>
</figure>

<p>This will become a lot easier to understand when we look at an example.
Consider the network depicted in <a href="#lsroute">Figure 6</a>. Note that,
unlike our previous example, this network has a range of different edge
costs. <a href="#ls-trace">Table</a> traces the steps for building the routing
table for node D. We denote the two outputs of D by using the names of
the nodes to which they connect, B and C. Note the way the algorithm
seems to head off on false leads (like the 11-unit cost path to B that
was the first addition to the <code>Tentative</code> list) but ends up with the
least-cost paths to all nodes.</p>
<p><a id="ls_trace"></a></p>
<table>
<thead>
<tr>
<th style="text-align:center">Step</th>
<th style="text-align:center">Confirmed</th>
<th style="text-align:center">Tentative</th>
<th style="text-align:left">Comments</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">(D,0,--)</td>
<td style="text-align:center"></td>
<td style="text-align:left">Since D is the only new member of the confirmed list, look at its LSP.</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">(D,0,--)</td>
<td style="text-align:center">(B,11,B) (C,2,C)</td>
<td style="text-align:left">D&apos;s LSP says we can reach B through B at cost 11, which is better than anything else on either list, so put it on <code>Tentative</code> list; same for C.</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">(D,0,--) (C,2,C)</td>
<td style="text-align:center">(B,11,B)</td>
<td style="text-align:left">Put lowest-cost member of <code>Tentative</code> (C) onto <code>Confirmed</code> list. Next, examine LSP of newly confirmed member (C).</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">(D,0,--) (C,2,C)</td>
<td style="text-align:center">(B,5,C) (A,12,C)</td>
<td style="text-align:left">Cost to reach B through C is 5, so replace (B,11,B). C&apos;s LSP tells us that we can reach A at cost 12.</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">(D,0,--) (C,2,C) (B,5,C)</td>
<td style="text-align:center">(A,12,C)</td>
<td style="text-align:left">Move lowest-cost member of <code>Tentative</code> (B) to <code>Confirmed</code>, then look at its LSP.</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">(D,0,--) (C,2,C) (B,5,C)</td>
<td style="text-align:center">(A,10,C)</td>
<td style="text-align:left">Since we can reach A at cost 5 through B, replace the <code>Tentative</code> entry.</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">(D,0,--) (C,2,C) (B,5,C) (A,10,C)</td>
<td style="text-align:center"></td>
<td style="text-align:left">Move lowest-cost member of <code>Tentative</code> (A) to <code>Confirmed</code>, and we are all done.</td>
</tr>
</tbody>
</table>
<div class="ba-center"><p><em>Table 6. Steps for Building Routing Table for Node D.</em></p></div>

<p>The link-state routing algorithm has many nice properties: It has been
proven to stabilize quickly, it does not generate much traffic, and it
responds rapidly to topology changes or node failures. On the downside,
the amount of information stored at each node (one LSP for every other
node in the network) can be quite large. This is one of the fundamental
problems of routing and is an instance of the more general problem of
scalability. Some solutions to both the specific problem (the amount of
storage potentially required at each node) and the general problem
(scalability) will be discussed in the next section.</p>
<p>The difference between the distance-vector and link-state algorithms
can be summarized as follows. In distance-vector, each node talks only
to its directly connected neighbors, but it tells them everything it
has learned (i.e., distance to all nodes). In link-state, each node
talks to all other nodes, but it tells them only what it knows for
sure (i.e., only the state of its directly connected links).</p>
<h3 id="the-open-shortest-path-first-protocol-ospf">The Open Shortest Path First Protocol (OSPF)</h3>
<p>One of the most widely used link-state routing protocols is OSPF. The
first word, &quot;Open,&quot; refers to the fact that it is an open,
nonproprietary standard, created under the auspices of the Internet
Engineering Task Force (IETF). The &quot;SPF&quot; part comes from an alternative
name for link-state routing. OSPF adds quite a number of features to the
basic link-state algorithm described above, including the following:</p>
<ul>
<li><p><em>Authentication of routing messages</em>&#x2014;One feature of distributed
  routing algorithms is that they disperse information from one node
  to many other nodes, and the entire network can thus be impacted by
  bad information from one node. For this reason, it&apos;s a good idea to
  be sure that all the nodes taking part in the protocol can be
  trusted. Authenticating routing messages helps achieve this. Early
  versions of OSPF used a simple 8-byte password for authentication.
  This is not a strong enough form of authentication to prevent
  dedicated malicious users, but it alleviates some problems caused by
  misconfiguration or casual attacks. (A similar form of
  authentication was added to RIP in version 2.) Strong cryptographic
  authentication was later added.</p>
</li>
<li><p><em>Additional hierarchy</em>&#x2014;Hierarchy is one of the fundamental tools
  used to make systems more scalable. OSPF introduces another layer of
  hierarchy into routing by allowing a domain to be partitioned into
  <em>areas</em>. This means that a router within a domain does not
  necessarily need to know how to reach every network within that
  domain&#x2014;it may be able to get by knowing only how to get to the
  right area. Thus, there is a reduction in the amount of information
  that must be transmitted to and stored in each node.</p>
</li>
<li><p><em>Load balancing</em>&#x2014;OSPF allows multiple routes to the same place to
  be assigned the same cost and will cause traffic to be distributed
  evenly over those routes, thus making better use of available
  network capacity.</p>
</li>
</ul>
<figure class="line">
    <a id="ospf"></a>
    <img src="figures/f03-34-9780123850591.png" width="400px">
    <figcaption>OSPF header format.</figcaption>
</figure>

<p>There are several different types of OSPF messages, but all begin with
the same header, as shown in <a href="#ospf">Figure 7</a>. The <code>Version</code> field
is currently set to 2, and the <code>Type</code> field may take the values 1
through 5. The <code>SourceAddr</code> identifies the sender of the message, and
the <code>AreaId</code> is a 32-bit identifier of the area in which the node is
located. The entire packet, except the authentication data, is protected
by a 16-bit checksum using the same algorithm as the IP header. The
<code>Authentication type</code> is 0 if no authentication is used; otherwise, it
may be 1, implying that a simple password is used, or 2, which indicates
that a cryptographic authentication checksum is used. In the latter
cases, the <code>Authentication</code> field carries the password or cryptographic
checksum.</p>
<p>Of the five OSPF message types, type 1 is the &quot;hello&quot; message, which a
router sends to its peers to notify them that it is still alive and
connected as described above. The remaining types are used to request,
send, and acknowledge the receipt of link-state messages. The basic
building block of link-state messages in OSPF is the link-state
advertisement (LSA). One message may contain many LSAs. We provide a few
details of the LSA here.</p>
<p>Like any internetwork routing protocol, OSPF must provide information
about how to reach networks. Thus, OSPF must provide a little more
information than the simple graph-based protocol described above.
Specifically, a router running OSPF may generate link-state packets that
advertise one or more of the networks that are directly connected to
that router. In addition, a router that is connected to another router
by some link must advertise the cost of reaching that router over the
link. These two types of advertisements are necessary to enable all the
routers in a domain to determine the cost of reaching all networks in
that domain and the appropriate next hop for each network.</p>
<figure class="line">
    <a id="ospf-lsa"></a>
    <img src="figures/f03-35-9780123850591.png" width="450px">
    <figcaption>OSPF link-state advertisement.</figcaption>
</figure>

<p><a href="#ospf-lsa">Figure 8</a> shows the packet format for a type 1 link-state
advertisement. Type 1 LSAs advertise the cost of links between routers.
Type 2 LSAs are used to advertise networks to which the advertising
router is connected, while other types are used to support additional
hierarchy as described in the next section. Many fields in the LSA
should be familiar from the preceding discussion. The <code>LS Age</code> is the
equivalent of a time to live, except that it counts up and the LSA
expires when the age reaches a defined maximum value. The <code>Type</code> field
tells us that this is a type 1 LSA.</p>
<p>In a type 1 LSA, the <code>Link state ID</code> and the <code>Advertising router</code> field
are identical. Each carries a 32-bit identifier for the router that
created this LSA. While a number of assignment strategies may be used to
assign this ID, it is essential that it be unique in the routing domain
and that a given router consistently uses the same router ID. One way to
pick a router ID that meets these requirements would be to pick the
lowest IP address among all the IP addresses assigned to that router.
(Recall that a router may have a different IP address on each of its
interfaces.)</p>
<p>The <code>LS sequence number</code> is used exactly as described above to detect
old or duplicate LSAs. The <code>LS checksum</code> is similar to others we have
seen in other protocols; it is, of course, used to verify that data has
not been corrupted. It covers all fields in the packet except <code>LS Age</code>,
so it is not necessary to recompute a checksum every time <code>LS Age</code> is
incremented. <code>Length</code> is the length in bytes of the complete LSA.</p>
<p>Now we get to the actual link-state information. This is made a little
complicated by the presence of TOS (type of service) information.
Ignoring that for a moment, each link in the LSA is represented by a
<code>Link ID</code>, some <code>Link Data</code>, and a <code>metric</code>. The first two of these
fields identify the link; a common way to do this would be to use the
router ID of the router at the far end of the link as the <code>Link ID</code> and
then use the <code>Link Data</code> to disambiguate among multiple parallel links
if necessary. The <code>metric</code> is of course the cost of the link. <code>Type</code>
tells us something about the link&#x2014;for example, if it is a
point-to-point link.</p>
<p>The TOS information is present to allow OSPF to choose different routes
for IP packets based on the value in their TOS field. Instead of
assigning a single metric to a link, it is possible to assign different
metrics depending on the TOS value of the data. For example, if we had a
link in our network that was very good for delay-sensitive traffic, we
could give it a low metric for the TOS value representing low delay and
a high metric for everything else. OSPF would then pick a different
shortest path for those packets that had their TOS field set to that
value. It is worth noting that, at the time of writing, this capability
has not been widely deployed.</p>
<h2 id="metrics">Metrics</h2>
<p>The preceding discussion assumes that link costs, or metrics, are known
when we execute the routing algorithm. In this section, we look at some
ways to calculate link costs that have proven effective in practice. One
example that we have seen already, which is quite reasonable and very
simple, is to assign a cost of 1 to all links&#x2014;the least-cost route
will then be the one with the fewest hops. Such an approach has several
drawbacks, however. First, it does not distinguish between links on a
latency basis. Thus, a satellite link with 250-ms latency looks just as
attractive to the routing protocol as a terrestrial link with 1-ms
latency. Second, it does not distinguish between routes on a capacity
basis, making a 1-Mbps link look just as good as a 10-Gbps link.
Finally, it does not distinguish between links based on their current
load, making it impossible to route around overloaded links. It turns
out that this last problem is the hardest because you are trying to
capture the complex and dynamic characteristics of a link in a single
scalar cost.</p>
<p>The ARPANET was the testing ground for a number of different approaches
to link-cost calculation. (It was also the place where the superior
stability of link-state over distance-vector routing was demonstrated;
the original mechanism used distance vector while the later version used
link state.) The following discussion traces the evolution of the
ARPANET routing metric and, in so doing, explores the subtle aspects of
the problem.</p>
<p>The original ARPANET routing metric measured the number of packets that
were queued waiting to be transmitted on each link, meaning that a link
with 10 packets queued waiting to be transmitted was assigned a larger
cost weight than a link with 5 packets queued for transmission. Using
queue length as a routing metric did not work well, however, since queue
length is an artificial measure of load&#x2014;it moves packets toward the
shortest queue rather than toward the destination, a situation all too
familiar to those of us who hop from line to line at the grocery store.
Stated more precisely, the original ARPANET routing mechanism suffered
from the fact that it did not take either the bandwidth or the latency
of the link into consideration.</p>
<p>A second version of the ARPANET routing algorithm
took both link bandwidth and latency into
consideration and used delay, rather than just queue length, as a
measure of load. This was done as follows. First, each incoming packet
was timestamped with its time of arrival at the router (<code>ArrivalTime</code>);
its departure time from the router (<code>DepartTime</code>) was also recorded.
Second, when the link-level ACK was received from the other side, the
node computed the delay for that packet as</p>
<pre><code class="lang-c">Delay = (DepartTime - ArrivalTime) + TransmissionTime + Latency
</code></pre>
<p>where <code>TransmissionTime</code> and <code>Latency</code> were statically defined for the
link and captured the link&apos;s bandwidth and latency, respectively. Notice
that in this case, <code>DepartTime - ArrivalTime</code> represents the amount of
time the packet was delayed (queued) in the node due to load. If the ACK
did not arrive, but instead the packet timed out, then <code>DepartTime</code> was
reset to the time the packet was <em>retransmitted</em>. In this case,
<code>DepartTime - ArrivalTime</code> captures the reliability of the link&#x2014;the
more frequent the retransmission of packets, the less reliable the link,
and the more we want to avoid it. Finally, the weight assigned to each
link was derived from the average delay experienced by the packets
recently sent over that link.</p>
<p>Although an improvement over the original mechanism, this approach
also had a lot of problems. Under light load, it worked reasonably well,
since the two static factors of delay dominated the cost. Under heavy
load, however, a congested link would start to advertise a very high
cost. This caused all the traffic to move off that link, leaving it
idle, so then it would advertise a low cost, thereby attracting back all
the traffic, and so on. The effect of this instability was that, under
heavy load, many links would in fact spend a great deal of time being
idle, which is the last thing you want under heavy load.</p>
<p>Another problem was that the range of link values was much too large.
For example, a heavily loaded 9.6-kbps link could look 127 times more
costly than a lightly loaded 56-kbps link. (Keep in mind, we&apos;re
talking about the ARPANET cira 1975.) This means that the routing
algorithm would choose a path with 126 hops of lightly loaded 56-kbps
links in preference to a 1-hop 9.6-kbps path. While shedding some
traffic from an overloaded line is a good idea, making it look so
unattractive that it loses all its traffic is excessive. Using 126 hops
when 1 hop will do is in general a bad use of network resources. Also,
satellite links were unduly penalized, so that an idle 56-kbps satellite
link looked considerably more costly than an idle 9.6-kbps terrestrial
link, even though the former would give better performance for
high-bandwidth applications.</p>
<p>A third approach addressed these problems. The major changes were to
compress the dynamic range of the metric considerably, to account for
the link type, and to smooth the variation of the metric with time.</p>
<p>The smoothing was achieved by several mechanisms. First, the delay
measurement was transformed to a link utilization, and this number was
averaged with the last reported utilization to suppress sudden changes.
Second, there was a hard limit on how much the metric could change from
one measurement cycle to the next. By smoothing the changes in the cost,
the likelihood that all nodes would abandon a route at once is greatly
reduced.</p>
<p>The compression of the dynamic range was achieved by feeding the
measured utilization, the link type, and the link speed into a function
that is shown graphically in <a href="#metric">Figure 9</a>. below. Observe the
following:</p>
<figure class="line">
    <a id="metric"></a>
    <img src="figures/f03-36-9780123850591.png" width="600px">
    <figcaption>Revised ARPANET routing metric versus link
    utilization.</figcaption>
</figure>

<ul>
<li><p>A highly loaded link never shows a cost of more than three times its
  cost when idle.</p>
</li>
<li><p>The most expensive link is only seven times the cost of the least
  expensive.</p>
</li>
<li><p>A high-speed satellite link is more attractive than a low-speed
  terrestrial link.</p>
</li>
<li><p>Cost is a function of link utilization only at moderate to high
  loads.</p>
</li>
</ul>
<p>All of these factors mean that a link is much less likely to be
universally abandoned, since a threefold increase in cost is likely to
make the link unattractive for some paths while letting it remain the
best choice for others. The slopes, offsets, and breakpoints for the
curves in <a href="#metric">Figure 9</a> were arrived at by a great deal of trial
and error, and they were carefully tuned to provide good performance.</p>
<p>Despite all these improvements, it turns out that in the majority of
real-world network deployments, metrics change rarely if at all and
only under the control of a network administrator, not automatically
as was described above. The reason for this is partly that
conventional wisdom now holds that dynamically changing metrics
are too unstable, even though this probably need not be true. Perhaps
more significantly, many networks today lack the great disparity of
link speeds and latencies that prevailed in the ARPANET. Thus, static
metrics are the norm. One common approach to setting metrics is to use
a constant multiplied by (1/link_bandwidth).</p>
<p>So why do we still tell the story about a decades old algorithm that&apos;s
no longer is use? Because it perfectly illustrates two valuable lessons.
The first is that computer systems are often <em>designed iteratively,
based on experience.</em> We seldom get it right the first time, so it&apos;s
important to deploy a simple solution sooner rather than later, and
expect to improve it over time. Staying stuck in the design phase
indefinitely is usually not a good approach. The second is the
well-know KISS principle: <em>Keep it Simple, Stupid.</em> When building a
complex system, less is often more. Opportunities to invent
sophisticated optimizations are plentiful, and it&apos;s a tempting
challenge to tackle. While such optimations sometimes have
short-term value, it is shocking how often a simple approach proves
best over time. This is because when a system has many moving parts,
as the Internet most certainly does, keeping each part as simple as
possible is usually the best bet.</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="basic-ip.html" class="navigation navigation-prev " aria-label="Previous page: 3.2 Basic Internetworking">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="impl.html" class="navigation navigation-next " aria-label="Next page: 3.4 Implementation">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"3.3 Routing","level":"1.4.3","depth":2,"next":{"title":"3.4 Implementation","level":"1.4.4","depth":2,"path":"internetworking/impl.md","ref":"internetworking/impl.md","articles":[]},"previous":{"title":"3.2 Basic Internetworking","level":"1.4.2","depth":2,"path":"internetworking/basic-ip.md","ref":"internetworking/basic-ip.md","articles":[]},"dir":"ltr"},"config":{"plugins":["anchorjs","katex","block-align","sequence-diagrams","creativecommons","custom-favicon","smart-nav-collapse"],"root":".","styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css"},"pluginsConfig":{"block-align":{},"search":{},"sequence-diagrams":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"katex":{},"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"favicon":"bridge.ico","custom-favicon":{},"creativecommons":{},"smart-nav-collapse":{},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false},"anchorjs":{}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{"branch":"master"},"title":"Computer Networks: A Systems Approach","gitbook":"*"},"file":{"path":"internetworking/routing.md","mtime":"2018-09-05T21:50:34.000Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2018-10-04T22:46:12.462Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.1.1/anchor.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-anchorjs/anchor-style.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-smart-nav-collapse/smart-nav-collapse.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

