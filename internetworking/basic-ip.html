
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>3.2 Basic Internetworking Â· Computer Networks: A Systems Approach</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-katex/katex.min.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-block-align/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-flexible-alerts/style.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-intopic-toc/style.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-smart-nav-collapse/smart-nav-collapse.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
        <link rel="stylesheet" href="../styles/website.css">
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="routing.html" />
    
    
    <link rel="prev" href="switching.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Preface
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../foundation/problem.html">
            
                <a href="../foundation/problem.html">
            
                    
                    Chapter 1: Foundation
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="../foundation/applications.html">
            
                <a href="../foundation/applications.html">
            
                    
                    1.1 Applications
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="../foundation/requirements.html">
            
                <a href="../foundation/requirements.html">
            
                    
                    1.2 Requirements
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="../foundation/architecture.html">
            
                <a href="../foundation/architecture.html">
            
                    
                    1.3 Architecture
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.4" data-path="../foundation/software.html">
            
                <a href="../foundation/software.html">
            
                    
                    1.4 Software
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.5" data-path="../foundation/performance.html">
            
                <a href="../foundation/performance.html">
            
                    
                    1.5 Performance
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.6" data-path="../foundation/trend.html">
            
                <a href="../foundation/trend.html">
            
                    
                    1.6 Broader Perspective
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../direct/problem.html">
            
                <a href="../direct/problem.html">
            
                    
                    Chapter 2: Direct Connections
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="../direct/perspective.html">
            
                <a href="../direct/perspective.html">
            
                    
                    2.1 Technology Landscape
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="../direct/encoding.html">
            
                <a href="../direct/encoding.html">
            
                    
                    2.2 Encoding
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3" data-path="../direct/framing.html">
            
                <a href="../direct/framing.html">
            
                    
                    2.3 Framing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4" data-path="../direct/error.html">
            
                <a href="../direct/error.html">
            
                    
                    2.4 Error Detection
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.5" data-path="../direct/reliable.html">
            
                <a href="../direct/reliable.html">
            
                    
                    2.5 Reliable Transmission
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.6" data-path="../direct/ethernet.html">
            
                <a href="../direct/ethernet.html">
            
                    
                    2.6 Multi-Access Networks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.7" data-path="../direct/wireless.html">
            
                <a href="../direct/wireless.html">
            
                    
                    2.7 Wireless Networks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.8" data-path="../direct/access.html">
            
                <a href="../direct/access.html">
            
                    
                    2.8 Access Networks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.9" data-path="../direct/trend.html">
            
                <a href="../direct/trend.html">
            
                    
                    2.9 Broader Perspective
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="problem.html">
            
                <a href="problem.html">
            
                    
                    Chapter 3: Internetworking
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="switching.html">
            
                <a href="switching.html">
            
                    
                    3.1 Switching and Bridging
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.4.2" data-path="basic-ip.html">
            
                <a href="basic-ip.html">
            
                    
                    3.2 Basic Internetworking
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3" data-path="routing.html">
            
                <a href="routing.html">
            
                    
                    3.3 Routing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4" data-path="impl.html">
            
                <a href="impl.html">
            
                    
                    3.4 Implementation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.5" data-path="trend.html">
            
                <a href="trend.html">
            
                    
                    3.5 Broader Perspective
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="../scaling/problem.html">
            
                <a href="../scaling/problem.html">
            
                    
                    Chapter 4: Advanced Internetworking
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.1" data-path="../scaling/global.html">
            
                <a href="../scaling/global.html">
            
                    
                    4.1 Global Internet
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.2" data-path="../scaling/multicast.html">
            
                <a href="../scaling/multicast.html">
            
                    
                    4.2 Multicast
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.3" data-path="../scaling/mpls.html">
            
                <a href="../scaling/mpls.html">
            
                    
                    4.3 Multiprotocol Label Switching
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.4" data-path="../scaling/mobile-ip.html">
            
                <a href="../scaling/mobile-ip.html">
            
                    
                    4.4 Routing Among Mobile Devices
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.5" data-path="../scaling/trend.html">
            
                <a href="../scaling/trend.html">
            
                    
                    4.5 Broader Perspective 
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="../e2e/problem.html">
            
                <a href="../e2e/problem.html">
            
                    
                    Chapter 5: End-to-End Protocols
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.6.1" data-path="../e2e/udp.html">
            
                <a href="../e2e/udp.html">
            
                    
                    5.1 Simple Demultiplexor (UDP)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2" data-path="../e2e/tcp.html">
            
                <a href="../e2e/tcp.html">
            
                    
                    5.2 Reliable Byte Stream (TCP)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.3" data-path="../e2e/rpc.html">
            
                <a href="../e2e/rpc.html">
            
                    
                    5.3 Remote Procedure Call
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.4" data-path="../e2e/rtp.html">
            
                <a href="../e2e/rtp.html">
            
                    
                    5.4 Transport for Real-Time (RTP)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.5" data-path="../e2e/trend.html">
            
                <a href="../e2e/trend.html">
            
                    
                    5.5 Broader Perspective
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="../congestion/problem.html">
            
                <a href="../congestion/problem.html">
            
                    
                    Chapter 6: Congestion Control
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.1" data-path="../congestion/issues.html">
            
                <a href="../congestion/issues.html">
            
                    
                    6.1 Issues in Resource Allocation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.2" data-path="../congestion/queuing.html">
            
                <a href="../congestion/queuing.html">
            
                    
                    6.2 Queuing Disciplines
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.3" data-path="../congestion/tcpcc.html">
            
                <a href="../congestion/tcpcc.html">
            
                    
                    6.3 TCP Congestion Control
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4" data-path="../congestion/avoidance.html">
            
                <a href="../congestion/avoidance.html">
            
                    
                    6.4 Advanced Congestion Control
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.5" data-path="../congestion/qos.html">
            
                <a href="../congestion/qos.html">
            
                    
                    6.5 Quality of Service
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.6" data-path="../congestion/trend.html">
            
                <a href="../congestion/trend.html">
            
                    
                    6.6 Broader Perspective
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="../data/problem.html">
            
                <a href="../data/problem.html">
            
                    
                    Chapter 7: End-to-End Data
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.8.1" data-path="../data/presentation.html">
            
                <a href="../data/presentation.html">
            
                    
                    7.1 Presentation Formatting
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.2" data-path="../data/multimedia.html">
            
                <a href="../data/multimedia.html">
            
                    
                    7.2 Multimedia Data
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.3" data-path="../data/trend.html">
            
                <a href="../data/trend.html">
            
                    
                    7.3 Broader Perspective 
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="../security/problem.html">
            
                <a href="../security/problem.html">
            
                    
                    Chapter 8: Network Security
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.9.1" data-path="../security/trust.html">
            
                <a href="../security/trust.html">
            
                    
                    8.1 Trust and Threats
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2" data-path="../security/crypto.html">
            
                <a href="../security/crypto.html">
            
                    
                    8.2 Cryptographic Building Blocks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.3" data-path="../security/key-distro.html">
            
                <a href="../security/key-distro.html">
            
                    
                    8.3 Key Predistribution
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.4" data-path="../security/authentication.html">
            
                <a href="../security/authentication.html">
            
                    
                    8.4 Authentication Protocols
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.5" data-path="../security/systems.html">
            
                <a href="../security/systems.html">
            
                    
                    8.5 Example Systems
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.6" data-path="../security/trend.html">
            
                <a href="../security/trend.html">
            
                    
                    8.6 Broader Perspective
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="../applications/problem.html">
            
                <a href="../applications/problem.html">
            
                    
                    Chapter 9: Applications
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.10.1" data-path="../applications/traditional.html">
            
                <a href="../applications/traditional.html">
            
                    
                    9.1 Traditional Applications
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.2" data-path="../applications/multimedia.html">
            
                <a href="../applications/multimedia.html">
            
                    
                    9.2 Multimedia Applications
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.3" data-path="../applications/infrastructure.html">
            
                <a href="../applications/infrastructure.html">
            
                    
                    9.3 Infrastructure Applications
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.4" data-path="../applications/overlays.html">
            
                <a href="../applications/overlays.html">
            
                    
                    9.4 Overlay Networks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.5" data-path="../applications/trend.html">
            
                <a href="../applications/trend.html">
            
                    
                    9.5 Broader Perspective
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >3.2 Basic Internetworking</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="32-basic-internetworking">3.2 Basic Internetworking</h1>
<p>In the previous section, we saw that it was possible to build reasonably
large LANs using bridges and LAN switches, but that such approaches were
limited in their ability to scale and to handle heterogeneity. In this
section, we explore some ways to go beyond the limitations of bridged
networks, enabling us to build large, highly heterogeneous networks with
reasonably efficient routing. We refer to such networks as
<em>internetworks.</em> We&apos;ll continue the discussion of how to build a truly
global internetwork in the next chapter, but for now we&apos;ll explore the
basics. We start by considering more carefully what the word
<em>internetwork</em> means.</p>
<h2 id="what-is-an-internetwork">What Is an Internetwork?</h2>
<p>We use the term <em>internetwork</em>, or sometimes just <em>internet</em> with a
lowercase <em>i</em>, to refer to an arbitrary collection of networks
interconnected to provide some sort of host-to-host packet delivery
service. For example, a corporation with many sites might construct a
private internetwork by interconnecting the LANs at their different
sites with point-to-point links leased from the phone company. When we
are talking about the widely used global internetwork to which a large
percentage of networks are now connected, we call it the <em>Internet</em> with
a capital <em>I.</em> In keeping with the first-principles approach of this
book, we mainly want you to learn about the principles of &quot;lowercase
<em>i</em>&quot; internetworking, but we illustrate these ideas with real-world
examples from the &quot;big <em>I</em>&quot; Internet.</p>
<p>Another piece of terminology that can be confusing is the difference
between networks, subnetworks, and internetworks. We are going to
avoid subnetworks (or subnets) altogether until a later section.
For now, we use <em>network</em> to mean either a directly connected or a
switched network of the kind described in the previous section and the
previous chapter. Such a network uses one technology, such as 802.11 or
Ethernet. An <em>internetwork</em> is an interconnected collection of such
networks. Sometimes, to avoid ambiguity, we refer to the underlying
networks that we are interconnecting as <em>physical</em> networks. An internet
is a <em>logical</em> network built out of a collection of physical networks.
In this context, a collection of Ethernet segments connected by
bridges or switches would still be viewed as a single network.</p>
<figure>
    <a id="inet"></a>
    <img src="figures/f03-14-9780123850591.png" width="500px">
    <figcaption>A simple internetwork. H denotes a host ane R denotes
    a router.</figcaption>
</figure>

<p><a href="#inet">Figure 1</a> shows an example internetwork. An internetwork is
often referred to as a &quot;network of networks&quot; because it is made up of
lots of smaller networks. In this figure, we see Ethernets, a wireless
network, and a point-to-point link. Each of these is a single-technology
network. The nodes that interconnect the networks are called <em>routers</em>.
They are also sometimes called <em>gateways</em>, but since this term has
several other connotations, we restrict our usage to router.</p>
<figure>
    <a id="ip-graph"></a>
    <img src="figures/f03-15-9780123850591.png" width="600px">
    <figcaption>A simple internetwork, showing the protocol layers
    used to connect H5 to H8 in the above figure. ETH is the protocol
    that runs over the Ethernet.</figcaption>
</figure>

<p>The <em>Internet Protocol</em> is the key tool used today to build scalable,
heterogeneous internetworks. It was originally known as the Kahn-Cerf
protocol after its inventors. One way to think of IP is that it runs
on all the nodes (both hosts and routers) in a collection of networks
and defines the infrastructure that allows these nodes and networks to
function as a single logical internetwork. For example,
<a href="#ip-graph">Figure 2</a> shows how hosts H5 and H8 are logically
connected by the internet in <a href="#inet">Figure 1</a>, including
the protocol graph running on each node. Note that higher-level
protocols, such as TCP and UDP, typically run on top of IP on the hosts.</p>
<p>The rest of this and the next chapter are about various aspects of IP.
While it is certainly possible to build an internetwork that does not use
IP&#x2014;and in fact, in the early days of the Internet there were
alternative solutions&#x2014;IP is the most interesting case to study simply
because of the size of the Internet. Said another way, it is only the
IP Internet that has really faced the issue of scale. Thus, it
provides the best case study of a scalable internetworking protocol.</p>
<h2 id="service-model">Service Model</h2>
<p>A good place to start when you build an internetwork is to define its
<em>service model</em>, that is, the host-to-host services you want to provide.
The main concern in defining a service model for an internetwork is that
we can provide a host-to-host service only if this service can somehow
be provided over each of the underlying physical networks. For example,
it would be no good deciding that our internetwork service model was
going to provide guaranteed delivery of every packet in 1 ms or less if
there were underlying network technologies that could arbitrarily delay
packets. The philosophy used in defining the IP service model,
therefore, was to make it undemanding enough that just about any network
technology that might turn up in an internetwork would be able to
provide the necessary service.</p>
<p>The IP service model can be thought of as having two parts: an
addressing scheme, which provides a way to identify all hosts in the
internetwork, and a datagram (connectionless) model of data delivery.
This service model is sometimes called <em>best effort</em> because, although
IP makes every effort to deliver datagrams, it makes no guarantees. We
postpone a discussion of the addressing scheme for now and look first at
the data delivery model.</p>
<h3 id="datagram-delivery">Datagram Delivery</h3>
<p>The IP datagram is fundamental to the Internet Protocol. Recall an
earlier section that a datagram is a type of packet that
happens to be sent in a connectionless manner over a network. Every
datagram carries enough information to let the network forward the
packet to its correct destination; there is no need for any advance
setup mechanism to tell the network what to do when the packet arrives.
You just send it, and the network makes its best effort to get it to the
desired destination. The &quot;best-effort&quot; part means that if something goes
wrong and the packet gets lost, corrupted, misdelivered, or in any way
fails to reach its intended destination, the network does nothing&#x2014;it
made its best effort, and that is all it has to do. It does not make any
attempt to recover from the failure. This is sometimes called an
<em>unreliable</em> service.</p>
<p>Best-effort, connectionless service is about the simplest service you
could ask for from an internetwork, and this is a great strength. For
example, if you provide best-effort service over a network that provides
a reliable service, then that&apos;s fine&#x2014;you end up with a best-effort
service that just happens to always deliver the packets. If, on the
other hand, you had a reliable service model over an unreliable network,
you would have to put lots of extra functionality into the routers to
make up for the deficiencies of the underlying network. Keeping the
routers as simple as possible was one of the original design goals
of IP.</p>
<p>The ability of IP to &quot;run over anything&quot; is frequently cited as one of
its most important characteristics. It is noteworthy that many of the
technologies over which IP runs today did not exist when IP was
invented. So far, no networking technology has been invented that has
proven too bizarre for IP; in principle, IP can run over a network
that transports messages using carrier pigeons.</p>
<p>Best-effort delivery does not just mean that packets can get lost.
Sometimes they can get delivered out of order, and sometimes the same
packet can get delivered more than once. The higher-level protocols or
applications that run above IP need to be aware of all these possible
failure modes.</p>
<h3 id="packet-format">Packet Format</h3>
<p>Clearly, a key part of the IP service model is the type of packets that
can be carried. The IP datagram, like most packets, consists of a header
followed by a number of bytes of data. The format of the header is shown
in <a href="#iphead">Figure 3</a>. Note that we have adopted a different style
of representing packets than the one we used in previous chapters. This is
because packet formats at the internetworking layer and above, where we
will be focusing our attention for the next few chapters, are almost
invariably designed to align on 32-bit boundaries to simplify the task
of processing them in software. Thus, the common way of representing
them (used in Internet Requests for Comments, for example) is to draw
them as a succession of 32-bit words. The top word is the one
transmitted first, and the leftmost byte of each word is the one
transmitted first. In this representation, you can easily recognize
fields that are a multiple of 8 bits long. On the odd occasion when
fields are not an even multiple of 8 bits, you can determine the field
lengths by looking at the bit positions marked at the top of the packet.</p>
<figure>
    <a id="iphead"></a>
    <img src="figures/f03-16-9780123850591.png" width="450px">
    <figcaption>IPv4 packet header.</figcaption>
</figure>

<p>Looking at each field in the IP header, we see that the &quot;simple&quot; model
of best-effort datagram delivery still has some subtle features. The
<code>Version</code> field specifies the version of IP. The still-assumed version
of IP is 4, which is typically called <em>IPv4</em>. Observe that putting this
field right at the start of the datagram makes it easy for everything
else in the packet format to be redefined in subsequent versions; the
header processing software starts off by looking at the version and then
branches off to process the rest of the packet according to the
appropriate format. The next field, <code>HLen</code>, specifies the length of the
header in 32-bit words. When there are no options, which is most of the
time, the header is 5 words (20 bytes) long. The 8-bit <code>TOS</code> (type of
service) field has had a number of different definitions over the years,
but its basic function is to allow packets to be treated differently
based on application needs. For example, the <code>TOS</code> value might determine
whether or not a packet should be placed in a special queue that
receives low delay.</p>
<p>The next 16 bits of the header contain the <code>Length</code> of the datagram,
including the header. Unlike the <code>HLen</code> field, the <code>Length</code> field counts
bytes rather than words. Thus, the maximum size of an IP datagram is
65,535 bytes. The physical network over which IP is running, however,
may not support such long packets. For this reason, IP supports a
fragmentation and reassembly process. The second word of the header
contains information about fragmentation, and the details of its use are
presented in the following section entitled &quot;Fragmentation and
Reassembly.&quot;</p>
<p>Moving on to the third word of the header, the next byte is the <code>TTL</code>
(time to live) field. Its name reflects its historical meaning rather
than the way it is commonly used today. The intent of the field is to
catch packets that have been going around in routing loops and discard
them, rather than let them consume resources indefinitely. Originally,
<code>TTL</code> was set to a specific number of seconds that the packet would be
allowed to live, and routers along the path would decrement this field
until it reached 0. However, since it was rare for a packet to sit for
as long as 1 second in a router, and routers did not all have access to
a common clock, most routers just decremented the <code>TTL</code> by 1 as they
forwarded the packet. Thus, it became more of a hop count than a timer,
which is still a perfectly good way to catch packets that are stuck in
routing loops. One subtlety is in the initial setting of this field by
the sending host: Set it too high and packets could circulate rather a
lot before getting dropped; set it too low and they may not reach their
destination. The value 64 is the current default.</p>
<p>The <code>Protocol</code> field is simply a demultiplexing key that identifies the
higher-level protocol to which this IP packet should be passed. There
are values defined for the TCP (Transmission Control Protocol&#x2014;6), UDP
(User Datagram Protocol&#x2014;17), and many other protocols that may sit
above IP in the protocol graph.</p>
<p>The <code>Checksum</code> is calculated by considering the entire IP header as a
sequence of 16-bit words, adding them up using ones complement
arithmetic, and taking the ones complement of the result. Thus, if any
bit in the header is corrupted in transit, the checksum will not contain
the correct value upon receipt of the packet. Since a corrupted header
may contain an error in the destination address&#x2014;and, as a result, may
have been misdelivered&#x2014;it makes sense to discard any packet that fails
the checksum. It should be noted that this type of checksum does not
have the same strong error detection properties as a CRC, but it is much
easier to calculate in software.</p>
<p>The last two required fields in the header are the <code>SourceAddr</code> and the
<code>DestinationAddr</code> for the packet. The latter is the key to datagram
delivery: Every packet contains a full address for its intended
destination so that forwarding decisions can be made at each router. The
source address is required to allow recipients to decide if they want to
accept the packet and to enable them to reply. IP addresses are
discussed in a later section&#x2014;for now, the important thing
to know is that IP defines its own global address space, independent of
whatever physical networks it runs over. As we will see, this is one of
the keys to supporting heterogeneity.</p>
<p>Finally, there may be a number of options at the end of the header. The
presence or absence of options may be determined by examining the header
length (<code>HLen</code>) field. While options are used fairly rarely, a complete
IP implementation must handle them all.</p>
<h3 id="fragmentation-and-reassembly">Fragmentation and Reassembly</h3>
<p>One of the problems of providing a uniform host-to-host service model
over a heterogeneous collection of networks is that each network
technology tends to have its own idea of how large a packet can be. For
example, classic Ethernet can accept packets up to 1500 bytes long,
but modern-day variants can deliver larger (jumbo) packets that carry
up to 9000 bytes of payload.
This leaves two choices for the IP service model: Make sure that all IP
datagrams are small enough to fit inside one packet on any network
technology, or provide a means by which packets can be fragmented and
reassembled when they are too big to go over a given network technology.
The latter turns out to be a good choice, especially when you consider
the fact that new network technologies are always turning up, and IP
needs to run over all of them; this would make it hard to pick a
suitably small bound on datagram size. This also means that a host will
not send needlessly small packets, which wastes bandwidth and consumes
processing resources by requiring more headers per byte of data sent.</p>
<p>The central idea here is that every network type has a <em>maximum
transmission unit</em> (MTU), which is the largest IP datagram that it can
carry in a frame. Note that this value is smaller than the largest
packet size on that network because the IP datagram needs to fit in the
<em>payload</em> of the link-layer frame.</p>
<blockquote>
<p>In ATM networks, the MTU is, fortunately, much larger than a 
single cell, as ATM has its own fragmentation mechanisms. The 
link-layer frame in ATM is called a <em>convergence-sublayer protocol 
data unit</em> (CS-PDU). </p>
</blockquote>
<p>When a host sends an IP datagram, therefore, it can choose any size that
it wants. A reasonable choice is the MTU of the network to which the
host is directly attached. Then, fragmentation will only be necessary if
the path to the destination includes a network with a smaller MTU.
Should the transport protocol that sits on top of IP give IP a packet
larger than the local MTU, however, then the source host must
fragment it.</p>
<p>Fragmentation typically occurs in a router when it receives a datagram
that it wants to forward over a network that has an MTU that is smaller
than the received datagram. To enable these fragments to be reassembled
at the receiving host, they all carry the same identifier in the <code>Ident</code>
field. This identifier is chosen by the sending host and is intended to
be unique among all the datagrams that might arrive at the destination
from this source over some reasonable time period. Since all fragments
of the original datagram contain this identifier, the reassembling host
will be able to recognize those fragments that go together. Should all
the fragments not arrive at the receiving host, the host gives up on the
reassembly process and discards the fragments that did arrive. IP does
not attempt to recover from missing fragments.</p>
<figure>
    <a id="frag"></a>
    <img src="figures/f03-17-9780123850591.png" width="600px">
    <figcaption>IP datagrams traversing the sequence of physical
    networks graphed in the earlier figure.</figcaption>
</figure>

<p>To see what this all means, consider what happens when host H5 sends a
datagram to host H8 in the example internet shown in <a href="#inet">Figure 1</a>.
Assuming that the MTU is 1500 bytes for the two
Ethernets and the 802.11 network, and 532 bytes for the point-to-point
network, then a 1420-byte datagram (20-byte IP header plus 1400 bytes
of data) sent from H5 makes it across the 802.11 network and the first
Ethernet without fragmentation but must be fragmented into three
datagrams at router R2. These three fragments are then forwarded by
router R3 across the second Ethernet to the destination host. This
situation is illustrated in <a href="#frag">Figure 4</a>. This figure
also serves to reinforce two important points:</p>
<ol>
<li><p>Each fragment is itself a self-contained IP datagram that is
 transmitted over a sequence of physical networks, independent of the
 other fragments.</p>
</li>
<li><p>Each IP datagram is re-encapsulated for each physical network over
 which it travels.</p>
</li>
</ol>
<figure>
    <a id="fragment"></a>
    <img src="figures/f03-18-9780123850591.png" width="350px">
    <figcaption>Header fields used in IP fragmentation:
    (a) unfragmented packet; (b) fragmented packets.</figcaption>
</figure>

<p>The fragmentation process can be understood in detail by looking at the
header fields of each datagram, as is done in <a href="#fragment">Figure 5</a>.
The unfragmented packet, shown at the top, has 1400 bytes of data and a
20-byte IP header. When the packet arrives at router R2, which has an
MTU of 532 bytes, it has to be fragmented. A 532-byte MTU leaves
512 bytes for data after the 20-byte IP header, so the first fragment
contains 512 bytes of data. The router sets the M bit in the <code>Flags</code>
field (see <a href="#iphead">Figure 3</a>), meaning that there are more
fragments to follow, and it sets the <code>Offset</code> to 0, since this
fragment contains the first part of the original datagram. The data
carried in the second fragment starts with the 513th byte of the
original data, so the <code>Offset</code> field in this header is set to 64,
which is 512/8. Why the division by 8? Because the designers of IP
decided that fragmentation should always happen on 8-byte boundaries,
which means that the <code>Offset</code> field counts 8-byte chunks, not
bytes. (We leave it as an exercise for you to figure out why this
design decision was made.) The third fragment contains the last
376 bytes of data, and the offset is now 2 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&#xD7;</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.58333em;"></span><span class="strut bottom" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord">&#xD7;</span></span></span></span> 512/8
= 128. Since this is the last fragment, the M bit is not set.</p>
<p>Observe that the fragmentation process is done in such a way that it
could be repeated if a fragment arrived at another network with an even
smaller MTU. Fragmentation produces smaller, valid IP datagrams that can
be readily reassembled into the original datagram upon receipt,
independent of the order of their arrival. Reassembly is done at the
receiving host and not at each router.</p>
<p>IP reassembly is far from a simple process. For example, if a single
fragment is lost, the receiver will still attempt to reassemble the
datagram, and it will eventually give up and have to garbage-collect the
resources that were used to perform the failed reassembly. Getting
a host to tie up resources needlessly can be the basis of a
denial-of-service attack.</p>
<p>For this reason, among others, IP fragmentation is generally considered
a good thing to avoid. Hosts are now strongly encouraged to perform
&quot;path MTU discovery,&quot; a process by which fragmentation is avoided by
sending packets that are small enough to traverse the link with the
smallest MTU in the path from sender to receiver.</p>
<h2 id="global-addresses">Global Addresses</h2>
<p>In the above discussion of the IP service model, we mentioned that one
of the things that it provides is an addressing scheme. After all, if
you want to be able to send data to any host on any network, there needs
to be a way of identifying all the hosts. Thus, we need a global
addressing scheme&#x2014;one in which no two hosts have the same address.
Global uniqueness is the first property that should be provided in an
addressing scheme.</p>
<p>Ethernet addresses are globally unique, but that alone does not suffice
for an addressing scheme in a large internetwork. Ethernet addresses are
also <em>flat</em>, which means that they have no structure and provide very
few clues to routing protocols. (In fact, Ethernet addresses do have a
structure for the purposes of <em>assignment</em>&#x2014;the first 24 bits identify
the manufacturer&#x2014;but this provides no useful information to routing
protocols since this structure has nothing to do with network topology.)
In contrast, IP addresses are <em>hierarchical</em>, by which we mean that they
are made up of several parts that correspond to some sort of hierarchy
in the internetwork. Specifically, IP addresses consist of two parts,
usually referred to as a <em>network</em> part and a <em>host</em> part. This is a
fairly logical structure for an internetwork, which is made up of many
interconnected networks. The network part of an IP address identifies
the network to which the host is attached; all hosts attached to the
same network have the same network part in their IP address. The host
part then identifies each host uniquely on that particular network.
Thus, in the simple internetwork of <a href="#inet">Figure 1</a>, the
addresses of the hosts on network 1, for example, would all have the
same network part and different host parts.</p>
<p>Note that the routers in <a href="#inet">Figure 1</a> are attached to two
networks. They need to have an address on each network, one for each
interface. For example, router R1, which sits between the wireless
network and an Ethernet, has an IP address on the interface to the
wireless network whose network part is the same as all the hosts on that
network. It also has an IP address on the interface to the Ethernet that
has the same network part as the hosts on that Ethernet. Thus, bearing
in mind that a router might be implemented as a host with two network
interfaces, it is more precise to think of IP addresses as belonging to
interfaces than to hosts.</p>
<p>Now, what do these hierarchical addresses look like? Unlike some other
forms of hierarchical address, the sizes of the two parts are not the
same for all addresses. Originally, IP addresses were divided into three
different classes, as shown in <a href="#class">Figure 6</a>, each of which
defines different-sized network and host parts. (There are also class D
addresses that specify a multicast group and class E addresses that
are currently unused.) In all cases, the address is 32 bits long.</p>
<p>The class of an IP address is identified in the most significant few
bits. If the first bit is 0, it is a class A address. If the first bit
is 1 and the second is 0, it is a class B address. If the first two bits
are 1 and the third is 0, it is a class C address. Thus, of the
approximately 4 billion possible IP addresses, half are class A,
one-quarter are class B, and one-eighth are class C. Each class
allocates a certain number of bits for the network part of the address
and the rest for the host part. Class A networks have 7 bits for the
network part and 24 bits for the host part, meaning that there can be
only 126 class A networks (the values 0 and 127 are reserved), but each
of them can accommodate up to 2<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow></mrow><mrow><mn>2</mn><mn>4</mn></mrow></msup></mrow><annotation encoding="application/x-tex">^{24}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span></span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span><span class="mord mathrm mtight">4</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span>&#x200B;</span></span></span></span></span></span></span> - 2 (about 16 million) hosts
(again, there are two reserved values). Class B addresses allocate
14 bits for the network and 16 bits for the host, meaning that each
class B network has room for 65,534 hosts. Finally, class C addresses
have only 8 bits for the host and 21 for the network part. Therefore, a
class C network can have only 256 unique host identifiers, which means
only 254 attached hosts (one host identifier, 255, is reserved for
broadcast, and 0 is not a valid host number). However, the addressing
scheme supports 2<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow></mrow><mrow><mn>2</mn><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">^{21}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span></span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathrm mtight">2</span><span class="mord mathrm mtight">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span>&#x200B;</span></span></span></span></span></span></span> class C networks.</p>
<figure>
    <a id="class"></a>
    <img src="figures/f03-19-9780123850591.png" width="350px">
    <figcaption>IP addresses: (a) class A; (b) class B; (c) class C.</figcaption>
</figure>

<p>On the face of it, this addressing scheme has a lot of flexibility,
allowing networks of vastly different sizes to be accommodated fairly
efficiently. The original idea was that the Internet would consist of a
small number of wide area networks (these would be class A networks), a
modest number of site- (campus-) sized networks (these would be class B
networks), and a large number of LANs (these would be class C networks).
However, it turned out not to be flexible enough, as we will see in a
moment. Today, IP addresses are normally &quot;classless&quot;; the details of
this are explained below.</p>
<p>Before we look at how IP addresses get used, it is helpful to look at
some practical matters, such as how you write them down. By convention,
IP addresses are written as four <em>decimal</em> integers separated by dots.
Each integer represents the decimal value contained in 1 byte of the
address, starting at the most significant. For example, the address of
the computer on which this sentence was typed is <code>171.69.210.245</code>.</p>
<p>It is important not to confuse IP addresses with Internet domain names,
which are also hierarchical. Domain names tend to be ASCII strings
separated by dots, such as <code>cs.princeton.edu</code>. The important thing
about IP addresses is that they are what is carried in the headers of
IP packets, and it is those addresses that are used in IP routers to
make forwarding decisions.</p>
<h2 id="datagram-forwarding-in-ip">Datagram Forwarding in IP</h2>
<p>We are now ready to look at the basic mechanism by which IP routers
forward datagrams in an internetwork. Recall from an earlier section
that <em>forwarding</em> is the process of taking a packet from an 
input and sending it out on the appropriate output, while <em>routing</em> is
the process of building up the tables that allow the correct output for
a packet to be determined. The discussion here focuses on forwarding; we
take up routing in a later section.</p>
<p>The main points to bear in mind as we discuss the forwarding of IP
datagrams are the following:</p>
<ul>
<li><p>Every IP datagram contains the IP address of the destination host.</p>
</li>
<li><p>The network part of an IP address uniquely identifies a single
  physical network that is part of the larger Internet.</p>
</li>
<li><p>All hosts and routers that share the same network part of their
  address are connected to the same physical network and can thus
  communicate with each other by sending frames over that network.</p>
</li>
<li><p>Every physical network that is part of the Internet has at least one
  router that, by definition, is also connected to at least one other
  physical network; this router can exchange packets with hosts or
  routers on either network.</p>
</li>
</ul>
<p>Forwarding IP datagrams can therefore be handled in the following way. A
datagram is sent from a source host to a destination host, possibly
passing through several routers along the way. Any node, whether it is a
host or a router, first tries to establish whether it is connected to
the same physical network as the destination. To do this, it compares
the network part of the destination address with the network part of the
address of each of its network interfaces. (Hosts normally have only one
interface, while routers normally have two or more, since they are
typically connected to two or more networks.) If a match occurs, then
that means that the destination lies on the same physical network as the
interface, and the packet can be directly delivered over that network.
A later section explains some of the details of this process.</p>
<p>If the node is not connected to the same physical network as the
destination node, then it needs to send the datagram to a router. In
general, each node will have a choice of several routers, and so it
needs to pick the best one, or at least one that has a reasonable chance
of getting the datagram closer to its destination. The router that it
chooses is known as the <em>next hop</em> router. The router finds the correct
next hop by consulting its forwarding table. The forwarding table is
conceptually just a list of <code>(NetworkNum, NextHop)</code>pairs. (As we will
see below, forwarding tables in practice often
contain some additional information related to the next hop.) Normally,
there is also a default router that is used if none of the entries in
the table matches the destination&apos;s network number. For a host, it may
be quite acceptable to have a default router and nothing else&#x2014;this
means that all datagrams destined for hosts not on the physical network
to which the sending host is attached will be sent out through the
default router.</p>
<p>We can describe the datagram forwarding algorithm in the following way:</p>
<pre><code class="lang-pseudo">if (NetworkNum of destination = NetworkNum of one of my interfaces) then
    deliver packet to destination over that interface
else
    if (NetworkNum of destination is in my forwarding table) then
        deliver packet to NextHop router
    else
        deliver packet to default router
</code></pre>
<p>For a host with only one interface and only a default router in its
forwarding table, this simplifies to</p>
<pre><code class="lang-pseudo">if (NetworkNum of destination = my NetworkNum) then
    deliver packet to destination directly
else
    deliver packet to default router
</code></pre>
<p>Let&apos;s see how this works in the example internetwork of
<a href="#inet">Figure 1</a>. First, suppose that H1 wants to send a datagram to
H2. Since they are on the same physical network, H1 and H2 have the same
network number in their IP address. Thus, H1 deduces that it can deliver
the datagram directly to H2 over the Ethernet. The one issue that needs
to be resolved is how H1 finds out the correct Ethernet address for
H2&#x2014;the resolution mechanism described in a later section addresses
this issue.</p>
<p>Now suppose H5 wants to send a datagram to H8. Since these hosts are on
different physical networks, they have different network numbers, so H5
deduces that it needs to send the datagram to a router. R1 is the only
choice&#x2014;the default router&#x2014;so H1 sends the datagram over the wireless
network to R1. Similarly, R1 knows that it cannot deliver a datagram
directly to H8 because neither of R1&apos;s interfaces is on the same network
as H8. Suppose R1&apos;s default router is R2; R1 then sends the datagram to
R2 over the Ethernet. Assuming R2 has the forwarding table shown in
<a href="#ipfwdtab">Table 1</a>, it looks up H8&apos;s network number (network 4) 
and forwards the datagram over the point-to-point network to
R3. Finally, R3, since it is on the same network as H8, forwards the
datagram directly to H8.</p>
<p><a id="ipfwdtab"></a></p>
<table>
<thead>
<tr>
<th style="text-align:center">NetworkNum</th>
<th style="text-align:center">NextHop</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">R1</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">R3</td>
</tr>
</tbody>
</table>
<table>
<caption>Table 1. Forwarding table for Router R2.</caption>
</table>

<p><a id="tab5.3"></a></p>
<table>
<thead>
<tr>
<th style="text-align:center">NetworkNum</th>
<th style="text-align:center">NextHop</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">R1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">Interface 1</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">Interface 0</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">R3</td>
</tr>
</tbody>
</table>
<table>
<caption>Table 2. Complete Forwarding Table for Router R2.</caption>
</table>

<p>Note that it is possible to include the information about directly
connected networks in the forwarding table. For example, we could
label the network interfaces of router R2 as interface 0 for the
point-to-point link (network 3) and interface 1 for the Ethernet
(network 2). Then R2 would have the forwarding table shown in
<a href="#tab5.3">Table 2</a>.</p>
<p>Thus, for any network number that R2 encounters in a packet, it knows
what to do. Either that network is directly connected to R2, in which
case the packet can be delivered to its destination over that network,
or the network is reachable via some next hop router that R2 can reach
over a network to which it is connected. In either case, R2 will use
ARP, described below, to find the MAC address of the node to which the
packet is to be sent next.</p>
<p>The forwarding table used by R2 is simple enough that it could be
manually configured. Usually, however, these tables are more complex
and would be built up by running a routing protocol such as one of
those described in a later section. Also note that, in practice, the
network numbers are usually longer (e.g., 128.96).</p>
<p>We can now see how hierarchical addressing&#x2014;splitting the address into
network and host parts&#x2014;has improved the scalability of a large
network. Routers now contain forwarding tables that list only a set of
network numbers rather than all the nodes in the network. In our simple
example, that meant that R2 could store the information needed to reach
all the hosts in the network (of which there were eight) in a four-entry
table. Even if there were 100 hosts on each physical network, R2 would
still only need those same four entries. This is a good first step
(although by no means the last) in achieving scalability.</p>
<blockquote>
<p>[!Note|style:flat|label:Key Takeaway|iconVisibility:hidden]
This illustrates one of the most important principles of building
scalable networks: To achieve scalability, you need to reduce the amount
of information that is stored in each node and that is exchanged between
nodes. The most common way to do that is <em>hierarchical aggregation</em>. IP
introduces a two-level hierarchy, with networks at the top level and
nodes at the bottom level. We have aggregated information by letting
routers deal only with reaching the right network; the information that
a router needs to deliver a datagram to any node on a given network is
represented by a single aggregated piece of information.</p>
</blockquote>
<h2 id="subnetting-and-classless-addressing">Subnetting and Classless Addressing</h2>
<p>The original intent of IP addresses was that the network part would
uniquely identify exactly one physical network. It turns out that this
approach has a couple of drawbacks. Imagine a large campus that has lots
of internal networks and decides to connect to the Internet. For every
network, no matter how small, the site needs at least a class C network
address. Even worse, for any network with more than 255 hosts, they need
a class B address. This may not seem like a big deal, and indeed it
wasn&apos;t when the Internet was first envisioned, but there are only a
finite number of network numbers, and there are far fewer class B
addresses than class Cs. Class B addresses tend to be in particularly
high demand because you never know if your network might expand beyond
255 nodes, so it is easier to use a class B address from the start than
to have to renumber every host when you run out of room on a class C
network. The problem we observe here is address assignment inefficiency:
A network with two nodes uses an entire class C network address, thereby
wasting 253 perfectly useful addresses; a class B network with slightly
more than 255 hosts wastes over 64,000 addresses.</p>
<p>Assigning one network number per physical network, therefore, uses up
the IP address space potentially much faster than we would like. While
we would need to connect over 4 billion hosts to use up all the valid
addresses, we only need to connect 2<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow></mrow><mrow><mn>1</mn><mn>4</mn></mrow></msup></mrow><annotation encoding="application/x-tex">^{14}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span></span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathrm mtight">1</span><span class="mord mathrm mtight">4</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span>&#x200B;</span></span></span></span></span></span></span> (about 16,000) class B
networks before that part of the address space runs out. Therefore, we
would like to find some way to use the network numbers more efficiently.</p>
<p>Assigning many network numbers has another drawback that becomes
apparent when you think about routing. Recall that the amount of state
that is stored in a node participating in a routing protocol is
proportional to the number of other nodes, and that routing in an
internet consists of building up forwarding tables that tell a router
how to reach different networks. Thus, the more network numbers there
are in use, the bigger the forwarding tables get. Big forwarding tables
add costs to routers, and they are potentially slower to search than
smaller tables for a given technology, so they degrade router
performance. This provides another motivation for assigning network
numbers carefully.</p>
<p><em>Subnetting</em> provides a first step to reducing total number of network
numbers that are assigned. The idea is to take a single IP network
number and allocate the IP addresses with that network number to several
physical networks, which are now referred to as <em>subnets</em>. Several
things need to be done to make this work. First, the subnets should be
close to each other. This is because from a distant point in the Internet,
they will all look like a single network, having only one network number
between them. This means that a router will only be able to select one
route to reach any of the subnets, so they had better all be in the same
general direction. A perfect situation in which to use subnetting is a
large campus or corporation that has many physical networks. From
outside the campus, all you need to know to reach any subnet inside the
campus is where the campus connects to the rest of the Internet. This is
often at a single point, so one entry in your forwarding table will
suffice. Even if there are multiple points at which the campus is
connected to the rest of the Internet, knowing how to get to one point
in the campus network is still a good start.</p>
<p>The mechanism by which a single network number can be shared among
multiple networks involves configuring all the nodes on each subnet with
a <em>subnet mask</em>. With simple IP addresses, all hosts on the same network
must have the same network number. The subnet mask enables us to
introduce a <em>subnet number</em>; all hosts on the same physical network will
have the same subnet number, which means that hosts may be on different
physical networks but share a single network number. This concept is
illustrated in <a href="#subaddr">Figure 7</a>.</p>
<figure>
    <a id="subaddr"></a>
    <img src="figures/f03-20-9780123850591.png" width="350px">
    <figcaption>Subnet addressing.</figcaption>
</figure>

<p>What subnetting means to a host is that it is now configured with both
an IP address and a subnet mask for the subnet to which it is attached.
For example, host H1 in <a href="#subnet">Figure 8</a> is configured with an
address of 128.96.34.15 and a subnet mask of 255.255.255.128. (All hosts
on a given subnet are configured with the same mask; that is, there is
exactly one subnet mask per subnet.) The bitwise AND of these two
numbers defines the subnet number of the host and of all other hosts on
the same subnet. In this case, 128.96.34.15 AND 255.255.255.128 equals
128.96.34.0, so this is the subnet number for the topmost subnet in the
figure.</p>
<figure>
    <a id="subnet"></a>
    <img src="figures/f03-21-9780123850591.png" width="500px">
    <figcaption>An example of subnetting.</figcaption>
</figure>

<p>When the host wants to send a packet to a certain IP address, the first
thing it does is to perform a bitwise AND between its own subnet mask
and the destination IP address. If the result equals the subnet number
of the sending host, then it knows that the destination host is on the
same subnet and the packet can be delivered directly over the subnet. If
the results are not equal, the packet needs to be sent to a router to be
forwarded to another subnet. For example, if H1 is sending to H2, then
H1 ANDs its subnet mask (255.255.255.128) with the address for H2
(128.96.34.139) to obtain 128.96.34.128. This does not match the subnet
number for H1 (128.96.34.0) so H1 knows that H2 is on a different
subnet. Since H1 cannot deliver the packet to H2 directly over the
subnet, it sends the packet to its default router R1.</p>
<p>The forwarding table of a router also changes slightly when we introduce
subnetting. Recall that we previously had a forwarding table that
consisted of entries of the form <code>(NetworkNum, NextHop)</code>. To support
subnetting, the table must now hold entries of the form
<code>(SubnetNumber, SubnetMask, NextHop)</code>. To find the right entry in the
table, the router ANDs the packet&apos;s destination address with the
<code>SubnetMask</code>for each entry in turn; if the result matches the
<code>SubnetNumber</code> of the entry, then this is the right entry to use, and
it forwards the packet to the next hop router indicated. In the
example network of <a href="#subnet">Figure 8</a>, router R1 would have the
entries shown in <a href="#subnettab">Table 2</a>.</p>
<p><a id="subnettab"></a></p>
<table>
<thead>
<tr>
<th style="text-align:left">SubnetNumber</th>
<th style="text-align:left">SubnetMask</th>
<th style="text-align:left">NextHop</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">128.96.34.0</td>
<td style="text-align:left">255.255.255.128</td>
<td style="text-align:left">Interface 0</td>
</tr>
<tr>
<td style="text-align:left">128.96.34.128</td>
<td style="text-align:left">255.255.255.128</td>
<td style="text-align:left">Interface 1</td>
</tr>
<tr>
<td style="text-align:left">128.96.33.0</td>
<td style="text-align:left">255.255.255.0</td>
<td style="text-align:left">R2</td>
</tr>
</tbody>
</table>
<table>
<caption>Table 3. Example Forwarding Table with Subnetting.</caption>
</table>

<p>Continuing with the example of a datagram from H1 being sent to H2, R1
would AND H2&apos;s address (128.96.34.139) with the subnet mask of the first
entry (255.255.255.128) and compare the result (128.96.34.128) with the
network number for that entry (128.96.34.0). Since this is not a match,
it proceeds to the next entry. This time a match does occur, so R1
delivers the datagram to H2 using interface 1, which is the interface
connected to the same network as H2.</p>
<p>We can now describe the datagram forwarding algorithm in the following
way:</p>
<pre><code class="lang-pseudo">D = destination IP address
for each forwarding table entry (SubnetNumber, SubnetMask, NextHop)
    D1 = SubnetMask &amp; D
    if D1 = SubnetNumber
        if NextHop is an interface
            deliver datagram directly to destination
        else
            deliver datagram to NextHop (a router)
</code></pre>
<p>Although not shown in this example, a default route would usually be
included in the table and would be used if no explicit matches were
found. Note that a naive implementation of this
algorithm&#x2014;one involving repeated ANDing of the destination address
with a subnet mask that may not be different every time, and a linear
table search&#x2014;would be very inefficient.</p>
<p>An important consequence of subnetting is that different parts of the
internet see the world differently. From outside our hypothetical
campus, routers see a single network. In the example above, routers
outside the campus see the collection of networks in
<a href="#subnet">Figure 8</a> as just the network 128.96, and they keep one entry
in their forwarding tables to tell them how to reach it. Routers within
the campus, however, need to be able to route packets to the right
subnet. Thus, not all parts of the internet see exactly the same routing
information. This is an example of <em>aggregation</em> of routing information,
which is fundamental to scaling of the routing system. The next section
shows how aggregation can be taken to another level.</p>
<h3 id="classless-addressing">Classless Addressing</h3>
<p>Subnetting has a counterpart, sometimes called <em>supernetting</em>, but more
often called <em>Classless Interdomain Routing</em> or CIDR, pronounced
&quot;cider.&quot; CIDR takes the subnetting idea to its logical conclusion by
essentially doing away with address classes altogether. Why isn&apos;t
subnetting alone sufficient? In essence, subnetting only allows us to
split a classful address among multiple subnets, while CIDR allows us to
coalesce several classful addresses into a single &quot;supernet.&quot; This
further tackles the address space inefficiency noted above, and does so
in a way that keeps the routing system from being overloaded.</p>
<p>To see how the issues of address space efficiency and scalability of the
routing system are coupled, consider the hypothetical case of a company
whose network has 256 hosts on it. That is slightly too many for a Class
C address, so you would be tempted to assign a class B. However, using
up a chunk of address space that could address 65535 to address 256
hosts has an efficiency of only 256/65,535 = 0.39%. Even though
subnetting can help us to assign addresses carefully, it does not get
around the fact that any organization with more than 255 hosts, or an
expectation of eventually having that many, wants a class B address.</p>
<p>The first way you might deal with this issue would be to refuse to give
a class B address to any organization that requests one unless they can
show a need for something close to 64K addresses, and instead giving
them an appropriate number of class C addresses to cover the expected
number of hosts. Since we would now be handing out address space in
chunks of 256 addresses at a time, we could more accurately match the
amount of address space consumed to the size of the organization. For
any organization with at least 256 hosts, we can guarantee an address
utilization of at least 50%, and typically much more.</p>
<blockquote>
<p>Even if you can justify a request of a class B network number, don&apos;t
bother. They are all spoken for.</p>
</blockquote>
<p>This solution, however, raises a problem that is at least as serious:
excessive storage requirements at the routers. If a single site has,
say, 16 class C network numbers assigned to it, that means every
Internet backbone router needs 16 entries in its routing tables to
direct packets to that site. This is true even if the path to every one
of those networks is the same. If we had assigned a class B address to
the site, the same routing information could be stored in one table
entry. However, our address assignment efficiency would then be
only 6 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&#xD7;</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.58333em;"></span><span class="strut bottom" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord">&#xD7;</span></span></span></span> 255 / 65,536 = 6.2%.</p>
<p>CIDR, therefore, tries to balance the desire to minimize the number of
routes that a router needs to know against the need to hand out
addresses efficiently. To do this, CIDR helps us to <em>aggregate</em> routes.
That is, it lets us use a single entry in a forwarding table to tell us
how to reach a lot of different networks. As noted above it does this by
breaking the rigid boundaries between address classes. To understand how
this works, consider our hypothetical organization with 16 class C
network numbers. Instead of handing out 16 addresses at random, we can
hand out a block of <em>contiguous</em> class C addresses. Suppose we assign
the class C network numbers from 192.4.16 through 192.4.31. Observe that
the top 20 bits of all the addresses in this range are the same
(<code>11000000 00000100 0001</code>). Thus, what we have effectively created is a
20-bit network number&#x2014;something that is between a class B network
number and a class C number in terms of the number of hosts that it can
support. In other words, we get both the high address efficiency of
handing out addresses in chunks smaller than a class B network, and a
single network prefix that can be used in forwarding tables. Observe
that, for this scheme to work, we need to hand out blocks of class C
addresses that share a common prefix, which means that each block must
contain a number of class C networks that is a power of two.</p>
<p>CIDR requires a new type of notation to represent network numbers, or
<em>prefixes</em> as they are known, because the prefixes can be of any length.
The convention is to place a <code>/X</code> after the prefix, where <code>X</code> is the
prefix length in bits. So, for the example above, the 20-bit prefix for
all the networks 192.4.16 through 192.4.31 is represented as
192.4.16/20. By contrast, if we wanted to represent a single class C
network number, which is 24 bits long, we would write it 192.4.16/24.
Today, with CIDR being the norm, it is more common to hear people talk
about &quot;slash 24&quot; prefixes than class C networks. Note that representing
a network address in this way is similar to the<code>(mask, value)</code>
approach used in subnetting, as long as <code>masks</code> consist of contiguous
bits starting from the most significant bit (which in practice is
almost always the case).</p>
<figure>
    <a id="cidreg"></a>
    <img src="figures/f03-22-9780123850591.png" width="500px">
    <figcaption>Route aggregation with CIDR.</figcaption>
</figure>

<p>The ability to aggregate routes at the edge of the network as we have
just seen is only the first step. Imagine an Internet service provider
network, whose primary job is to provide Internet connectivity to a
large number of corporations and campuses (customers). If we assign
prefixes to the customers in such a way that many different customer
networks connected to the provider network share a common, shorter
address prefix, then we can get even greater aggregation of routes.
Consider the example in <a href="#cidreg">Figure 9</a>. Assume that eight
customers served by the provider network have each been assigned
adjacent 24-bit network prefixes. Those prefixes all start with the same
21 bits. Since all of the customers are reachable through the same
provider network, it can advertise a single route to all of them by just
advertising the common 21-bit prefix they share. And it can do this even
if not all the 24-bit prefixes have been handed out, as long as the
provider ultimately <em>will</em> have the right to hand out those prefixes to
a customer. One way to accomplish that is to assign a portion of address
space to the provider in advance and then to let the network provider
assign addresses from that space to its customers as needed. Note that,
in contrast to this simple example, there is no need for all customer
prefixes to be the same length.</p>
<h3 id="ip-forwarding-revisited">IP Forwarding Revisited</h3>
<p>In all our discussion of IP forwarding so far, we have assumed that we
could find the network number in a packet and then look up that number
in a forwarding table. However, now that we have introduced CIDR, we
need to reexamine this assumption. CIDR means that prefixes may be of
any length, from 2 to 32 bits. Furthermore, it is sometimes possible to
have prefixes in the forwarding table that &quot;overlap,&quot; in the sense that
some addresses may match more than one prefix. For example, we might
find both 171.69 (a 16-bit prefix) and 171.69.10 (a 24-bit prefix) in
the forwarding table of a single router. In this case, a packet destined
to, say, 171.69.10.5 clearly matches both prefixes. The rule in this
case is based on the principle of &quot;longest match&quot;; that is, the packet
matches the longest prefix, which would be 171.69.10 in this example. On
the other hand, a packet destined to 171.69.20.5 would match 171.69 and
<em>not</em> 171.69.10, and in the absence of any other matching entry in the
routing table 171.69 would be the longest match.</p>
<p>The task of efficiently finding the longest match between an IP address
and the variable-length prefixes in a forwarding table has been a
fruitful field of research for many years. The most well-known
algorithm uses an approach known as a <em>PATRICIA tree</em>, which was
actually developed well in advance of CIDR.</p>
<h2 id="address-translation-arp">Address Translation (ARP)</h2>
<p>In the previous section we talked about how to get IP datagrams to the
right physical network but glossed over the issue of how to get a
datagram to a particular host or router on that network. The main issue
is that IP datagrams contain IP addresses, but the physical interface
hardware on the host or router to which you want to send the datagram
only understands the addressing scheme of that particular network. Thus,
we need to translate the IP address to a link-level address that makes
sense on this network (e.g., a 48-bit Ethernet address). We can then
encapsulate the IP datagram inside a frame that contains that link-level
address and send it either to the ultimate destination or to a router
that promises to forward the datagram toward the ultimate destination.</p>
<p>One simple way to map an IP address into a physical network address is
to encode a host&apos;s physical address in the host part of its IP address.
For example, a host with physical address <code>00100001 01001001</code> (which has
the decimal value 33 in the upper byte and 81 in the lower byte) might
be given the IP address <code>128.96.33.81</code>. While this solution has been
used on some networks, it is limited in that the network&apos;s physical
addresses can be no more than 16 bits long in this example; they can be
only 8 bits long on a class C network. This clearly will not work for
48-bit Ethernet addresses.</p>
<p>A more general solution would be for each host to maintain a table of
address pairs; that is, the table would map IP addresses into physical
addresses. While this table could be centrally managed by a system
administrator and then copied to each host on the network, a better
approach would be for each host to dynamically learn the contents of the
table using the network. This can be accomplished using the Address
Resolution Protocol (ARP). The goal of ARP is to enable each host on a
network to build up a table of mappings between IP addresses and
link-level addresses. Since these mappings may change over time (e.g.,
because an Ethernet card in a host breaks and is replaced by a new one
with a new address), the entries are timed out periodically and removed.
This happens on the order of every 15 minutes. The set of mappings
currently stored in a host is known as the ARP cache or ARP table.</p>
<p>ARP takes advantage of the fact that many link-level network
technologies, such as Ethernet, support broadcast. If a host wants to
send an IP datagram to a host (or router) that it knows to be on the
same network (i.e., the sending and receiving node have the same IP
network number), it first checks for a mapping in the cache. If no
mapping is found, it needs to invoke the Address Resolution Protocol
over the network. It does this by broadcasting an ARP query onto the
network. This query contains the IP address in question (the target IP
address). Each host receives the query and checks to see if it matches
its IP address. If it does match, the host sends a response message that
contains its link-layer address back to the originator of the query. The
originator adds the information contained in this response to its ARP
table.</p>
<p>The query message also includes the IP address and link-layer address of
the sending host. Thus, when a host broadcasts a query message, each
host on the network can learn the sender&apos;s link-level and IP addresses
and place that information in its ARP table. However, not every host
adds this information to its ARP table. If the host already has an entry
for that host in its table, it &quot;refreshes&quot; this entry; that is, it
resets the length of time until it discards the entry. If that host is
the target of the query, then it adds the information about the sender
to its table, even if it did not already have an entry for that host.
This is because there is a good chance that the source host is about to
send it an application-level message, and it may eventually have to send
a response or ACK back to the source; it will need the source&apos;s physical
address to do this. If a host is not the target and does not already
have an entry for the source in its ARP table, then it does not add an
entry for the source. This is because there is no reason to believe that
this host will ever need the source&apos;s link-level address; there is no
need to clutter its ARP table with this information.</p>
<figure>
    <a id="arp"></a>
    <img src="figures/f03-23-9780123850591.png" width="500px">
    <figcaption>ARP packet format for mapping IP addresses into
    Ethernet addresses.</figcaption>
</figure>

<p><a href="#arp">Figure 10</a> shows the ARP packet format for
IP-to-Ethernet address mappings. In fact, ARP can be used for lots of
other kinds of mappings&#x2014;the major differences are in the address
sizes. In addition to the IP and link-layer addresses of both sender
and target, the packet contains</p>
<ul>
<li><p>A <code>HardwareType</code> field, which specifies the type of physical network
  (e.g., Ethernet)</p>
</li>
<li><p>A <code>ProtocolType</code> field, which specifies the higher-layer protocol
  (e.g., IP)</p>
</li>
<li><p><code>HLen</code> (&quot;hardware&quot; address length) and <code>PLen</code> (&quot;protocol&quot; address
  length) fields, which specify the length of the link-layer address
  and higher-layer protocol address, respectively</p>
</li>
<li><p>An <code>Operation</code> field, which specifies whether this is a request or a
  response</p>
</li>
<li><p>The source and target hardware (Ethernet) and protocol (IP)
  addresses</p>
</li>
</ul>
<p>Note that the results of the ARP process can be added as an extra column
in a forwarding table like the one in <a href="#ipfwdtab">Table 1</a>. Thus, for example,
when R2 needs to forward a packet to network 2, it not only finds that the
next hop is R1, but also finds the MAC address to place on the packet to
send it to R1.</p>
<blockquote>
<p>[!Note|style:flat|label:Key Takeaway|iconVisibility:hidden]
We have now seen the basic mechanisms that IP provides for dealing with
both heterogeneity and scale. On the issue of heterogeneity, IP begins
by defining a best-effort service model that makes minimal assumptions
about the underlying networks; most notably, this service model is based
on unreliable datagrams. IP then makes two important additions to this
starting point: (1) a common packet format (fragmentation/reassembly is
the mechanism that makes this format work over networks with different
MTUs) and (2) a global address space for identifying all hosts (ARP is
the mechanism that makes this global address space work over networks
with different physical addressing schemes). On the issue of scale, IP
uses hierarchical aggregation to reduce the amount of information needed
to forward packets. Specifically, IP addresses are partitioned into
network and host components, with packets first routed toward the
destination network and then delivered to the correct host on that
network.</p>
</blockquote>
<h2 id="host-configuration-dhcp">Host Configuration (DHCP)</h2>
<p>Ethernet addresses are configured into the network adaptor by the
manufacturer, and this process is managed in such a way to ensure that
these addresses are globally unique. This is clearly a sufficient
condition to ensure that any collection of hosts connected to a single
Ethernet (including an extended LAN) will have unique
addresses. Furthermore, uniqueness is all we ask of Ethernet addresses.</p>
<p>IP addresses, by contrast, not only must be unique on a given
internetwork but also must reflect the structure of the internetwork. As
noted above, they contain a network part and a host part, and the
network part must be the same for all hosts on the same network. Thus,
it is not possible for the IP address to be configured once into a host
when it is manufactured, since that would imply that the manufacturer
knew which hosts were going to end up on which networks, and it would
mean that a host, once connected to one network, could never move to
another. For this reason, IP addresses need to be reconfigurable.</p>
<p>In addition to an IP address, there are some other pieces of information
a host needs to have before it can start sending packets. The most
notable of these is the address of a default router&#x2014;the place to which
it can send packets whose destination address is not on the same network
as the sending host.</p>
<p>Most host operating systems provide a way for a system administrator, or
even a user, to manually configure the IP information needed by a host;
however, there are some obvious drawbacks to such manual configuration.
One is that it is simply a lot of work to configure all the hosts in a
large network directly, especially when you consider that such hosts are
not reachable over a network until they are configured. Even more
importantly, the configuration process is very error prone, since it is
necessary to ensure that every host gets the correct network number and
that no two hosts receive the same IP address. For these reasons,
automated configuration methods are required. The primary method uses a
protocol known as the <em>Dynamic Host Configuration Protocol</em> (DHCP).</p>
<p>DHCP relies on the existence of a DHCP server that is responsible for
providing configuration information to hosts. There is at least one DHCP
server for an administrative domain. At the simplest level, the DHCP
server can function just as a centralized repository for host
configuration information. Consider, for example, the problem of
administering addresses in the internetwork of a large company. DHCP
saves the network administrators from having to walk around to every
host in the company with a list of addresses and network map in hand and
configuring each host manually. Instead, the configuration information
for each host could be stored in the DHCP server and automatically
retrieved by each host when it is booted or connected to the network.
However, the administrator would still pick the address that each host
is to receive; he would just store that in the server. In this model,
the configuration information for each host is stored in a table that is
indexed by some form of unique client identifier, typically the hardware
address (e.g., the Ethernet address of its network adaptor).</p>
<p>A more sophisticated use of DHCP saves the network administrator from
even having to assign addresses to individual hosts. In this model, the
DHCP server maintains a pool of available addresses that it hands out to
hosts on demand. This considerably reduces the amount of configuration
an administrator must do, since now it is only necessary to allocate a
range of IP addresses (all with the same network number) to each
network.</p>
<p>Since the goal of DHCP is to minimize the amount of manual configuration
required for a host to function, it would rather defeat the purpose if
each host had to be configured with the address of a DHCP server. Thus,
the first problem faced by DHCP is that of server discovery.</p>
<p>To contact a DHCP server, a newly booted or attached host sends a
<code>DHCPDISCOVER</code> message to a special IP address (255.255.255.255) that is
an IP broadcast address. This means it will be received by all hosts and
routers on that network. (Routers do not forward such packets onto other
networks, preventing broadcast to the entire Internet.) In the simplest
case, one of these nodes is the DHCP server for the network. The server
would then reply to the host that generated the discovery message (all
the other nodes would ignore it). However, it is not really desirable to
require one DHCP server on every network, because this still creates a
potentially large number of servers that need to be correctly and
consistently configured. Thus, DHCP uses the concept of a <em>relay agent</em>.
There is at least one relay agent on each network, and it is configured
with just one piece of information: the IP address of the DHCP server.
When a relay agent receives a <code>DHCPDISCOVER</code> message, it unicasts it to
the DHCP server and awaits the response, which it will then send back to
the requesting client. The process of relaying a message from a host to
a remote DHCP server is shown in <a href="#dhcp-relay">Figure 11</a>.</p>
<figure>
    <a id="dhcp-relay"></a>
    <img src="figures/f03-24-9780123850591.png" width="500px">
    <figcaption>A DHCP relay agent receives a broadcast DHCPDISCOVER
    message from a host and sends a unicast DHCPDISCOVER to the DHCP
    server.</figcaption>
</figure>

<p><a href="#dhcp">Figure 12</a> below shows the format of a DHCP message. The
message is actually sent using a protocol called the <em>User Datagram
Protocol</em> (UDP) that runs over IP. UDP is discussed in detail in the
next chapter, but the only interesting thing it does in this context
is to provide a demultiplexing key that says, &quot;This is a DHCP packet.&quot;</p>
<figure>
    <a id="dhcp"></a>
    <img src="figures/f03-25-9780123850591.png" width="400px">
    <figcaption>DHCP packet format.</figcaption>
</figure>

<p>DHCP is derived from an earlier protocol called BOOTP, and some of the
packet fields are thus not strictly relevant to host configuration. When
trying to obtain configuration information, the client puts its hardware
address (e.g., its Ethernet address) in the <code>chaddr</code> field. The DHCP
server replies by filling in the <code>yiaddr</code> (&quot;your&quot; IP address) field and
sending it to the client. Other information such as the default router
to be used by this client can be included in the <code>options</code> field.</p>
<p>In the case where DHCP dynamically assigns IP addresses to hosts, it is
clear that hosts cannot keep addresses indefinitely, as this would
eventually cause the server to exhaust its address pool. At the same
time, a host cannot be depended upon to give back its address, since it
might have crashed, been unplugged from the network, or been turned off.
Thus, DHCP allows addresses to be leased for some period of time. Once
the lease expires, the server is free to return that address to its
pool. A host with a leased address clearly needs to renew the lease
periodically if in fact it is still connected to the network and
functioning correctly.</p>
<blockquote>
<p>[!Note|style:flat|label:Key Takeaway|iconVisibility:hidden]
DHCP illustrates an important aspect of scaling: the scaling of network
management. While discussions of scaling often focus on keeping the
state in network devices from growing too fast, it is important to pay
attention to growth of network management complexity. By allowing
network managers to configure a range of IP addresses per network rather
than one IP address per host, DHCP improves the manageability of a
network.</p>
</blockquote>
<p>Note that DHCP may also introduce some more complexity into network
management, since it makes the binding between physical hosts and IP
addresses much more dynamic. This may make the network manager&apos;s job
more difficult if, for example, it becomes necessary to locate a
malfunctioning host.</p>
<h2 id="error-reporting-icmp">Error Reporting (ICMP)</h2>
<p>The next issue is how the Internet treats errors. While IP is perfectly
willing to drop datagrams when the going gets tough&#x2014;for example, when
a router does not know how to forward the datagram or when one fragment
of a datagram fails to arrive at the destination&#x2014;it does not
necessarily fail silently. IP is always configured with a companion
protocol, known as the <em>Internet Control Message Protocol</em> (ICMP), that
defines a collection of error messages that are sent back to the source
host whenever a router or host is unable to process an IP datagram
successfully. For example, ICMP defines error messages indicating that
the destination host is unreachable (perhaps due to a link failure),
that the reassembly process failed, that the TTL had reached 0, that the
IP header checksum failed, and so on.</p>
<p>ICMP also defines a handful of control messages that a router can send
back to a source host. One of the most useful control messages, called
an <em>ICMP-Redirect</em>, tells the source host that there is a better route
to the destination. ICMP-Redirects are used in the following situation.
Suppose a host is connected to a network that has two routers attached
to it, called <em>R1</em> and <em>R2</em>, where the host uses R1 as its default
router. Should R1 ever receive a datagram from the host, where based on
its forwarding table it knows that R2 would have been a better choice
for a particular destination address, it sends an ICMP-Redirect back to
the host, instructing it to use R2 for all future datagrams addressed to
that destination. The host then adds this new route to its forwarding
table.</p>
<p>ICMP also provides the basis for two widely used debugging tools, <code>ping</code>
and <code>traceroute</code>. <code>ping</code> uses ICMP echo messages to determine if a node
is reachable and alive. <code>traceroute</code> uses a slightly non-intuitive
technique to determine the set of routers along the path to a
destination, which is the topic for one of the exercises at the end of
this chapter.</p>
<h2 id="virtual-networks-and-tunnels">Virtual Networks and Tunnels</h2>
<p>We conclude our introduction to IP by considering an issue you might not
have anticipated, but one that is becoming increasingly important.
Our discussion up to this point has focused on making it possible for
nodes on different networks to communicate with each other in an
unrestricted way. This is the usually the goal in the
Internet&#x2014;everybody wants to be able to send email to everybody, and
the creator of a new website wants to reach the widest possible
audience. However, there are many situations where more controlled
connectivity is required. An important example of such a situation is
the <em>virtual private network</em> (VPN).</p>
<p>The term <em>VPN</em> is heavily overused and definitions vary, but intuitively
we can define a VPN by considering first the idea of a private network.
Corporations with many sites often build private networks by leasing
transmission lines from the phone companies and using those lines to
interconnect sites. In such a network, communication is restricted to
take place only among the sites of that corporation, which is often
desirable for security reasons. To make a private network <em>virtual</em>, the
leased transmission lines&#x2014;which are not shared with any other
corporations&#x2014;would be replaced by some sort of shared network. A
virtual circuit (VC) is a very reasonable replacement for a leased line
because it still provides a logical point-to-point connection between
the corporation&apos;s sites. For example, if corporation X has a VC from
site A to site B, then clearly it can send packets between sites A and
B. But there is no way that corporation Y can get its packets delivered
to site B without first establishing its own virtual circuit to site B,
and the establishment of such a VC can be administratively prevented,
thus preventing unwanted connectivity between corporation X and
corporation Y.</p>
<p><a href="#vpn">Figure 13(a)</a> shows two private networks for two
separate corporations. In <a href="#vpn">Figure 13(b)</a> they are both migrated to
a virtual circuit network. The limited connectivity of a real private
network is maintained, but since the private networks now share the same
transmission facilities and switches we say that two virtual private
networks have been created.</p>
<figure>
    <a id="vpn"></a>
    <img src="figures/f03-26-9780123850591.png" width="500px">
    <figcaption>An example of virtual private networks: (a) two
    separate private networks; (b) two virtual private networks
    sharing common switches.</figcaption>
</figure>

<p>In <a href="#vpn">Figure 13</a>, a virtual circuit network (using ATM, for
example) is used to provide the controlled connectivity among
sites. It is also possible to provide a similar function using an IP
network to provide the connectivity. However, we
cannot just connect the various corporations&apos; sites to a single
internetwork because that would provide connectivity between
corporation X and corporation Y, which we wish to avoid. To solve this
problem, we need to introduce a new concept, the <em>IP tunnel</em>.</p>
<p>We can think of an IP tunnel as a virtual point-to-point link between a
pair of nodes that are actually separated by an arbitrary number of
networks. The virtual link is created within the router at the entrance
to the tunnel by providing it with the IP address of the router at the
far end of the tunnel. Whenever the router at the entrance of the tunnel
wants to send a packet over this virtual link, it encapsulates the
packet inside an IP datagram. The destination address in the IP header
is the address of the router at the far end of the tunnel, while the
source address is that of the encapsulating router.</p>
<figure>
    <a id="tunnel"></a>
    <img src="figures/f03-27-9780123850591.png" width="600px">
    <figcaption>A tunnel through an internetwork. 18.5.0.1 is the
    address of R2 that can be reached from R1 across the
    internetwork.</figcaption>
</figure>

<p>In the forwarding table of the router at the entrance to the tunnel,
this virtual link looks much like a normal link. Consider, for example,
the network in <a href="#tunnel">Figure 14</a>. A tunnel has been
configured from R1 to R2 and assigned a virtual interface number
of 0. The forwarding table in R1 might therefore look like
<a href="#tunneltab">Table 4</a>.</p>
<p><a id="tunneltab"></a></p>
<table>
<thead>
<tr>
<th style="text-align:center">NetworkNum</th>
<th style="text-align:center">NextHop</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">Interface 0</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">Virtual interface 0</td>
</tr>
<tr>
<td style="text-align:center">Default</td>
<td style="text-align:center">Interface 1</td>
</tr>
</tbody>
</table>
<table>
<caption>Table 4. Forwarding Table for Router R1 in [Figure 14](#tunnel).</caption>
</table>

<p>R1 has two physical interfaces. Interface 0 connects to network 1;
interface 1 connects to a large internetwork and is thus the default for
all traffic that does not match something more specific in the
forwarding table. In addition, R1 has a virtual interface, which is the
interface to the tunnel. Suppose R1 receives a packet from network 1
that contains an address in network 2. The forwarding table says this
packet should be sent out virtual interface 0. In order to send a packet
out this interface, the router takes the packet, adds an IP header
addressed to R2, and then proceeds to forward the packet as if it had
just been received. R2&apos;s address is 18.5.0.1; since the network number
of this address is 18, not 1 or 2, a packet destined for R2 will be
forwarded out the default interface into the internetwork.</p>
<p>Once the packet leaves R1, it looks to the rest of the world like a
normal IP packet destined to R2, and it is forwarded accordingly. All
the routers in the internetwork forward it using normal means, until it
arrives at R2. When R2 receives the packet, it finds that it carries its
own address, so it removes the IP header and looks at the payload of the
packet. What it finds is an inner IP packet whose destination address is
in network 2. R2 now processes this packet like any other IP packet it
receives. Since R2 is directly connected to network 2, it forwards the
packet on to that network. <a href="#tunnel">Figur 14</a> shows the
change in encapsulation of the packet as it moves across the network.</p>
<p>While R2 is acting as the endpoint of the tunnel, there is nothing to
prevent it from performing the normal functions of a router. For
example, it might receive some packets that are not tunneled, but that
are addressed to networks that it knows how to reach, and it would
forward them in the normal way.</p>
<p>You might wonder why anyone would want to go to all the trouble of
creating a tunnel and changing the encapsulation of a packet as it goes
across an internetwork. One reason is security.
Supplemented with encryption, a tunnel can
become a very private sort of link across a public network. Another
reason may be that R1 and R2 have some capabilities that are not widely
available in the intervening networks, such as multicast routing. By
connecting these routers with a tunnel, we can build a virtual network
in which all the routers with this capability appear to be directly
connected. A third reason to build
tunnels is to carry packets from protocols other than IP across an IP
network. As long as the routers at either end of the tunnel know how to
handle these other protocols, the IP tunnel looks to them like a
point-to-point link over which they can send non-IP packets. Tunnels
also provide a mechanism by which we can force a packet to be delivered
to a particular place even if its original header&#x2014;the one that gets
encapsulated inside the tunnel header&#x2014;might suggest that it should go
somewhere else. Thus, we see that tunneling is a powerful and quite
general technique for building virtual links across internetworks. So
general, in fact, that the technique recurses, with the most common
use case being to tunnel IP over IP.</p>
<p>Tunneling does have its downsides. One is that it increases the length
of packets; this might represent a significant waste of bandwidth for
short packets. Longer packets might be subject to fragmentation, which
has its own set of drawbacks. There may also be performance implications
for the routers at either end of the tunnel, since they need to do more
work than normal forwarding as they add and remove the tunnel header.
Finally, there is a management cost for the administrative entity that
is responsible for setting up the tunnels and making sure they are
correctly handled by the routing protocols.</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="switching.html" class="navigation navigation-prev " aria-label="Previous page: 3.1 Switching and Bridging">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="routing.html" class="navigation navigation-next " aria-label="Next page: 3.3 Routing">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"3.2 Basic Internetworking","level":"1.4.2","depth":2,"next":{"title":"3.3 Routing","level":"1.4.3","depth":2,"path":"internetworking/routing.md","ref":"internetworking/routing.md","articles":[]},"previous":{"title":"3.1 Switching and Bridging","level":"1.4.1","depth":2,"path":"internetworking/switching.md","ref":"internetworking/switching.md","articles":[]},"dir":"ltr"},"config":{"plugins":["anchorjs","katex","block-align","flexible-alerts","sequence-diagrams","creativecommons","intopic-toc","custom-favicon","smart-nav-collapse"],"root":".","styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css"},"pluginsConfig":{"intopic-toc":{"label":"Content","selector":".markdown-section h2","visible":true},"block-align":{},"search":{},"sequence-diagrams":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"katex":{},"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"favicon":"bridge.ico","custom-favicon":{},"creativecommons":{},"flexible-alerts":{"danger":{"className":"danger","icon":"fa fa-ban","label":"Attention"},"note":{"className":"info","icon":"fa fa-info-circle","label":"Note"},"style":"callout","tip":{"className":"tip","icon":"fa fa-lightbulb-o","label":"Tip"},"warning":{"className":"warning","icon":"fa fa-exclamation-triangle","label":"Warning"}},"smart-nav-collapse":{},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false},"anchorjs":{}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{"branch":"master"},"title":"Computer Networks: A Systems Approach","gitbook":"*"},"file":{"path":"internetworking/basic-ip.md","mtime":"2019-05-28T18:17:20.000Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2019-05-28T20:44:34.155Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-anchorjs/anchor.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-anchorjs/anchor-style.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-flexible-alerts/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-intopic-toc/anchor.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-intopic-toc/gumshoe.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-intopic-toc/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-smart-nav-collapse/smart-nav-collapse.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

