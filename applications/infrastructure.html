
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>9.3 Infrastructure Applications Â· Computer Networks: A Systems Approach</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-katex/katex.min.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-block-align/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-smart-nav-collapse/smart-nav-collapse.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
        <link rel="stylesheet" href="../styles/website.css">
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="overlays.html" />
    
    
    <link rel="prev" href="multimedia.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Preface
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../foundation/problem.html">
            
                <a href="../foundation/problem.html">
            
                    
                    Chapter 1: Foundation
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="../foundation/applications.html">
            
                <a href="../foundation/applications.html">
            
                    
                    1.1 Applications
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="../foundation/requirements.html">
            
                <a href="../foundation/requirements.html">
            
                    
                    1.2 Requirements
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="../foundation/architecture.html">
            
                <a href="../foundation/architecture.html">
            
                    
                    1.3 Architecture
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.4" data-path="../foundation/software.html">
            
                <a href="../foundation/software.html">
            
                    
                    1.4 Software
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.5" data-path="../foundation/performance.html">
            
                <a href="../foundation/performance.html">
            
                    
                    1.5 Performance
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.6" data-path="../foundation/summary.html">
            
                <a href="../foundation/summary.html">
            
                    
                    1.6 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../direct/problem.html">
            
                <a href="../direct/problem.html">
            
                    
                    Chapter 2: Direct Connections
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="../direct/perspective.html">
            
                <a href="../direct/perspective.html">
            
                    
                    2.1 Technology Landscape
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="../direct/encoding.html">
            
                <a href="../direct/encoding.html">
            
                    
                    2.2 Encoding
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3" data-path="../direct/framing.html">
            
                <a href="../direct/framing.html">
            
                    
                    2.3 Framing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4" data-path="../direct/error.html">
            
                <a href="../direct/error.html">
            
                    
                    2.4 Error Detection
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.5" data-path="../direct/reliable.html">
            
                <a href="../direct/reliable.html">
            
                    
                    2.5 Reliable Transmission
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.6" data-path="../direct/ethernet.html">
            
                <a href="../direct/ethernet.html">
            
                    
                    2.6 Multi-Access Networks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.7" data-path="../direct/wireless.html">
            
                <a href="../direct/wireless.html">
            
                    
                    2.7 Wireless Networks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.8" data-path="../direct/access.html">
            
                <a href="../direct/access.html">
            
                    
                    2.8 Access Networks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.9" data-path="../direct/summary.html">
            
                <a href="../direct/summary.html">
            
                    
                    2.9 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="../internetworking/problem.html">
            
                <a href="../internetworking/problem.html">
            
                    
                    Chapter 3: Internetworking
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="../internetworking/switching.html">
            
                <a href="../internetworking/switching.html">
            
                    
                    3.1 Switching and Bridging
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="../internetworking/basic-ip.html">
            
                <a href="../internetworking/basic-ip.html">
            
                    
                    3.2 Basic Internetworking
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3" data-path="../internetworking/routing.html">
            
                <a href="../internetworking/routing.html">
            
                    
                    3.3 Routing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4" data-path="../internetworking/impl.html">
            
                <a href="../internetworking/impl.html">
            
                    
                    3.4 Implementation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.5" data-path="../internetworking/summary.html">
            
                <a href="../internetworking/summary.html">
            
                    
                    3.5 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="../scaling/problem.html">
            
                <a href="../scaling/problem.html">
            
                    
                    Chapter 4: Advanced Internetworking
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.1" data-path="../scaling/global.html">
            
                <a href="../scaling/global.html">
            
                    
                    4.1 Global Internet
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.2" data-path="../scaling/multicast.html">
            
                <a href="../scaling/multicast.html">
            
                    
                    4.2 Multicast
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.3" data-path="../scaling/mpls.html">
            
                <a href="../scaling/mpls.html">
            
                    
                    4.3 Multiprotocol Label Switching
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.4" data-path="../scaling/mobile-ip.html">
            
                <a href="../scaling/mobile-ip.html">
            
                    
                    4.4 Routing Among Mobile Devices
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.5" data-path="../scaling/summary.html">
            
                <a href="../scaling/summary.html">
            
                    
                    4.5 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="../e2e/problem.html">
            
                <a href="../e2e/problem.html">
            
                    
                    Chapter 5: End-to-End Protocols
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.6.1" data-path="../e2e/udp.html">
            
                <a href="../e2e/udp.html">
            
                    
                    5.1 Simple Demultiplexor (UDP)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2" data-path="../e2e/tcp.html">
            
                <a href="../e2e/tcp.html">
            
                    
                    5.2 Reliable Byte Stream (TCP)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.3" data-path="../e2e/rpc.html">
            
                <a href="../e2e/rpc.html">
            
                    
                    5.3 Remote Procedure Call
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.4" data-path="../e2e/rtp.html">
            
                <a href="../e2e/rtp.html">
            
                    
                    5.4 Transport for Real-Time (RTP)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.5" data-path="../e2e/summary.html">
            
                <a href="../e2e/summary.html">
            
                    
                    5.5 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="../congestion/problem.html">
            
                <a href="../congestion/problem.html">
            
                    
                    Chapter 6: Congestion Control
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.1" data-path="../congestion/issues.html">
            
                <a href="../congestion/issues.html">
            
                    
                    6.1 Issues in Resource Allocation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.2" data-path="../congestion/queuing.html">
            
                <a href="../congestion/queuing.html">
            
                    
                    6.2 Queuing Disciplines
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.3" data-path="../congestion/tcpcc.html">
            
                <a href="../congestion/tcpcc.html">
            
                    
                    6.3 TCP Congestion Control
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4" data-path="../congestion/avoidance.html">
            
                <a href="../congestion/avoidance.html">
            
                    
                    6.4 Congestion-Avoidance
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.5" data-path="../congestion/qos.html">
            
                <a href="../congestion/qos.html">
            
                    
                    6.5 Quality of Service
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.6" data-path="../congestion/summary.html">
            
                <a href="../congestion/summary.html">
            
                    
                    6.6 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="../data/problem.html">
            
                <a href="../data/problem.html">
            
                    
                    Chapter 7: End-to-End Data
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.8.1" data-path="../data/presentation.html">
            
                <a href="../data/presentation.html">
            
                    
                    7.1 Presentation Formatting
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.2" data-path="../data/multimedia.html">
            
                <a href="../data/multimedia.html">
            
                    
                    7.2 Multimedia Data
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.3" data-path="../data/summary.html">
            
                <a href="../data/summary.html">
            
                    
                    7.3 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="../security/problem.html">
            
                <a href="../security/problem.html">
            
                    
                    Chapter 8: Network Security
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.9.1" data-path="../security/crypto.html">
            
                <a href="../security/crypto.html">
            
                    
                    8.1 Cryptographic Building Blocks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2" data-path="../security/key-distro.html">
            
                <a href="../security/key-distro.html">
            
                    
                    8.2 Key Predistribution
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.3" data-path="../security/authentication.html">
            
                <a href="../security/authentication.html">
            
                    
                    8.3 Authentication Protocols
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.4" data-path="../security/systems.html">
            
                <a href="../security/systems.html">
            
                    
                    8.4 Example Systems
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.5" data-path="../security/summary.html">
            
                <a href="../security/summary.html">
            
                    
                    8.5 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="problem.html">
            
                <a href="problem.html">
            
                    
                    Chapter 9: Applications
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.10.1" data-path="traditional.html">
            
                <a href="traditional.html">
            
                    
                    9.1 Traditional Applications
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.2" data-path="multimedia.html">
            
                <a href="multimedia.html">
            
                    
                    9.2 Multimedia Applications
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.10.3" data-path="infrastructure.html">
            
                <a href="infrastructure.html">
            
                    
                    9.3 Infrastructure Applications
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.4" data-path="overlays.html">
            
                <a href="overlays.html">
            
                    
                    9.4 Overlay Networks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.5" data-path="summary.html">
            
                <a href="summary.html">
            
                    
                    9.5 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >9.3 Infrastructure Applications</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="93-infrastructure-applications">9.3 Infrastructure Applications</h1>
<p>There are some protocols that are essential to the smooth running of the
Internet but that don&apos;t fit neatly into the strictly layered model. One
of these is the Domain Name System (DNS)&#x2014;not an application that users
normally invoke directly, but rather a service that almost all other
applications depend upon. This is because the name service is used to
translate host names into host addresses; the existence of such an
application allows the users of other applications to refer to remote
hosts by name rather than by address. In other words, a name service is
usually used by other applications, rather than by humans.</p>
<p>A second critical function is network management, which although not so
familiar to the average user, is the operation performed most often by
system administrators. Network management is widely considered one of
the hard problems of networking and continues to be the focus of much
research. We&apos;ll look at some of the issues and approaches to the problem
below.</p>
<h2 id="name-service-dns">Name Service (DNS)</h2>
<p>In most of this book, we have been using addresses to identify hosts.
While perfectly suited for processing by routers, addresses are not
exactly user friendly. It is for this reason that a unique <em>name</em> is
also typically assigned to each host in a network. Already in this
section we have seen application protocols like HTTP using names
such as <code>www.princeton.edu</code>. We now describe how a naming service can
be developed to map user-friendly names into router-friendly
addresses. Name services are sometimes called <em>middleware</em> because
they fill a gap between applications and the underlying network.</p>
<p>Host names differ from host addresses in two important ways. First, they
are usually of variable length and mnemonic, thereby making them easier
for humans to remember. (In contrast, fixed-length numeric addresses are
easier for routers to process.) Second, names typically contain no
information that helps the network locate (route packets toward) the
host. Addresses, in contrast, sometimes have routing information
embedded in them; <em>flat</em> addresses (those not divisible into component
parts) are the exception.</p>
<p>Before getting into the details of how hosts are named in a network, we
first introduce some basic terminology. First, a <em>name space</em> defines
the set of possible names. A name space can be either <em>flat</em> (names are
not divisible into components) or <em>hierarchical</em> (Unix file names are an
obvious example). Second, the naming system maintains a collection of
<em>bindings</em> of names to values. The value can be anything we want the
naming system to return when presented with a name; in many cases, it is
an address. Finally, a <em>resolution mechanism</em> is a procedure that, when
invoked with a name, returns the corresponding value. A <em>name server</em> is
a specific implementation of a resolution mechanism that is available on
a network and that can be queried by sending it a message.</p>
<p>Because of its large size, the Internet has a particularly
well-developed naming system in place&#x2014;the Domain Name System (DNS). We
therefore use DNS as a framework for discussing the problem of naming
hosts. Note that the Internet did not always use DNS. Early in its
history, when there were only a few hundred hosts on the Internet, a
central authority called the <em>Network Information Center</em> (NIC)
maintained a flat table of name-to-address bindings; this table was
called <code>HOSTS.TXT</code>. Whenever a site wanted to add a new host to the
Internet, the site administrator sent email to the NIC giving the new host&apos;s
name/address pair. This information was manually entered into the table,
the modified table was mailed out to the various sites every few days,
and the system administrator at each site installed the table on every
host at the site. Name resolution was then simply implemented by a
procedure that looked up a host&apos;s name in the local copy of the table
and returned the corresponding address.</p>
<blockquote>
<p>Believe it or not, there was also a paper book (like a phone book)
published periodically that listed all the machines connected to the
Internet and all people that had an Internet email account.</p>
</blockquote>
<p>It should come as no surprise that the approach to naming did not work
well as the number of hosts in the Internet started to grow. Therefore,
in the mid-1980s, the Domain Naming System was put into place. DNS
employs a hierarchical namespace rather than a flat name space, and the
&quot;table&quot; of bindings that implements this name space is partitioned into
disjoint pieces and distributed throughout the Internet. These subtables
are made available in name servers that can be queried over the network.</p>
<p>What happens in the Internet is that a user presents a host name to an
application program (possibly embedded in a compound name such as an
email address or URL), and this program engages the naming system to
translate this name into a host address. The application then opens a
connection to this host by presenting some transport protocol (e.g.,
TCP) with the host&apos;s IP address. This situation is illustrated (in the
case of sending email) in <a href="#names">Figure 1</a>. While this picture makes
the name resolution task look simple enough, there is a bit more to it,
as we shall see.</p>
<figure class="line">
    <a id="names"></a>
    <img src="figures/f09-14-9780123850591.png" width="400px">
    <figcaption>Names translated into addresses, where the numbers 1
    to 5 show the sequence of steps in the process.</figcaption>
</figure>

<h3 id="domain-hierarchy">Domain Hierarchy</h3>
<p>DNS implements a hierarchical name space for Internet objects. Unlike
Unix file names, which are processed from left to right with the naming
components separated with slashes, DNS names are processed from right to
left and use periods as the separator. (Although they are processed from
right to left, humans still read domain names from left to right.) An
example domain name for a host is <code>cicada.cs.princeton.edu</code>.
Notice that we said domain names are
used to name Internet &quot;objects.&quot; What we mean by this is that DNS is not
strictly used to map host names into host addresses. It is more accurate
to say that DNS maps domain names into values. For the time being, we
assume that these values are IP addresses; we will come back to this
issue later in this section.</p>
<figure class="line">
    <a id="domains"></a>
    <img src="figures/f09-15-9780123850591.png" width="700px">
    <figcaption>Example of a domain hierarchy.</figcaption>
</figure>

<p>Like the Unix file hierarchy, the DNS hierarchy can be visualized as a
tree, where each node in the tree corresponds to a domain, and the
leaves in the tree correspond to the hosts being named.
<a href="#domains">Figure 2</a> gives an example of a domain hierarchy. Note that
we should not assign any semantics to the term <em>domain</em> other than that
it is simply a context in which additional names can be defined.</p>
<blockquote>
<p>Confusingly, the word <em>domain</em> is also used in Internet routing,
where it means something different than it does in DNS, being 
roughly equivalent to the term <em>autonomous system</em>. </p>
</blockquote>
<p>There was actually a substantial amount of discussion that took place
when the domain name hierarchy was first being developed as to what
conventions would govern the names that were to be handed out near the
top of the hierarchy. Without going into that discussion in any detail,
notice that the hierarchy is not very wide at the first level. There are
domains for each country, plus the &quot;big six&quot; domains: <code>.edu</code>, <code>.com</code>,
<code>.gov</code>, <code>.mil</code>, <code>.org</code>, and <code>.net</code>. These six
domains were all originally based in the United States (where the
Internet and DNS were invented); for example, only U.S.-accredited
educational institutions can register an <code>.edu</code> domain name. In recent
years, the number of top-level domains has been expanded, partly to
deal with the high demand for <code>.com</code> domains names. The newer
top-level domains include <code>.biz</code>, <code>.coop</code>, and <code>.info</code>. There are now
over 1200 top-level domains.</p>
<h3 id="name-servers">Name Servers</h3>
<p>The complete domain name hierarchy exists only in the abstract. We now
turn our attention to the question of how this hierarchy is actually
implemented. The first step is to partition the hierarchy into subtrees
called <em>zones</em>. <a href="#zones">Figure 3</a> shows how the hierarchy given in
<a href="#domains">Figure 2</a> might be divided into zones. Each zone can be
thought of as corresponding to some administrative authority that is
responsible for that portion of the hierarchy. For example, the top
level of the hierarchy forms a zone that is managed by the Internet
Corporation for Assigned Names and Numbers (ICANN). Below this is a zone
that corresponds to Princeton University. Within this zone, some
departments do not want the responsibility of managing the hierarchy
(and so they remain in the university-level zone), while others, like
the Department of Computer Science, manage their own department-level
zone.</p>
<figure class="line">
    <a id="zones"></a>
    <img src="figures/f09-16-9780123850591.png" width="700px">
    <figcaption>Domain hierarchy partitioned into zones.</figcaption>
</figure>

<p>The relevance of a zone is that it corresponds to the fundamental unit
of implementation in DNS&#x2014;the name server. Specifically, the
information contained in each zone is implemented in two or more name
servers. Each name server, in turn, is a program that can be accessed
over the Internet. Clients send queries to name servers, and name
servers respond with the requested information. Sometimes the response
contains the final answer that the client wants, and sometimes the
response contains a pointer to another server that the client should
query next. Thus, from an implementation perspective, it is more
accurate to think of DNS as being represented by a hierarchy of name
servers rather than by a hierarchy of domains, as illustrated in
<a href="#servers">Figure 4</a>.</p>
<figure class="line">
    <a id="servers"></a>
    <img src="figures/f09-17-9780123850591.png" width="500px">
    <figcaption>Hierarchy of name servers.</figcaption>
</figure>

<p>Note that each zone is implemented in two or more name servers for the
sake of redundancy; that is, the information is still available even if
one name server fails. On the flip side, a given name server is free to
implement more than one zone.</p>
<p>Each name server implements the zone information as a collection of
<em>resource records</em>. In essence, a resource record is a name-to-value
binding or, more specifically, a 5-tuple that contains the following
fields:</p>
<pre><code class="lang-pseudo">(Name, Value, Type, Class, TTL)
</code></pre>
<p>The <code>Name</code> and <code>Value</code> fields are exactly what you would expect,
while the <code>Type</code> field specifies how the <code>Value</code> should be
interpreted. For example, indicates that the <code>Value</code> is an IP address.
Thus, <code>A</code> records implement the name-to-address mapping we have been
assuming. Other record types include:</p>
<ul>
<li><p><code>NS</code>&#x2014;The <code>Value</code> field gives the domain name for a host that
  is running a name server that knows how to resolve names within the
  specified domain.</p>
</li>
<li><p><code>CNAME</code>&#x2014;The <code>Value</code> field gives the canonical name for a
  particular host; it is used to define aliases.</p>
</li>
<li><p><code>MX</code>&#x2014;The <code>Value</code> field gives the domain name for a host that
  is running a mail server that accepts messages for the specified
  domain.</p>
</li>
</ul>
<p>The <code>Class</code> field was included to allow entities other than the NIC to
define useful record types. To date, the only widely used <code>Class</code> is
the one used by the Internet; it is denoted <code>IN</code>. Finally, the
time-to-live (<code>TTL</code>) field shows how long this resource record is
valid. It is used by servers that cache resource records from other
servers; when the <code>TTL</code> expires, the server must evict the record from
its cache.</p>
<p>To better understand how resource records represent the information in
the domain hierarchy, consider the following examples drawn from the
domain hierarchy given in <a href="#domains">Figure 2</a>. To simplify the
example, we ignore the <code>TTL</code> field and we give the relevant
information for only one of the name servers that implement each zone.</p>
<p>First, a root name server contains an <code>NS</code> record for each top-level
domain (TLD) name server. This identifies a server that can resolve
queries for this part of the DNS hierarchy (<code>.edu</code> and <code>.com</code>in this
example). It also has <code>A</code> records that translates these names into the
corresponding IP addresses. Taken together, these two records
effectively implement a pointer from the root name server to one of the
TLD servers.</p>
<pre><code class="lang-pseudo">(edu, a3.nstld.com, NS, IN)
(a3.nstld.com, 192.5.6.32, A, IN)
(com, a.gtld-servers.net, NS, IN)
(a.gtld-servers.net, 192.5.6.30, A, IN)
...
</code></pre>
<p>Moving our way down the hierarchy by one level, the server has records
for domains like this:</p>
<pre><code class="lang-pseudo">(princeton.edu, dns.princeton.edu, NS, IN)
(dns.princeton.edu, 128.112.129.15, A, IN)
...
</code></pre>
<p>In this case, we get an <code>NS</code> record and an <code>A</code> record for the name
server that is responsible for the <code>princeton.edu</code> part of the
hierarchy. That server might be able to directly resolve some queries
(e.g., for<code>email.princeton.edu</code>) while it would redirect others to a
server at yet another layer in the hierarchy (e.g., for a query about
<code>penguins.cs.princeton.edu</code>).</p>
<pre><code class="lang-pseudo">(email.princeton.edu, 128.112.198.35, A, IN)
(penguins.cs.princeton.edu, dns1.cs.princeton.edu, NS, IN)
(dns1.cs.princeton.edu, 128.112.136.10, A, IN)
...
</code></pre>
<p>Finally, a third-level name server, such as the one managed by domain
<code>cs.princeton.edu</code>, contains <code>A</code> records for all of its hosts. It
might also define a set of aliases (<code>CNAME</code> records) for each of those
hosts. Aliases are sometimes just convenient (e.g., shorter) names for
machines, but they can also be used to provide a level of
indirection. For example,<code>www.cs.princeton.edu</code> is an alias for the
host named <code>coreweb.cs.princeton.edu</code>.This allows the site&apos;s web
server to move to another machine without affecting remote users; they
simply continue to use the alias without regard for what machine
currently runs the domain&apos;s web server. The mail exchange (<code>MX</code>)
records serve the same purpose for the email application&#x2014;they allow an
administrator to change which host receives mail on behalf of the
domain without having to change everyone&apos;s email address.</p>
<pre><code class="lang-pseudo">(penguins.cs.princeton.edu, 128.112.155.166, A, IN)
(www.cs.princeton.edu, coreweb.cs.princeton.edu, CNAME, IN)
coreweb.cs.princeton.edu, 128.112.136.35, A, IN)
(cs.princeton.edu, mail.cs.princeton.edu, MX, IN)
(mail.cs.princeton.edu, 128.112.136.72, A, IN)
...
</code></pre>
<p>Note that, although resource records can be defined for virtually any
type of object, DNS is typically used to name hosts (including servers)
and sites. It is not used to name individual people or other objects
like files or directories; other naming systems are typically used to
identify such objects. For example, X.500 is an ISO naming system
designed to make it easier to identify people. It allows you to name a
person by giving a set of attributes: name, title, phone number, postal
address, and so on. X.500 proved too cumbersome&#x2014;and, in some sense,
was usurped by powerful search engines now available on the Web&#x2014;but it
did eventually evolve into the Lightweight Directory Access Protocol
(LDAP). LDAP is a subset of X.500 originally designed as a PC front end
to X.500. Today, widely used, mostly at the enterprise level, as a
system for learning information about users.</p>
<h3 id="name-resolution">Name Resolution</h3>
<p>Given a hierarchy of name servers, we now consider the issue of how a
client engages these servers to resolve a domain name. To illustrate the
basic idea, suppose the client wants to resolve the name
<code>penguins.cs.princeton.edu</code> relative to the
set of servers given in the previous subsection. The client could first
send a query containing this name to one of the root servers (as we&apos;ll
see below, this rarely happens in practice but will suffice to
illustrate the basic operation for now). The root server, unable to
match the entire name, returns the best match it has&#x2014;the <code>NS</code> record
for <code>edu</code> which points to the TLD server <code>a3.nstld.com</code>. The server
also returns all records that are related to this record, in this
case, the <code>A</code> record for <code>a3.nstld.com</code>. The client, having not
received the answer it was after, next sends the same query to the
name server at IP host <code>192.5.6.32</code>. This server also cannot match the
whole name and so returns the <code>NS</code> and corresponding <code>A</code> records for
the <code>princeton.edu</code> domain. Once again, the client sends the same
query as before to the server at IP host <code>128.112.129.15</code>, and this
time gets back the <code>NS</code> record and corresponding <code>A</code> record for the
<code>cs.princeton.edu</code> domain. This time, the server that can fully
resolve the query has been reached. A final query to the server at
<code>128.112.136.10</code> yields the <code>A</code> record for
<code>penguins.cs.princeton.edu</code>, and the client learns that the
corresponding IP address is <code>128.112.155.166</code>.</p>
<p>This example still leaves a couple of questions about the resolution
process unanswered. The first question is how did the client locate the
root server in the first place, or, put another way, how do you resolve
the name of the server that knows how to resolve names? This is a
fundamental problem in any naming system, and the answer is that the
system has to be bootstrapped in some way. In this case, the
name-to-address mapping for one or more root servers is well known; that
is, it is published through some means outside the naming system itself.</p>
<p>In practice, however, not all clients know about the root servers.
Instead, the client program running on each Internet host is initialized
with the address of a <em>local</em> name server. For example, all the hosts in
the Department of Computer Science at Princeton know about the server
on <code>dns1.cs.princeton.edu</code>. This local name server, in turn, has
resource records for one or more of the root servers, for example:</p>
<pre><code class="lang-pseudo">(&apos;root&apos;, a.root-servers.net, NS, IN)
(a.root-servers.net, 198.41.0.4, A, IN)
</code></pre>
<p>Thus, resolving a name actually involves a client querying the local
server, which in turn acts as a client that queries the remote servers
on the original client&apos;s behalf. This results in the client/server
interactions illustrated in <a href="#resolution">Figure 5</a>. One advantage of
this model is that all the hosts in the Internet do not have to be kept
up-to-date on where the current root servers are located; only the
servers have to know about the root. A second advantage is that the
local server gets to see the answers that come back from queries that
are posted by all the local clients. The local server <em>caches</em> these
responses and is sometimes able to resolve future queries without having
to go out over the network. The <code>TTL</code> field in the resource records
returned by remote servers indicates how long each record can be safely
cached. This caching mechanism can be used further up the hierarchy as
well, reducing the load on the root and TLD servers.</p>
<p>The second question is how the system works when a user submits a
partial name (e.g., <code>penguins</code>) rather than a complete domain name
(e.g., <code>penguins.cs.princeton.edu</code>). The answer is that the client
program is configured with the local domain in which the host resides
(e.g., <code>cs.princeton.edu</code>), and it appends this string to any simple
names before sending out a query.</p>
<figure class="line">
    <a id="resolution"></a>
    <img src="figures/f09-18-9780123850591.png" width="600px">
    <figcaption>Name resolution in practice, where the numbers 1 to 10
    show the sequence of steps in the process.</figcaption>
</figure>

<p>Just to make sure we are clear, we have now seen three different levels
of identifiers&#x2014;domain names, IP addresses, and physical network
addresses&#x2014;and the mapping of identifiers at one level into identifiers
at another level happens at different points in the network
architecture. First, users specify domain names when interacting with
the application. Second, the application engages DNS to translate this
name into an IP address; it is the IP address that is placed in each
datagram, not the domain name. (As an aside, this translation process
involves IP datagrams being sent over the Internet, but these datagrams
are addressed to a host that runs a name server, not to the ultimate
destination.) Third, IP does forwarding at each router, which often
means that it maps one IP address into another; that is, it maps the
ultimate destination&apos;s address into the address for the next hop router.
Finally, IP engages the Address Resolution Protocol (ARP) to translate
the next hop IP address into the physical address for that machine; the
next hop might be the ultimate destination or it might be an
intermediate router. Frames sent over the physical network have these
physical addresses in their headers.</p>
<h2 id="network-management-snmp">Network Management (SNMP)</h2>
<p>A network is a complex system, both in terms of the number of nodes that
are involved and in terms of the suite of protocols that can be running
on any one node. Even if you restrict yourself to worrying about the
nodes within a single administrative domain, such as a campus, there
might be dozens of routers and hundreds&#x2014;or even thousands&#x2014;of hosts
to keep track of. If you think about all the state that is maintained
and manipulated on any one of those nodes&#x2014;address translation tables,
routing tables, TCP connection state, and so on&#x2014;then it is easy to
become depressed about the prospect of having to manage all of this
information.</p>
<p>It is easy to imagine wanting to know about the state of various
protocols on different nodes. For example, you might want to monitor the
number of IP datagram reassemblies that have been aborted, so as to
determine if the timeout that garbage collects partially assembled
datagrams needs to be adjusted. As another example, you might want to
keep track of the load on various nodes (i.e., the number of packets
sent or received) so as to determine if new routers or links need to be
added to the network. Of course, you also have to be on the watch for
evidence of faulty hardware and misbehaving software.</p>
<p>What we have just described is the problem of network management, an
issue that pervades the entire network architecture. Since the nodes we
want to keep track of are distributed, our only real option is to use
the network to manage the network. This means we need a protocol that
allows us to read, and possibly write, various pieces of state
information on different network nodes. A widely used protocol
for this purpose is the Simple Network Management Protocol (SNMP).</p>
<blockquote>
<p>While it is true that SNMP is widely used, and was historically
&quot;the&quot; management protocol for switches and
routers, system admins also have to administer servers, client
desktop machines, and laptops. And to complicate matters even
more, virtualization technology has led to the proliferation of
virtual machines (VM), which now outnumber physical machines; admins
have to administer these VMs too. New management tools are being
invented every day to help address this challenge, but they typically
leverage standard protocols like HTTP to retrieve monitoring data.
This is a positive development in that it takes us out of the
business of creating new protocols and puts us in the business of
creating smarter and smarter management tools, many of which now
starting to take advantage of Artificial Intelligence to determine
if something is amiss. Today, SNMP is one of many sources of data
being used by network automation and orchestration tools.</p>
</blockquote>
<p>SNMP is essentially a specialized request/reply protocol that supports
two kinds of request messages: <code>GET</code> and <code>SET</code>. The former is used
to retrieve a piece of state from some node, and the latter is used to
store a new piece of state in some node. (SNMP also supports a third
operation, , which we explain below.) The following discussion focuses
on the <code>GET</code> operation, since it is the one most frequently used.</p>
<p>SNMP is used in the obvious way. A system administrator interacts with a
client program that displays information about the network. This client
program usually has a graphical interface. You can think of this
interface as playing the same role as a web browser. Whenever the
administrator selects a certain piece of information that he or she
wants to see, the client program uses SNMP to request that information
from the node in question. (SNMP runs on top of UDP.) An SNMP server
running on that node receives the request, locates the appropriate piece
of information, and returns it to the client program, which then
displays it to the user.</p>
<p>There is only one complication to this otherwise simple scenario:
Exactly how does the client indicate which piece of information it wants
to retrieve, and, likewise, how does the server know which variable in
memory to read to satisfy the request? The answer is that SNMP depends
on a companion specification called the <em>management information base</em>
(MIB). The MIB defines the specific pieces of information&#x2014;the MIB
<em>variables</em>&#x2014;that you can retrieve from a network node.</p>
<p>The current version of MIB, called MIB-II, organizes variables into 10
different <em>groups</em>. You will recognize that most of the groups
correspond to one of the protocols described in this book, and nearly
all of the variables defined for each group should look familiar. For
example:</p>
<ul>
<li><p>System&#x2014;General parameters of the system (node) as a whole,
 including where the node is located, how long it has been up, and
 the system&apos;s name</p>
</li>
<li><p>Interfaces&#x2014;Information about all the network interfaces (adaptors)
 attached to this node, such as the physical address of each
 interface and how many packets have been sent and received on each
 interface</p>
</li>
<li><p>Address translation&#x2014;Information about the Address Resolution
 Protocol, and in particular, the contents of its address translation
 table</p>
</li>
<li><p>IP&#x2014;Variables related to IP, including its routing table, how many
 datagrams it has successfully forwarded, and statistics about
 datagram reassembly; includes counts of how many times IP drops a
 datagram for one reason or another</p>
</li>
<li><p>TCP&#x2014;Information about TCP connections, such as the number of
 passive and active opens, the number of resets, the number of
 timeouts, default timeout settings, and so on; per-connection
 information persists only as long as the connection exists</p>
</li>
<li><p>UDP&#x2014;Information about UDP traffic, including the total number of
 UDP datagrams that have been sent and received.</p>
</li>
</ul>
<p>There are also groups for Internet Control Message Protocol (ICMP),
Exterior Gateway Protocol (EGP), and SNMP itself. The tenth group is
used by different media.</p>
<p>Returning to the issue of the client stating exactly what information it
wants to retrieve from a node, having a list of MIB variables is only
half the battle. Two problems remain. First, we need a precise syntax
for the client to use to state which of the MIB variables it wants to
fetch. Second, we need a precise representation for the values returned
by the server. Both problems are addressed using Abstract Syntax
Notation One (ASN.1).</p>
<p>Consider the second problem first. As we already saw in in a previous
chapter, ASN.1/Basic Encoding Rules (BER) defines a representation for
different data types, such as integers. The MIB defines the type of each
variable, and then it uses ASN.1/BER to encode the value contained in
this variable as it is transmitted over the network. As far as the first
problem is concerned, ASN.1 also defines an object identification
scheme. The MIB uses this identification system to assign a globally
unique identifier to each MIB variable. These identifiers are given in a
&quot;dot&quot; notation, not unlike domain names. For example, 1.3.6.1.2.1.4.3 is
the unique ASN.1 identifier for the IP-related MIB variable
<code>ipInReceives</code>; this variable counts the number of IP datagrams that
have been received by this node. In this example, the 1.3.6.1.2.1 prefix
identifies the MIB database (remember, ASN.1 object IDs are for all
possible objects in the world), the 4 corresponds to the IP group, and
the final 3 denotes the third variable in this group.</p>
<p>Thus, network management works as follows. The SNMP client puts the
ASN.1 identifier for the MIB variable it wants to get into the request
message, and it sends this message to the server. The server then maps
this identifier into a local variable (i.e., into a memory location
where the value for this variable is stored), retrieves the current
value held in this variable, and uses ASN.1/BER to encode the value it
sends back to the client.</p>
<p>There is one final detail. Many of the MIB variables are either tables
or structures. Such compound variables explain the reason for the SNMP
operation. This operation, when applied to a particular variable ID,
returns the value of that variable plus the ID of the next variable, for
example, the next item in the table or the next field in the structure.
This aids the client in &quot;walking through&quot; the elements of a table or
structure.</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="multimedia.html" class="navigation navigation-prev " aria-label="Previous page: 9.2 Multimedia Applications">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="overlays.html" class="navigation navigation-next " aria-label="Next page: 9.4 Overlay Networks">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"9.3 Infrastructure Applications","level":"1.10.3","depth":2,"next":{"title":"9.4 Overlay Networks","level":"1.10.4","depth":2,"path":"applications/overlays.md","ref":"applications/overlays.md","articles":[]},"previous":{"title":"9.2 Multimedia Applications","level":"1.10.2","depth":2,"path":"applications/multimedia.md","ref":"applications/multimedia.md","articles":[]},"dir":"ltr"},"config":{"plugins":["anchorjs","katex","block-align","sequence-diagrams","creativecommons","custom-favicon","smart-nav-collapse"],"root":".","styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css"},"pluginsConfig":{"block-align":{},"search":{},"sequence-diagrams":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"katex":{},"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"favicon":"bridge.ico","custom-favicon":{},"creativecommons":{},"smart-nav-collapse":{},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false},"anchorjs":{}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{"branch":"master"},"title":"Computer Networks: A Systems Approach","gitbook":"*"},"file":{"path":"applications/infrastructure.md","mtime":"2018-10-04T22:41:34.000Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2018-10-04T22:46:12.462Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.1.1/anchor.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-anchorjs/anchor-style.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-smart-nav-collapse/smart-nav-collapse.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

