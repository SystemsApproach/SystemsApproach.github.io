
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>9.1 Traditional Applications Â· Computer Networks: A Systems Approach</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-katex/katex.min.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-block-align/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-smart-nav-collapse/smart-nav-collapse.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
        <link rel="stylesheet" href="../styles/website.css">
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="multimedia.html" />
    
    
    <link rel="prev" href="problem.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Preface
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../foundation/problem.html">
            
                <a href="../foundation/problem.html">
            
                    
                    Chapter 1: Foundation
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="../foundation/applications.html">
            
                <a href="../foundation/applications.html">
            
                    
                    1.1 Applications
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="../foundation/requirements.html">
            
                <a href="../foundation/requirements.html">
            
                    
                    1.2 Requirements
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="../foundation/architecture.html">
            
                <a href="../foundation/architecture.html">
            
                    
                    1.3 Architecture
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.4" data-path="../foundation/software.html">
            
                <a href="../foundation/software.html">
            
                    
                    1.4 Software
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.5" data-path="../foundation/performance.html">
            
                <a href="../foundation/performance.html">
            
                    
                    1.5 Performance
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.6" data-path="../foundation/summary.html">
            
                <a href="../foundation/summary.html">
            
                    
                    1.6 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../direct/problem.html">
            
                <a href="../direct/problem.html">
            
                    
                    Chapter 2: Direct Connections
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="../direct/perspective.html">
            
                <a href="../direct/perspective.html">
            
                    
                    2.1 Perspective on Connecting
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="../direct/encoding.html">
            
                <a href="../direct/encoding.html">
            
                    
                    2.2 Encoding
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3" data-path="../direct/framing.html">
            
                <a href="../direct/framing.html">
            
                    
                    2.3 Framing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4" data-path="../direct/error.html">
            
                <a href="../direct/error.html">
            
                    
                    2.4 Error Detection
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.5" data-path="../direct/reliable.html">
            
                <a href="../direct/reliable.html">
            
                    
                    2.5 Reliable Transmission
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.6" data-path="../direct/ethernet.html">
            
                <a href="../direct/ethernet.html">
            
                    
                    2.6 Multi-Access Networks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.7" data-path="../direct/wireless.html">
            
                <a href="../direct/wireless.html">
            
                    
                    2.7 Wireless Networks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.8" data-path="../direct/summary.html">
            
                <a href="../direct/summary.html">
            
                    
                    2.8 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="../internetworking/problem.html">
            
                <a href="../internetworking/problem.html">
            
                    
                    Chapter 3: Internetworking
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="../internetworking/switching.html">
            
                <a href="../internetworking/switching.html">
            
                    
                    3.1 Switching and Bridging
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="../internetworking/basic-ip.html">
            
                <a href="../internetworking/basic-ip.html">
            
                    
                    3.2 Basic Internetworking
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3" data-path="../internetworking/routing.html">
            
                <a href="../internetworking/routing.html">
            
                    
                    3.3 Routing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4" data-path="../internetworking/impl.html">
            
                <a href="../internetworking/impl.html">
            
                    
                    3.4 Implementation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.5" data-path="../internetworking/summary.html">
            
                <a href="../internetworking/summary.html">
            
                    
                    3.5 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="../scaling/problem.html">
            
                <a href="../scaling/problem.html">
            
                    
                    Chapter 4: Advanced Internetworking
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.1" data-path="../scaling/global.html">
            
                <a href="../scaling/global.html">
            
                    
                    4.1 Global Internet
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.2" data-path="../scaling/multicast.html">
            
                <a href="../scaling/multicast.html">
            
                    
                    4.2 Multicast
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.3" data-path="../scaling/mpls.html">
            
                <a href="../scaling/mpls.html">
            
                    
                    4.3 Multiprotocol Label Switching
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.4" data-path="../scaling/mobile-ip.html">
            
                <a href="../scaling/mobile-ip.html">
            
                    
                    4.4 Routing Among Mobile Devices
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.5" data-path="../scaling/summary.html">
            
                <a href="../scaling/summary.html">
            
                    
                    4.5 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="../e2e/problem.html">
            
                <a href="../e2e/problem.html">
            
                    
                    Chapter 5: End-to-End Protocols
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.6.1" data-path="../e2e/udp.html">
            
                <a href="../e2e/udp.html">
            
                    
                    5.1 Simple Demultiplexor (UDP)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2" data-path="../e2e/tcp.html">
            
                <a href="../e2e/tcp.html">
            
                    
                    5.2 Reliable Byte Stream (TCP)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.3" data-path="../e2e/rpc.html">
            
                <a href="../e2e/rpc.html">
            
                    
                    5.3 Remote Procedure Call
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.4" data-path="../e2e/rtp.html">
            
                <a href="../e2e/rtp.html">
            
                    
                    5.4 Transport for Real-Time Applications (RTP)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.5" data-path="../e2e/summary.html">
            
                <a href="../e2e/summary.html">
            
                    
                    5.5 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="../congestion/problem.html">
            
                <a href="../congestion/problem.html">
            
                    
                    Chapter 6: Congestion Control and Resource Allocation
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.1" data-path="../congestion/issues.html">
            
                <a href="../congestion/issues.html">
            
                    
                    6.1 Issues in Resource Allocation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.2" data-path="../congestion/queuing.html">
            
                <a href="../congestion/queuing.html">
            
                    
                    6.2 Queuing Disciplines
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.3" data-path="../congestion/tcpcc.html">
            
                <a href="../congestion/tcpcc.html">
            
                    
                    6.3 TCP Congestion Control
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4" data-path="../congestion/avoidance.html">
            
                <a href="../congestion/avoidance.html">
            
                    
                    6.4 Congestion-Avoidance Mechanisms
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.5" data-path="../congestion/qos.html">
            
                <a href="../congestion/qos.html">
            
                    
                    6.5 Quality of Service
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.6" data-path="../congestion/summary.html">
            
                <a href="../congestion/summary.html">
            
                    
                    6.6 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="../data/problem.html">
            
                <a href="../data/problem.html">
            
                    
                    Chapter 7: End-to-End Data
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.8.1" data-path="../data/presentation.html">
            
                <a href="../data/presentation.html">
            
                    
                    7.1 Presentation Formatting
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.2" data-path="../data/multimedia.html">
            
                <a href="../data/multimedia.html">
            
                    
                    7.2 Multimedia Data
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.3" data-path="../data/summary.html">
            
                <a href="../data/summary.html">
            
                    
                    7.3 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="../security/problem.html">
            
                <a href="../security/problem.html">
            
                    
                    Chapter 8: Network Security
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.9.1" data-path="../security/crypto.html">
            
                <a href="../security/crypto.html">
            
                    
                    8.1 Cryptographic Building Blocks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2" data-path="../security/key-distro.html">
            
                <a href="../security/key-distro.html">
            
                    
                    8.2 Key Predistribution
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.3" data-path="../security/authentication.html">
            
                <a href="../security/authentication.html">
            
                    
                    8.3 Authentication Protocols
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.4" data-path="../security/systems.html">
            
                <a href="../security/systems.html">
            
                    
                    8.4 Example Systems
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.5" data-path="../security/summary.html">
            
                <a href="../security/summary.html">
            
                    
                    8.5 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="problem.html">
            
                <a href="problem.html">
            
                    
                    Chapter 9: Applications
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter active" data-level="1.10.1" data-path="traditional.html">
            
                <a href="traditional.html">
            
                    
                    9.1 Traditional Applications
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.2" data-path="multimedia.html">
            
                <a href="multimedia.html">
            
                    
                    9.2 Multimedia Applications
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.3" data-path="infrastructure.html">
            
                <a href="infrastructure.html">
            
                    
                    9.3 Infrastructure Applications
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.4" data-path="overlays.html">
            
                <a href="overlays.html">
            
                    
                    9.4 Overlay Networks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.5" data-path="summary.html">
            
                <a href="summary.html">
            
                    
                    9.5 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >9.1 Traditional Applications</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="91-traditional-applications">9.1 Traditional Applications</h1>
<p>We begin our discussion of applications by focusing on two of the most
popular&#x2014;the World Wide Web and email. Broadly speaking, both of these
applications use the request/reply paradigm&#x2014;users send requests to
servers, which then respond accordingly. We refer to these as
&quot;traditional&quot; applications because they typify the sort of applications
that have existed since the early days of computer networks (although
the Web is a lot newer than email but has its roots in file transfers
that predated it). By contrast, later sections will look at a class of
applications that have become feasible only relatively recently:
streaming applications (e.g., multimedia applications like video and
audio) and various overlay-based applications. (Note that there is a bit
of a blurring between these classes, as you can of course get access to
streaming multimedia data over the Web, but for now we&apos;ll focus on the
general usage of the Web to request pages, images, etc.)</p>
<p>Before taking a close look at each of these applications, there are
three general points that we need to make. The first is that it is
important to distinguish between application <em>programs</em> and application
<em>protocols</em>. For example, the HyperText Transport Protocol (HTTP) is an
application protocol that is used to retrieve Web pages from remote
servers. Many different application programs&#x2014;that is, web clients like
Internet Explorer, Chrome, Firefox, and Safari&#x2014;provide users with a
different look and feel, but all of them use the same HTTP protocol to
communicate with web servers over the Internet. Indeed, it is the fact
that the protocol is published and standardized that enables application
programs developed by many different companies and individuals to
interoperate. That is how so many browsers are able to interoperate with
all the web servers (of which there are also many varieties).</p>
<p>This section looks at two very widely used, standardized application
protocols:</p>
<ul>
<li><p>Simple Mail Transfer Protocol (SMTP) is used to exchange electronic
 mail.</p>
</li>
<li><p>HyperText Transport Protocol (HTTP) is used to communicate between
 web browsers and web servers.</p>
</li>
</ul>
<p>We&apos;ll also look at how custom application protocols are defined in the
<em>Web Services</em> architecture.</p>
<p>The second point is that, since the application protocols described in
this section follow the same request/reply communication pattern, you
might expect that they would be built on top of a Remote Procedure Call
(RPC) transport protocol. This is not the case, however, as they are
instead implemented on top of TCP. In effect, each protocol reinvents a
simple RPC-like mechanism on top of a reliable transport protocol (TCP).
We say &quot;simple&quot; because each protocol is not designed to support
arbitrary remote procedure calls of the sort discussed in an earlier
chapter, but is instead designed to send and respond to a specific set
of request messages.</p>
<p>Finally, we observe that many application layer protocols, including
HTTP and SMTP, have a companion protocol that specifies the format of
the data that can be exchanged. This is one reason WHY these protocols
are relatively simple: Much of the complexity is managed in this
companion document. For example, SMTP is a protocol for exchanging
electronic mail messages, but RFC 822 and Multipurpose Internet Mail
Extensions (MIME) define the format of email messages. Similarly, HTTP
is a protocol for fetching Web pages, but HyperText Markup Language
(HTML) is a companion specification that defines the basic form of those
pages.</p>
<h2 id="electronic-mail-smtp-mime-imap">Electronic Mail (SMTP, MIME, IMAP)</h2>
<p>Email is one of the oldest network applications. After all, what could
be more natural than wanting to send a message to the user at the other
end of a cross-country link you just managed to get running?
Surprisingly, the pioneers of the ARPANET had not really envisioned
email as a key application when the network was created&#x2014;remote access
to computing resources was the main design goal&#x2014;but it turned out to
be a useful application that continues to be extremely popular.</p>
<p>As noted above, it is important (1) to distinguish the user interface
(i.e., your mail reader) from the underlying message transfer protocols
(such as SMTP or IMAP), and (2) to distinguish between this transfer
protocol and a companion protocol (RFC 822 and MIME) that defines the
format of the messages being exchanged. We start by looking at the
message format.</p>
<h3 id="message-format">Message Format</h3>
<p>RFC 822 defines messages to have two parts: a <em>header</em> and a <em>body</em>.
Both parts are represented in ASCII text. Originally, the body was
assumed to be simple text. This is still the case, although RFC 822 has
been augmented by MIME to allow the message body to carry all sorts of
data. This data is still represented as ASCII text, but because it may
be an encoded version of, say, a JPEG image, it&apos;s not necessarily
readable by human users. More on MIME in a moment.</p>
<p>The message header is a series of <crlf>-terminated lines. (<crlf>
stands for carriage-return plus line-feed, which are a pair of ASCII
control characters often used to indicate the end of a line of text.)
The header is separated from the message body by a blank line. Each
header line contains a type and value separated by a colon. Many of
these header lines are familiar to users, since they are asked to fill
them out when they compose an email message; for example, the header
identifies the message recipient, and the header says something about
the purpose of the message. Other headers are filled in by the
underlying mail delivery system. Examples include (when the message
was transmitted), (what user sent the message), and (each mail server
that handled this message). There are, of course, many other header
lines; the interested reader is referred to RFC 822.</crlf></crlf></p>
<p>RFC 822 was extended in 1993 (and updated quite a few times since then)
to allow email messages to carry many different types of data: audio,
video, images, PDF documents, and so on. MIME consists of three basic
pieces. The first piece is a collection of header lines that augment the
original set defined by RFC 822. These header lines describe, in various
ways, the data being carried in the message body. They include (the
version of MIME being used), (a human-readable description of what&apos;s in
the message, analogous to the line), (the type of data contained in the
message), and (how the data in the message body is encoded).</p>
<p>The second piece is definitions for a set of content types (and
subtypes). For example, MIME defines two different still image types,
denoted and , each with the obvious meaning. As another example, refers
to simple text you might find in a vanilla 822-style message, while
denotes a message that contains &quot;marked up&quot; text (text using special
fonts, italics, etc.). As a third example, MIME defines an
<code>application</code> type, where the subtypes correspond to the output of
different application programs (e.g., <code>application/postscript</code> and
<code>application/msword</code>).</p>
<p>MIME also defines a <code>multipart</code> type that says how a message carrying
more than one data type is structured. This is like a programming
language that defines both base types (e.g., integers and floats) and
compound types (e.g., structures and arrays). One possible <code>multipart</code>
subtype is <code>mixed</code>, which says that the message contains a set of
independent data pieces in a specified order. Each piece then has its
own header line that describes the type of that piece.</p>
<p>The third piece is a way to encode the various data types so they can be
shipped in an ASCII email message. The problem is that, for some data
types (a JPEG image, for example), any given 8-bit byte in the image
might contain one of 256 different values. Only a subset of these values
are valid ASCII characters. It is important that email messages contain
only ASCII, because they might pass through a number of intermediate
systems (gateways, as described below) that assume all email is ASCII
and would corrupt the message if it contained non-ASCII characters. To
address this issue, MIME uses a straightforward encoding of binary data
into the ASCII character set. The encoding is called <code>base64</code>. The
idea is to map every three bytes of the original binary data into four
ASCII characters. This is done by grouping the binary data into 24-bit
units and breaking each such unit into four 6-bit pieces. Each 6-bit
piece maps onto one of 64 valid ASCII characters; for example, 0 maps
onto A, 1 maps onto B, and so on. If you look at a message that has
been encoded using the base64 encoding scheme, you&apos;ll notice only the 52
upper- and lowercase letters, the 10 digits 0 through 9, and the special
characters + and /. These are the first 64 values in the ASCII
character set.</p>
<p>As one aside, so as to make reading mail as painless as possible for
those who still insist on using text-only mail readers, a MIME message
that consists of regular text only can be encoded using 7-bit ASCII.
There&apos;s also a readable encoding for mostly ASCII data.</p>
<p>Putting this all together, a message that contains some plain text, a
JPEG image, and a PostScript file would look something like this:</p>
<pre><code class="lang-pseudo">MIME-Version: 1.0
Content-Type: multipart/mixed;
boundary=&quot;-------417CA6E2DE4ABCAFBC5&quot;
From: Alice Smith &lt;Alice@cisco.com&gt;
To: Bob@cs.Princeton.edu
Subject: promised material
Date: Mon, 07 Sep 1998 19:45:19 -0400

---------417CA6E2DE4ABCAFBC5
Content-Type: text/plain; charset=us-ascii
Content-Transfer-Encoding: 7bit

Bob,

Here&apos;s the jpeg image and draft report I promised.

--Alice

---------417CA6E2DE4ABCAFBC5
Content-Type: image/jpeg
Content-Transfer-Encoding: base64
... unreadable encoding of a jpeg figure
---------417CA6E2DE4ABCAFBC5
Content-Type: application/postscript; name=&quot;draft.ps&quot;
Content-Transfer-Encoding: 7bit
... readable encoding of a PostScript document
</code></pre>
<p>In this example, the line in the message header says that this message
contains various pieces, each denoted by a character string that does
not appear in the data itself. Each piece then has its own and lines.</p>
<h3 id="message-transfer">Message Transfer</h3>
<p>For many years, the majority of email was moved from host to host using
only SMTP. While SMTP continues to play a central role, it is now just
one email protocol of several, Internet Message Access Protocol (IMAP)
and Post Office Protocol (POP) being two other important protocols for
retrieving mail messages. We&apos;ll begin our discussion by looking at SMTP,
and move on to IMAP below.</p>
<p>To place SMTP in the right context, we need to identify the key players.
First, users interact with a <em>mail reader</em> when they compose, file,
search, and read their email. Countless mail readers are available, just
like there are many web browsers to choose from. In the early days of
the Internet, users typically logged into the machine on which their
<em>mailbox</em> resided, and the mail reader they invoked was a local
application program that extracted messages from the file system. Today,
of course, users remotely access their mailbox from their laptop or
smartphone; they do not first log into the host that stores their mail
(a mail server). A second mail transfer protocol, such as POP or IMAP,
is used to remotely download email from a mail server to the user&apos;s
device.</p>
<p>Second, there is a <em>mail daemon</em> (or process) running on each host that
holds a mailbox. You can think of this process, also called a <em>message
transfer agent</em> (MTA), as playing the role of a post office: Users (or
their mail readers) give the daemon messages they want to send to other
users, the daemon uses SMTP running over TCP to transmit the message to
a daemon running on another machine, and the daemon puts incoming
messages into the user&apos;s mailbox (where that user&apos;s mail reader can
later find them). Since SMTP is a protocol that anyone could implement,
in theory there could be many different implementations of the mail
daemon. It turns out, though, that there are only a few popular
implementations, with the old <code>sendmail</code> program from Berkeley Unix
and <code>postfix</code> being the most widespread.</p>
<figure class="line">
    <a id="mail"></a>
    <img src="figures/f09-01-9780123850591.png" width="600px">
    <figcaption>Sequence of mail gateways store and forward email
    messages.</figcaption>
</figure>

<p>While it is certainly possible that the MTA on a sender&apos;s machine
establishes an SMTP/TCP connection to the MTA on the recipient&apos;s mail
server, in many cases the mail traverses one or more <em>mail gateways</em> on
its route from the sender&apos;s host to the receiver&apos;s host. Like the end
hosts, these gateways also run a message transfer agent process. It&apos;s
not an accident that these intermediate nodes are called <em>gateways</em>
since their job is to store and forward email messages, much like an &quot;IP
gateway&quot; (which we have referred to as a <em>router</em>) stores and forwards
IP datagrams. The only difference is that a mail gateway typically
buffers messages on disk and is willing to try retransmitting them to
the next machine for several days, while an IP router buffers datagrams
in memory and is only willing to retry transmitting them for a fraction
of a second. <a href="#mail">Figure 1</a> illustrates a two-hop path from the
sender to the receiver.</p>
<p>Why, you might ask, are mail gateways necessary? Why can&apos;t the sender&apos;s
host send the message to the receiver&apos;s host? One reason is that the
recipient does not want to include the specific host on which he or she
reads email in his or her address. Another is scale: In large
organizations, it&apos;s often the case that a number of different machines
hold the <em>mailboxes</em> for the organization. For example, mail delivered
to is first sent to a mail gateway in the CS Department at Princeton
(that is, to the host named ), and then forwarded&#x2014;involving a second
connection&#x2014;to the specific machine on which Bob has a mailbox. The
forwarding gateway maintains a database that maps users into the machine
on which their mailbox resides; the sender need not be aware of this
specific name. (The list of header lines in the message will help you
trace the mail gateways that a given message traversed.) Yet another
reason, particularly true in the early days of email, is that the
machine that hosts any given user&apos;s mailbox may not always be up or
reachable, in which case the mail gateway holds the message until it can
be delivered.</p>
<p>Independent of how many mail gateways are in the path, an independent
SMTP connection is used between each host to move the message closer to
the recipient. Each SMTP session involves a dialog between the two mail
daemons, with one acting as the client and the other acting as the
server. Multiple messages might be transferred between the two hosts
during a single session. Since RFC 822 defines messages using ASCII as
the base representation, it should come as no surprise to learn that
SMTP is also ASCII based. This means it is possible for a human at a
keyboard to pretend to be an SMTP client program.</p>
<p>SMTP is best understood by a simple example. The following is an
exchange between sending host and receiving host . In this case, user
Bob at Princeton is trying to send mail to users Alice and Tom at Cisco.
The lines sent by are shown in black and the lines sent by are shown in
teal. Extra blank lines have been added to make the dialog more
readable.</p>
<pre><code class="lang-shell">HELO cs.princeton.edu
250 Hello daemon@mail.cs.princeton.edu [128.12.169.24]

MAIL FROM:&lt;Bob@cs.princeton.edu&gt;
250 OK

RCPT TO:&lt;Alice@cisco.com&gt;
250 OK

RCPT TO:&lt;Tom@cisco.com&gt;
550 No such user here

DATA
354 Start mail input; end with &lt;CRLF&gt;.&lt;CRLF&gt;
Blah blah blah...
...etc. etc. etc.
&lt;CRLF&gt;.&lt;CRLF&gt;
250 OK

QUIT
221 Closing connection
</code></pre>
<p>As you can see, SMTP involves a sequence of exchanges between the client
and the server. In each exchange, the client posts a command (e.g.,
<code>QUIT</code>) and the server responds with a code (e.g., <code>221</code>). The
server also returns a human-readable explanation for the code (e.g., ).
In this particular example, the client first identifies itself to the
server with the <code>HELO</code> command. It gives its domain name as an
argument. The server verifies that this name corresponds to the IP
address being used by the TCP connection; you&apos;ll notice the server
states this IP address back to the client. The client then asks the
server if it is willing to accept mail for two different users; the
server responds by saying &quot;yes&quot; to one and &quot;no&quot; to the other. Then the
client sends the message, which is terminated by a line with a single
period (&quot;.&quot;) on it. Finally, the client terminates the connection.</p>
<p>There are, of course, many other commands and return codes. For example,
the server can respond to a client&apos;s <code>RCPT</code> command with a <code>251</code>
code, which indicates that the user does not have a mailbox on this
host, but that the server promises to forward the message onto another
mail daemon. In other words, the host is functioning as a mail gateway.
As another example, the client can issue a <code>VRFY</code> operation to verify
a user&apos;s email address, but without actually sending a message to the
user.</p>
<p>The only other point of interest is the arguments to the <code>MAIL</code> and
<code>RCPT</code> operations; for example, and , respectively. These look a lot
like 822 header fields, and in some sense they are. What actually
happens is that the mail daemon parses the message to extract the
information it needs to run SMTP. The information it extracts is said to
form an <em>envelope</em> for the message. The SMTP client uses this envelope
to parameterize its exchange with the SMTP server. One historical note:
The reason <code>sendmail</code> became so popular is that no one wanted to
reimplement this message parsing function. While today&apos;s email addresses
look pretty tame (e.g., ), this was not always the case. In the days
before everyone was connected to the Internet, it was not uncommon to
see email addresses of the form .</p>
<h3 id="mail-reader">Mail Reader</h3>
<p>The final step is for the user to actually retrieve his or her messages
from the mailbox, read them, reply to them, and possibly save a copy for
future reference. The user performs all these actions by interacting
with a mail reader. As pointed out earlier, this reader was originally
just a program running on the same machine as the user&apos;s mailbox, in
which case it could simply read and write the file that implements the
mailbox. This was the common case in the pre-laptop era. Today, most
often the user accesses his or her mailbox from a remote machine using
yet another protocol, such as POP or IMAP. It is beyond the scope of
this book to discuss the user interface aspects of the mail reader, but
it is definitely within our scope to talk about the access protocol. We
consider IMAP, in particular.</p>
<p>IMAP is similar to SMTP in many ways. It is a client/server protocol
running over TCP, where the client (running on the user&apos;s desktop
machine) issues commands in the form of -terminated ASCII text lines and
the mail server (running on the machine that maintains the user&apos;s
mailbox) responds in kind. The exchange begins with the client
authenticating him- or herself and identifying the mailbox he or she
wants to access. This can be represented by the simple state transition
diagram shown in <a href="#imap">Figure 2</a>. In this diagram, , and
<code>LOGOUT</code> are example commands that the client can issue, while <code>OK</code>
is one possible server response. Other common commands include and
<code>EXPUNGE</code>, with the obvious meanings. Additional server responses
include <code>NO</code> (client does not have permission to perform that
operation) and <code>BAD</code> (command is ill formed).</p>
<figure class="line">
    <a id="imap"></a>
    <img src="figures/f09-02-9780123850591.png" width="400px">
    <figcaption>IMAP state transition diagram.</figcaption>
</figure>

<p>When the user asks to <code>FETCH</code> a message, the server returns it in MIME
format and the mail reader decodes it. In addition to the message
itself, IMAP also defines a set of message <em>attributes</em> that are
exchanged as part of other commands, independent of transferring the
message itself. Message attributes include information like the size of
the message and, more interestingly, various <em>flags</em> associated with the
message (e.g., and <code>Recent</code>). These flags are used to keep the client
and server synchronized; that is, when the user deletes a message in the
mail reader, the client needs to report this fact to the mail server.
Later, should the user decide to expunge all deleted messages, the
client issues an <code>EXPUNGE</code> command to the server, which knows to
actually remove all earlier deleted messages from the mailbox.</p>
<p>Finally, note that when the user replies to a message, or sends a new
message, the mail reader does not forward the message from the client to
the mail server using IMAP, but it instead uses SMTP. This means that
the user&apos;s mail server is effectively the first mail gateway traversed
along the path from the desktop to the recipient&apos;s mailbox.</p>
<h2 id="world-wide-web-http">World Wide Web (HTTP)</h2>
<p>The World Wide Web has been so successful and has made the Internet
accessible to so many people that sometimes it seems to be synonymous
with the Internet. In fact, the design of the system that became the Web
started around 1989, long after the Internet had become a widely
deployed system. The original goal of the Web was to find a way to
organize and retrieve information, drawing on ideas about
hypertext&#x2014;interlinked documents&#x2014;that had been around since at least
the 1960s. The core idea of hypertext is that one document can link
to another document, and the protocol (HTTP) and document language
(HTML) were designed to meet that goal.</p>
<blockquote>
<p>A short history of the Web provided by the World Wide Web 
consortium traces its roots to a 1945 article describing links 
between microfiche documents. </p>
</blockquote>
<p>One helpful way to think of the Web is as a set of cooperating clients
and servers, all of whom speak the same language: HTTP. Most people are
exposed to the Web through a graphical client program or web browser
like Safari, Chrome, Firefox, or Internet Explorer.
<a href="#netscape">Figure 3</a> shows the Firefox browser in use, displaying a
page of information from Princeton University.</p>
<figure class="line">
    <a id="netscape"></a>
    <img src="figures/f09-03-9780123850591.png" width="500px">
    <figcaption>The Firefox web browser.</figcaption>
</figure>

<p>Clearly, if you want to organize information into a system of linked
documents or objects, you need to be able to retrieve one document to
get started. Hence, any web browser has a function that allows the user
to obtain an object by opening a URL. Uniform Resource Locators (URLs)
are so familiar to most of us by now that it&apos;s easy to forget that they
haven&apos;t been around forever. They provide information that allows
objects on the Web to be located, and they look like the following:</p>
<pre><code class="lang-html">http://www.cs.princeton.edu/index.html
</code></pre>
<p>If you opened that particular URL, your web browser would open a TCP
connection to the web server at a machine called and immediately
retrieve and display the file called . Most files on the Web contain
images and text, and many have other objects such as audio and video
clips, pieces of code, etc. They also frequently include URLs that point
to other files that may be located on other machines, which is the core
of the &quot;hypertext&quot; part of HTTP and HTML. A web browser has some way in
which you can recognize URLs (often by highlighting or underlining some
text) and then you can ask the browser to open them. These embedded URLs
are called <em>hypertext links</em>. When you ask your web browser to open one
of these embedded URLs (e.g., by pointing and clicking on it with a
mouse), it will open a new connection and retrieve and display a new
file. This is called <em>following a link</em>. It thus becomes very easy to
hop from one machine to another around the network, following links to
all sorts of information. Once you have a means to embed a link in a
document and allow a user to follow that link to get another document,
you have the basis of a hypertext system.</p>
<p>When you ask your browser to view a page, your browser (the client)
fetches the page from the server using HTTP running over TCP. Like SMTP,
HTTP is a text-oriented protocol. At its core, HTTP is a
request/response protocol, where every message has the general form</p>
<pre><code class="lang-pseudo">START_LINE &lt;CRLF&gt;
MESSAGE_HEADER &lt;CRLF&gt;
&lt;CRLF&gt;
MESSAGE_BODY &lt;CRLF&gt;
</code></pre>
<p>where, as before, <code>&lt;CRLF&gt;</code> stands for carriage-return+line-feed.
The first line (<code>START_LINE</code>) indicates whether this is a request
message or a response message. In effect, it identifies the &quot;remote
procedure&quot; to be executed (in the case of a request message), or the
<em>status</em> of the request (in the case of a response message). The next
set of lines specifies a collection of options and parameters that
qualify the request or response. There are zero or more of these
<code>MESSAGE_HEADER</code> lines&#x2014;the set is terminated by a blank line&#x2014;each
of which looks like a header line in an email message. HTTP defines many
possible header types, some of which pertain to request messages, some
to response messages, and some to the data carried in the message body.
Instead of giving the full set of possible header types, though, we just
give a handful of representative examples. Finally, after the blank line
comes the contents of the requested message (<code>MESSAGE_BODY</code>); this part
of the message is where a server would place the requested page when
responding to a request, and it is typically empty for request messages.</p>
<p>Why does HTTP run over TCP? The designers didn&apos;t have to do it that way,
but TCP does provide a pretty good match to what HTTP needs,
particularly by providing reliable delivery (who wants a Web page with
missing data?), flow control, and congestion control. However, as we&apos;ll
see below, there are a few issues that can arise from building a
request/response protocol on top of TCP, especially if you ignore the
subtleties of the interactions between the application and transport
layer protocols.</p>
<h3 id="request-messages">Request Messages</h3>
<p>The first line of an HTTP request message specifies three things: the
operation to be performed, the Web page the operation should be
performed on, and the version of HTTP being used. Although HTTP defines
a wide assortment of possible request operations&#x2014;including <em>write</em>
operations that allow a Web page to be posted on a server&#x2014;the two most
common operations are <code>GET</code> (fetch the specified Web page) and
<code>HEAD</code> (fetch status information about the specified Web page). The
former is obviously used when your browser wants to retrieve and display
a Web page. The latter is used to test the validity of a hypertext link
or to see if a particular page has been modified since the browser last
fetched it. The full set of operations is summarized in
<a href="#ops">Table 1</a>. As innocent as it sounds, the <code>POST</code> command enables
much mischief (including spam) on the Internet.</p>
<p><a id="ops"></a></p>
<table>
<thead>
<tr>
<th style="text-align:right">Operation</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">OPTIONS</td>
<td style="text-align:left">Request information about available options</td>
</tr>
<tr>
<td style="text-align:right">GET</td>
<td style="text-align:left">Retrieve document identified in URL</td>
</tr>
<tr>
<td style="text-align:right">HEAD</td>
<td style="text-align:left">Retrieve metainformation about document identified in URL</td>
</tr>
<tr>
<td style="text-align:right">POST</td>
<td style="text-align:left">Give information (e.g., annotation) to server</td>
</tr>
<tr>
<td style="text-align:right">PUT</td>
<td style="text-align:left">Store document under specified URL</td>
</tr>
<tr>
<td style="text-align:right">DELETE</td>
<td style="text-align:left">Delete specified URL</td>
</tr>
<tr>
<td style="text-align:right">TRACE</td>
<td style="text-align:left">Loopback request message</td>
</tr>
<tr>
<td style="text-align:right">CONNECT</td>
<td style="text-align:left">For use by proxies</td>
</tr>
</tbody>
</table>
<div class="ba-center"><p><em>Table 1. HTTP Request Operations.</em></p></div>

<p>For example, the <code>START_LINE</code></p>
<pre><code class="lang-http">GET http://www.cs.princeton.edu/index.html
HTTP/1.1
</code></pre>
<p>says that the client wants the server on host to return the page named .
This particular example uses an <em>absolute</em> URL. It is also possible to
use a <em>relative</em> identifier and specify the host name in one of the
<code>MESSAGE_HEADER</code> lines; for example,</p>
<pre><code class="lang-http"><span class="hljs-keyword">GET</span> <span class="hljs-string">index.html</span> HTTP/1.1
<span class="hljs-attribute">Host</span>: www.cs.princeton.edu
</code></pre>
<p>Here, <code>Host</code> is one of the possible <code>MESSAGE_HEADER</code> fields. One of
the more interesting of these is , which gives the client a way to
conditionally request a Web page&#x2014;the server returns the page only if
it has been modified since the time specified in that header line.</p>
<h3 id="response-messages">Response Messages</h3>
<p>Like request messages, response messages begin with a single
<code>START_LINE</code>. In this case, the line specifies the version of HTTP
being used, a three-digit code indicating whether or not the request was
successful, and a text string giving the reason for the response. For
example, the <code>START_LINE</code></p>
<pre><code class="lang-http">HTTP/1.1 <span class="hljs-number">202</span> Accepted
</code></pre>
<p>indicates that the server was able to satisfy the request, while</p>
<pre><code class="lang-http">HTTP/1.1 <span class="hljs-number">404</span> Not Found
</code></pre>
<p>indicates that it was not able to satisfy the request because the page
was not found. There are five general types of response codes, with the
first digit of the code indicating its type. <a href="#codes">Table 2</a>
summarizes the five types of codes.</p>
<p><a id="codes"></a></p>
<table>
<thead>
<tr>
<th style="text-align:center">Code</th>
<th style="text-align:center">Type</th>
<th style="text-align:left">Example Reasons</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1xx</td>
<td style="text-align:center">Informational</td>
<td style="text-align:left">request received, continuing process</td>
</tr>
<tr>
<td style="text-align:center">2xx</td>
<td style="text-align:center">Success</td>
<td style="text-align:left">action successfully received, understood, and accepted</td>
</tr>
<tr>
<td style="text-align:center">3xx</td>
<td style="text-align:center">Redirection</td>
<td style="text-align:left">further action must be taken to complete the request</td>
</tr>
<tr>
<td style="text-align:center">4xx</td>
<td style="text-align:center">Client Error</td>
<td style="text-align:left">request contains bad syntax or cannot be fulfilled</td>
</tr>
<tr>
<td style="text-align:center">5xx</td>
<td style="text-align:center">Server Error</td>
<td style="text-align:left">server failed to fulfill an apparently valid request</td>
</tr>
</tbody>
</table>
<div class="ba-center"><p><em>Table 2. Five Types of HTTP Result Codes.</em></p></div>

<p>As with the unexpected consequences of the <code>POST</code> request message, it
is sometimes surprising how various response messages are used in
practice. For example, request redirection (specifically code 302) turns
out to be a powerful mechanism that plays a big role in Content
Distribution Networks (CDNs) by redirecting requests to a nearby cache.</p>
<p>Also similar to request messages, response messages can contain one or
more <code>MESSAGE_HEADER</code> lines. These lines relay additional information
back to the client. For example, the <code>Location</code> header line specifies
that the requested URL is available at another location. Thus, if the
Princeton CS Department Web page had moved from to , for example, then
the server at the original address might respond with</p>
<pre><code class="lang-http">HTTP/1.1 <span class="hljs-number">301</span> Moved Permanently
<span class="hljs-attribute">Location</span>: http://www.princeton.edu/cs/index.html
</code></pre>
<p>In the common case, the response message will also carry the requested
page. This page is an HTML document, but since it may carry nontextual
data (e.g., a GIF image), it is encoded using MIME (see the previous
section). Certain of the <code>MESSAGE_HEADER</code> lines give attributes of the
page contents, including (number of bytes in the contents), <code>Expires</code>
(time at which the contents are considered stale), and (time at which
the contents were last modified at the server).</p>
<h3 id="uniform-resource-identifiers">Uniform Resource Identifiers</h3>
<p>The URLs that HTTP uses as addresses are one type of <em>Uniform Resource
Identifier</em> (URI). A URI is a character string that identifies a
resource, where a resource can be anything that has identity, such as a
document, an image, or a service.</p>
<p>The format of URIs allows various more specialized kinds of resource
identifiers to be incorporated into the URI space of identifiers. The
first part of a URI is a <em>scheme</em> that names a particular way of
identifying a certain kind of resource, such as <code>mailto</code> for email
addresses or <code>file</code> for file names. The second part of a URI,
separated from the first part by a colon, is the <em>scheme-specific part</em>.
It is a resource identifier consistent with the scheme in the first
part, as in the URIs <code>mailto:santa@northpole.org</code> and <code>file:///C:/foo.html</code>.</p>
<p>A resource doesn&apos;t have to be retrievable or accessible. We saw an
example of this in an earlier chapter&#x2014;extensible markup language (XML)
namespaces are identified by URIs that look an awful lot like URLs, but
strictly speaking they are not <em>locators</em> because they don&apos;t tell you
how to locate something; they just provide a globally unique identifier
for the namespace. There is no requirement that you can retrieve
anything at the URI given as the target namespace of an XML document.
We&apos;ll see another example of a URI that is not a URL in a later section</p>
<h3 id="tcp-connections">TCP Connections</h3>
<p>The original version of HTTP (1.0) established a separate TCP connection
for each data item retrieved from the server. It&apos;s not too hard to see
how this was a very inefficient mechanism: connection setup and teardown
messages had to be exchanged between the client and server even if all
the client wanted to do was verify that it had the most recent copy of a
page. Thus, retrieving a page that included some text and a dozen icons
or other small graphics would result in 13 separate TCP connections
being established and closed. <a href="#oldhttp">Figure 4</a> shows the sequence
of events for fetching a page that has just a single embedded object.
Colored lines indicate TCP messages, while black lines indicate the HTTP
requests and responses. (Some of the TCP ACKs are not shown to avoid
cluttering the picture.) You can see two round trip times are spent
setting up TCP connections while another two (at least) are spent
getting the page and image. As well as the latency impact, there is also
processing cost on the server to handle the extra TCP connection
establishment and termination.</p>
<figure class="line">
    <a id="oldhttp"></a>
    <img src="figures/f09-04-9780123850591.png" width="500px">
    <figcaption>HTTP 1.0 behavior.</figcaption>
</figure>

<p>To overcome this situation, HTTP version 1.1 introduced <em>persistent
connections</em>&#x2014;the client and server can exchange multiple request/
response messages over the same TCP connection. Persistent connections
have many advantages. First, they obviously eliminate the connection
setup overhead, thereby reducing the load on the server, the load on the
network caused by the additional TCP packets, and the delay perceived by
the user. Second, because a client can send multiple request messages
down a single TCP connection, TCP&apos;s congestion window mechanism is able
to operate more efficiently. This is because it&apos;s not necessary to go
through the slow start phase for each page. <a href="#persist">Figure 5</a> shows
the transaction from <a href="#oldhttp">Figure 4</a> using a persistent connection
in the case where the connection is already open (presumably due to some
prior access of the same server).</p>
<figure class="line">
    <a id="persist"></a>
    <img src="figures/f09-05-9780123850591.png" width="500px">
    <figcaption>HTTP 1.1 behavior with persistent connections.</figcaption>
</figure>

<p>Persistent connections do not come without a price, however. The problem
is that neither the client nor server necessarily knows how long to keep
a particular TCP connection open. This is especially critical on the
server, which might be asked to keep connections opened on behalf of
thousands of clients. The solution is that the server must time out and
close a connection if it has received no requests on the connection for
a period of time. Also, both the client and server must watch to see if
the other side has elected to close the connection, and they must use
that information as a signal that they should close their side of the
connection as well. (Recall that both sides must close a TCP connection
before it is fully terminated.) Concerns about this added complexity may
be one reason why persistent connections were not used from the outset,
but today it is widely accepted that the benefits of persistent
connections more than offset the drawbacks.</p>
<h3 id="caching">Caching</h3>
<p>One of the most active areas of research (and entrepreneurship) in the
Internet today is how to effectively cache Web pages. Caching has many
benefits. From the client&apos;s perspective, a page that can be retrieved
from a nearby cache can be displayed much more quickly than if it has to
be fetched from across the world. From the server&apos;s perspective, having
a cache intercept and satisfy a request reduces the load on the server.</p>
<p>Caching can be implemented in many different places. For example, a
user&apos;s browser can cache recently accessed pages and simply display the
cached copy if the user visits the same page again. As another example,
a site can support a single site-wide cache. This allows users to take
advantage of pages previously downloaded by other users. Closer to the
middle of the Internet, Internet Service Providers (ISPs) can cache
pages. Note that, in the second case, the users within the site most
likely know what machine is caching pages on behalf of the site, and
they configure their browsers to connect directly to the caching host.
This node is sometimes called a <em>proxy</em>. In contrast, the sites that
connect to the ISP are probably not aware that the ISP is caching pages.
It simply happens to be the case that HTTP requests coming out of the
various sites pass through a common ISP router. This router can peek
inside the request message and look at the URL for the requested page.
If it has the page in its cache, it returns it. If not, it forwards the
request to the server and watches for the response to fly by in the
other direction. When it does, the router saves a copy in the hope that
it can use it to satisfy a future request.</p>
<blockquote>
<p>There are quite a few issues with this sort of caching, ranging 
from the technical to the regulatory. One example of a technical 
challenge is the effect of <em>asymmetric paths</em>, when the request to 
the server and the response to the client do not follow the same 
sequence of router hops. </p>
</blockquote>
<p>No matter where pages are cached, the ability to cache Web pages is
important enough that HTTP has been designed to make the job easier. The
trick is that the cache needs to make sure it is not responding with an
out-of-date version of the page. For example, the server assigns an
expiration date (the <code>Expires</code> header field) to each page it sends
back to the client (or to a cache between the server and client). The
cache remembers this date and knows that it need not reverify the page
each time it is requested until after that expiration date has passed.
After that time (or if that header field is not set) the cache can use
the <code>HEAD</code> or conditional <code>GET</code> operation (<code>GET</code> with header line)
to verify that it has the most recent copy of the page. More generally,
there are a set of <em>cache directives</em> that must be obeyed by all caching
mechanisms along the request/response chain. These directives specify
whether or not a document can be cached, how long it can be cached, how
fresh a document must be, and so on. We&apos;ll look at the related issue of
CDNs&#x2014;which are effectively distributed caches&#x2014;in a later section.</p>
<h2 id="web-services">Web Services</h2>
<p>So far we have focused on interactions between a human and a machine.
For example, a human uses a web browser to interact with a server, and
the interaction proceeds in response to input from the user (e.g., by
clicking on links). However, there is increasing demand for direct
computer-to-computer interaction. And, just as the applications
described above need protocols, so too do the applications that
communicate directly with each other. We conclude this section by
looking at the challenges of building large numbers of
application-to-application protocols and some of the proposed solutions.</p>
<p>Much of the motivation for enabling direct application-to-application
communication comes from the business world. Historically, interactions
between enterprises&#x2014;businesses or other organizations&#x2014;have involved
some manual steps such as filling out an order form or making a phone
call to determine whether some product is in stock. Even within a single
enterprise it is common to have manual steps between software systems
that cannot interact directly because they were developed independently.
Increasingly, such manual interactions are being replaced with direct
application-to-application interaction. An ordering application at
enterprise A would send a message to an order fulfillment application at
enterprise B, which would respond immediately indicating whether the
order can be filled. Perhaps, if the order cannot be filled by B, the
application at A would immediately order from another supplier or
solicit bids from a collection of suppliers.</p>
<p>Here is a simple example of what we are talking about. Suppose you buy a
book at an online retailer like Amazon.com. Once your book has been
shipped, Amazon could send you the tracking number in an email, and then
you could head over to the website for the shipping
company&#x2014;<code>http://www.fedex.com</code>, perhaps&#x2014;and track the package.
However, you can also track your
package directly from the Amazon.com website. In order to make this
happen, Amazon has to be able to send a query to FedEx, in a format that
FedEx understands, interpret the result, and display it in a Web page
that perhaps contains other information about your order. Underlying the
user experience of getting all the information about the order served up
at once on the Amazon.com Web page is the fact that Amazon and FedEx had
to have a protocol for exchanging the information needed to track
packages&#x2014;call it the Package Tracking Protocol. It should be clear
that there are so many potential protocols of this type that we&apos;d better
have some tools to simplify the task of specifying them and building
them.</p>
<p>Network applications, even those that cross
organization boundaries, are not new&#x2014;email and web browsing cross such
boundaries. What is new about this problem is the scale. Not scale in
the size of the network, but scale in the number of different kinds of
network applications. Both the protocol specifications and the
implementations of those protocols for traditional applications like
electronic mail and file transfer have typically been developed by a
small group of networking experts. To enable the vast number of
potential network applications to be developed quickly, it was necessary
to come up with some technologies that simplify and automate the task of
application protocol design and implementation.</p>
<p>Two architectures have been advocated as solutions to this problem. Both
architectures are called <em>Web Services</em>, taking their name from the term
for the individual applications that offer a remotely accessible service
to client applications to form network applications. The terms used
as informal shorthand to distinguish the two Web Services architectures
are <em>SOAP</em> and <em>REST</em> (as in, &quot;the SOAP vs. REST debate&quot;). We will
discuss the technical meanings of those terms shortly.</p>
<blockquote>
<p>The name <em>Web Services</em> is unfortunately so generic sounding that 
many mistakenly assume that it includes any sort of service 
associated with the Web. </p>
</blockquote>
<p>The SOAP architecture&apos;s approach to the problem is to make it feasible,
at least in theory, to generate protocols that are customized to each
network application. The key elements of the approach are a framework
for protocol specification, software toolkits for automatically
generating protocol implementations from the specifications, and modular
partial specifications that can be reused across protocols.</p>
<p>The REST architecture&apos;s approach to the problem is to regard individual
Web Services as World Wide Web resources&#x2014;identified by URIs and
accessed via HTTP. Essentially, the REST architecture is just the Web
architecture. The Web architecture&apos;s strengths include stability and a
demonstrated scalability (in the network-size sense). It could be
considered a weakness that HTTP is not well suited to the usual
procedural or operation-oriented style of invoking a remote service.
REST advocates argue, however, that rich services can nonetheless be
exposed using a more data-oriented or document-passing style for which
HTTP is well suited.</p>
<p>Although both architectures are being actively adopted, they are still
new enough that we don&apos;t yet have much empirical data about their
real-world use. One architecture may come to dominate, or they may merge
in some way, or we may find that one architecture is better suited to
certain kinds of applications while the other architecture is better for
others.</p>
<h3 id="custom-application-protocols-wsdl-soap">Custom Application Protocols (WSDL, SOAP)</h3>
<p>The architecture informally referred to as SOAP is based on <em>Web
Services Description Language</em> (WSDL) and <em>SOAP</em>. Both of these
standards are issued by the World Wide Web Consortium (W3C). This is the
architecture that people usually mean when they use the term Web
Services without any preceding qualifier. As these standards are still
evolving, our discussion here is effectively a snapshot.</p>
<blockquote>
<p>Although the name <em>SOAP</em> originated as an acronym, it officially 
no longer stands for anything. </p>
</blockquote>
<p>WSDL and SOAP are frameworks for specifying and implementing application
protocols and transport protocols, respectively. They are generally used
together, although that is not strictly required. WSDL is used to
specify application-specific details such as what operations are
supported, the formats of the application data to invoke or respond to
those operations, and whether an operation involves a response. SOAP&apos;s
role is to make it easy to define a transport protocol with exactly the
desired semantics regarding protocol features such as reliability and
security.</p>
<p>Both WSDL and SOAP consist primarily of a protocol specification
language. Both languages are based on XML with an eye toward making
specifications accessible to software tools such as stub compilers and
directory services. In a world of many custom protocols, support for
automating generation of implementations is crucial to avoid the effort
of manually implementing each protocol. Support software generally takes
the form of toolkits and application servers developed by third-party
vendors, which allows developers of individual Web Services to focus
more on the business problem they need to solve (such as tracking the
package purchased by a customer).</p>
<h3 id="defining-application-protocols">Defining Application Protocols</h3>
<p>WSDL has chosen a procedural <em>operation</em> model of application protocols.
An abstract Web Service interface consists of a set of named operations,
each representing a simple interaction between a client and the Web
Service. An operation is analogous to a remotely callable procedure in
an RPC system. An example from W3C&apos;s WSDL Primer is a hotel reservation
Web Service with two operations, CheckAvailability and MakeReservation.</p>
<p>Each operation specifies a <em>Message Exchange Pattern</em> (MEP) that gives
the sequence in which the messages are to be transmitted, including the
fault messages to be sent when an error disrupts the message flow.
Several MEPs are predefined, and new custom MEPs can be defined, but it
appears that in practice only two MEPs are being used: <strong>In-Only</strong> (a
single message from client to service) and <strong>In-Out</strong> (a request from
client and a corresponding reply from service). These patterns should be
very familiar, and suggest that the costs of supporting MEP flexibility
perhaps outweigh the benefits.</p>
<p>MEPs are templates that have placeholders instead of specific message
types or formats, so part of the definition of an operation involves
specifying which message formats to map into the placeholders in the
pattern. Message formats are not defined at the bit level that is
typical of protocols we have discussed. They are instead defined as an
abstract data model using XML. XML Schema provides a set of primitive
data types and ways to define compound data types. Data that conforms to
an XML Schema-defined format&#x2014;its abstract data model&#x2014;can be
concretely represented using XML, or it can use another representation,
such as the &quot;binary&quot; representation Fast Infoset.</p>
<p>WSDL nicely separates the parts of a protocol that can be specified
abstractly&#x2014;operations, MEPs, abstract message formats&#x2014;from the parts
that must be concrete. WSDL&apos;s concrete part specifies an underlying
protocol, how MEPs are mapped onto it, and what bit-level representation
is used for messages on the wire. This part of a specification is known
as a <em>binding</em>, although it is better described as an implementation, or
a mapping onto an implementation. WSDL has predefined bindings for HTTP
and SOAP-based protocols, with parameters that allow the protocol
designer to fine-tune the mapping onto those protocols. There is a
framework for defining new bindings, but SOAP protocols dominate.</p>
<p>A crucial aspect of how WSDL mitigates the problem of specifying large
numbers of protocols is through reuse of what are essentially
specification modules. The WSDL specification of a Web Service may be
composed of multiple WSDL documents, and individual WSDL documents may
also be used in other Web Service specifications. This modularity makes
it easier to develop a specification and easier to ensure that, if two
specifications are supposed to have some elements that are identical
(for example, so that they can be supported by the same tool), then
those elements are indeed identical. This modularity, together with
WSDL&apos;s defaulting rules, also helps keep specifications from becoming
overwhelmingly verbose for human protocol designers.</p>
<p>WSDL modularity should be familiar to anyone who has developed
moderately large pieces of software. A WSDL document need not be a
complete specification; it could, for example, define a single message
format. The partial specifications are uniquely identified using XML
Namespaces; each WSDL document specifies the URI of a <em>target
namespace</em>, and any new definitions in the document are named in the
context of that namespace. One WSDL document can incorporate components
of another by <em>including</em> the second document if both share the same
target namespace or <em>importing</em> it if the target namespaces differ.</p>
<h3 id="defining-transport-protocols">Defining Transport Protocols</h3>
<p>Although SOAP is sometimes called a protocol, it is better thought of as
a framework for defining protocols. As the SOAP 1.2 specification
explains, &quot;SOAP provides a simple messaging framework whose core
functionality is concerned with providing extensibility.&quot; SOAP uses many
of the same strategies as WSDL, including message formats defined using
XML Schema, bindings to underlying protocols, Message Exchange Patterns,
and reusable specification elements identified using XML namespaces.</p>
<p>SOAP is used to define transport protocols with exactly the features
needed to support a particular application protocol. SOAP aims to make
it feasible to define many such protocols by using reusable components.
Each component captures the header information and logic that go into
implementing a particular feature. To define a protocol with a certain
set of features, just compose the corresponding components. Let&apos;s look
more closely at this aspect of SOAP.</p>
<p>SOAP 1.2 introduced a <em>feature</em> abstraction, which the specification
describes thus: <em>A SOAP feature is an extension of the SOAP messaging
framework. Although SOAP poses no constraints on the potential scope of
such features, example features may include &quot;reliability,&quot; &quot;security,&quot;
&quot;correlation,&quot; &quot;routing,&quot; and message exchange patterns (MEPs) such as
request/response, one-way, and peer-to-peer conversations.</em> A SOAP
feature specification must include:</p>
<ul>
<li><p>A URI that identifies the feature</p>
</li>
<li><p>The state information and processing, abstractly described, that is
 required at each SOAP node to implement the feature</p>
</li>
<li><p>The information to be relayed to the next node</p>
</li>
<li><p>(If the feature is a MEP) the life cycle and temporal/causal
 relationships of the messages exchanged&#x2014;for example, responses
 follow requests and are sent to the originator of the request</p>
</li>
</ul>
<p>Note that this formalization of the concept of a protocol feature is
rather low level; it is almost a design.</p>
<p>Given a set of features, there are two strategies for defining a SOAP
protocol that will implement them. One is by layering: binding SOAP to
an underlying protocol in such a way as to derive the features. For
example, we could obtain a request/response protocol by binding SOAP to
HTTP, with a SOAP request in an HTTP request and a SOAP reply in an HTTP
response. Because this is such a common example, it happens that SOAP
has a predefined binding to HTTP; new bindings may be defined using the
SOAP Protocol Binding Framework.</p>
<p>The second and more flexible way to implement features involves <em>header
blocks</em>. A SOAP message consists of an Envelope, which contains a Header
that contains header blocks, and a Body, which contains the payload
destined for the ultimate receiver. This message structure is
illustrated in <a href="#soapFormat">Figure 6</a>.</p>
<figure class="line">
    <a id="soapFormat"></a>
    <img src="figures/f09-06-9780123850591.png" width="250px">
    <figcaption>SOAP message structure.</figcaption>
</figure>

<p>It should be a familiar notion by now that certain header information
corresponds to particular features. A digital signature is used to
implement authentication, a sequence number is used for reliability, and
a checksum is used to detect message corruption. A SOAP header block is
intended to encapsulate the header information that corresponds to a
particular feature. The correspondence is not always one-to-one since
multiple header blocks could be involved in a single feature, or a
single header block could be used in multiple features. A <em>SOAP module</em>
is a specification of the syntax and the semantics of one or more header
blocks. Each module is intended to provide one or more features and must
declare the features it implements.</p>
<p>The goal behind SOAP modules is to be able to compose a protocol with a
set of features by simply including each of the corresponding module
specifications. If your protocol is required to have at-most-once
semantics and authentication, include the corresponding modules in your
specification. This represents a novel approach to modularizing protocol
services, an alternative to the protocol layering we have seen
throughout this book. It is bit like flattening a series of protocol
layers into a single protocol, but in a structured way. It remains to be
seen how well SOAP features and modules, introduced in version 1.2 of
SOAP, will work in practice. The main weakness of this scheme is that
modules may well interfere with each other. A module specification is
required to specify any <em>known</em> interactions with other SOAP modules,
but clearly that doesn&apos;t do much to alleviate the problem. On the other
hand, a core set of features and modules that provides the most
important properties may be small enough to be well known and well
understood.</p>
<h3 id="standardizing-web-services-protocols">Standardizing Web Services Protocols</h3>
<p>As we&apos;ve said, WSDL and SOAP aren&apos;t protocols; they are standards for
<em>specifying</em> protocols. For different enterprises to implement Web
Services that interoperate with each other, it is not enough to agree to
use WSDL and SOAP to define their protocols; they must agree
on&#x2014;standardize&#x2014;specific protocols. For example, you could imagine
that online retailers and shipping companies might like to standardize a
protocol by which they exchange information, along the lines of the
simple package tracking example at the start of this section. This
standardization is crucial for tool support as well as interoperability.
And, yet, different network applications in this architecture must
necessarily differ in at least the message formats and operations they
use.</p>
<p>This tension between standardization and customization is tackled by
establishing partial standards called <em>profiles</em>. A profile is a set of
guidelines that narrow or constrain choices available in WSDL, SOAP, and
other standards that may be referenced in defining a protocol. They may
at the same time resolve ambiguities or gaps in those standards. In
practice, a profile often formalizes an emerging <em>de facto</em> standard.</p>
<p>The broadest and most widely adopted profile is known as the <em>WS-I Basic
Profile</em>. It was proposed by the Web Services Interoperability
Organization (WS-I), an industry consortium, while WSDL and SOAP are
specified by the World Wide Web Consortium (W3C). The Basic Profile
resolves some of the most basic choices faced in defining a Web Service.
Most notably it requires that WSDL be bound exclusively to SOAP and SOAP
be bound exclusively to HTTP and use the HTTP POST method. It also
specifies which versions of WSDL and SOAP must be used.</p>
<p>The <em>WS-I Basic Security Profile</em> adds security constraints to the Basic
Profile by specifying how the SSL/TLS layer is to be used and requiring
conformance to <em>WS-Security</em> (Web Services Security). WS-Security
specifies how to use various existing techniques such as X.509 public
key certificatesand Kerberos to provide security features in SOAP
protocols.</p>
<p>2.5pt plus1pt minus1pt WS-Security is just the first of a growing suite
of SOAP-level standards established by the industry consortium OASIS
(Organization for the Advancement of Structured Information Standards).
The standards known collectively as <em>WS-</em>* include WS-Reliability,
WS-ReliableMessaging, WS-Coordination, and WS-AtomicTransaction.</p>
<h3 id="a-generic-application-protocol-rest">A Generic Application Protocol (REST)</h3>
<p>The WSDL/SOAP Web Services architecture is based on the assumption that
the best way to integrate applications across networks is via protocols
that are customized to each application. That architecture is designed
to make it practical to specify and implement all those protocols. In
contrast, the REST Web Services architecture is based on the assumption
that the best way to integrate applications across networks is by
re-applying the model underlying the World Wide Web architecture. This
model, articulated by Web architect Roy Fielding, is known as
<em>REpresentational State Transfer</em> (REST). There is no need for a new
REST architecture for Web Services&#x2014;the existing Web architecture is
sufficient, although a few extensions are probably necessary. In the Web
architecture, individual Web Services are regarded as resources
identified by URIs and accessed via HTTP&#x2014;a single generic application
protocol with a single generic addressing scheme.</p>
<p>Where WSDL has user-defined operations, REST uses the small set of
available HTTP methods, such as <code>GET</code> and <code>POST</code> (see
<a href="#ops">Table 1</a>). So how can these simple methods provide an interface
to a rich Web Service? By employing the REST model, in which the
complexity is shifted from the protocol to the payload. The payload is a
representation of the abstract state of a resource. For example, a
<code>GET</code> could return a representation of the current state of the
resource, and a <code>POST</code> could send a representation of a desired state
of the resource.</p>
<p>The representation of a resource state is abstract; it need not resemble
how the resource is actually implemented by a particular Web Service
instance. It is not necessary to transmit a complete resource state in
each message. The size of messages can be reduced by transmitting just
the parts of a state that are of interest (e.g., just the parts that are
being modified). And, because Web Services share a single protocol and
address space with other web resources, parts of states can be passed by
reference&#x2014;by URI&#x2014;even when they are other Web Services.</p>
<p>This approach is best summarized as a data-oriented or document-passing
style, as opposed to a procedural style. Defining an application
protocol in this architecture consists of defining the document
structure (i.e., the state representation). XML and the lighter-weight
JavaScript Object Notation (JSON) are the most frequently used
presentation languages for this state. Interoperability depends on
agreement, between a Web Service and its client, on the state
representation. Of course, the same is true in the SOAP architecture; a
Web Service and its client have to be in agreement on payload format.
The difference is that in the SOAP architecture interoperability
additionally depends on agreement on the protocol; in the REST
architecture, the protocol is always HTTP, so that source of
interoperability problems is eliminated.</p>
<p>One of the selling features of REST is that it leverages the
infrastructure that has been deployed to support the Web. For example,
Web proxies can enforce security or cache information. Existing content
distribution networks (CDNs) can be used to support RESTful
applications.</p>
<p>In contrast with WSDL/SOAP, the Web has had time for standards to
stabilize and to demonstrate that it scales very well. It also comes
with some security in the form of Secure Socket Layer (SSL)/Transport
Layer Security (TLS). The Web and REST may also have an advantage in
evolvability. Although the WSDL and SOAP <em>frameworks</em> are highly
flexible with regard to what new features and bindings can go into the
definition of a protocol, that flexibility is irrelevant once the
protocol is defined. Standardized protocols such as HTTP are designed
with a provision for being extended in a backward-compatible way. HTTP&apos;s
own extensibility takes the form of headers, new methods, and new
content types. Protocol designers using WSDL/SOAP need to design such
extensibility into each of their custom protocols. Of course, the
designers of state representations in a REST architecture also have to
design for evolvability.</p>
<p>An area where WSDL/SOAP may have an advantage is in adapting or wrapping
previously written, &quot;legacy&quot; applications to conform to Web Services.
This is an important point since most Web Services will be based on
legacy applications for the near future at least. These applications
usually have a procedural interface that maps more easily into WSDL&apos;s
operations than REST states. The REST versus WSDL/SOAP competition may
very well hinge on how easy or difficult it turns out to be to devise
REST-style interfaces for individual Web Services. We may find that some
Web Services are better served by WSDL/SOAP and others by REST.</p>
<p>The online retailer Amazon.com, as it happens, was an early adopter
(2002) of Web Services. Interestingly, Amazon made its systems publicly
accessible via <em>both</em> of the Web Services architectures, and according
to some reports a substantial majority of developers use the REST
interface. Of course, this is just one data point and may well reflect
factors specific to Amazon.</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="problem.html" class="navigation navigation-prev " aria-label="Previous page: Chapter 9: Applications">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="multimedia.html" class="navigation navigation-next " aria-label="Next page: 9.2 Multimedia Applications">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"9.1 Traditional Applications","level":"1.10.1","depth":2,"next":{"title":"9.2 Multimedia Applications","level":"1.10.2","depth":2,"path":"applications/multimedia.md","ref":"applications/multimedia.md","articles":[]},"previous":{"title":"Chapter 9: Applications","level":"1.10","depth":1,"path":"applications/problem.md","ref":"applications/problem.md","articles":[{"title":"9.1 Traditional Applications","level":"1.10.1","depth":2,"path":"applications/traditional.md","ref":"applications/traditional.md","articles":[]},{"title":"9.2 Multimedia Applications","level":"1.10.2","depth":2,"path":"applications/multimedia.md","ref":"applications/multimedia.md","articles":[]},{"title":"9.3 Infrastructure Applications","level":"1.10.3","depth":2,"path":"applications/infrastructure.md","ref":"applications/infrastructure.md","articles":[]},{"title":"9.4 Overlay Networks","level":"1.10.4","depth":2,"path":"applications/overlays.md","ref":"applications/overlays.md","articles":[]},{"title":"9.5 Summary","level":"1.10.5","depth":2,"path":"applications/summary.md","ref":"applications/summary.md","articles":[]}]},"dir":"ltr"},"config":{"plugins":["anchorjs","katex","block-align","sequence-diagrams","creativecommons","custom-favicon","smart-nav-collapse"],"root":".","styles":{"website":"styles/website.css","pdf":"styles/pdf.css"},"pluginsConfig":{"block-align":{},"search":{},"sequence-diagrams":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"katex":{},"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"favicon":"bridge.ico","custom-favicon":{},"creativecommons":{},"smart-nav-collapse":{},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false},"anchorjs":{}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{"branch":"master"},"title":"Computer Networks: A Systems Approach","gitbook":"*"},"file":{"path":"applications/traditional.md","mtime":"2018-08-15T22:11:51.000Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2018-08-22T20:57:40.956Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.1.1/anchor.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-anchorjs/anchor-style.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-smart-nav-collapse/smart-nav-collapse.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

