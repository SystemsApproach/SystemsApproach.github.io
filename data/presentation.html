
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>7.1 Presentation Formatting Â· Computer Networks: A Systems Approach</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-katex/katex.min.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-block-align/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-smart-nav-collapse/smart-nav-collapse.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
        <link rel="stylesheet" href="../styles/website.css">
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="multimedia.html" />
    
    
    <link rel="prev" href="problem.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Preface
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../foundation/problem.html">
            
                <a href="../foundation/problem.html">
            
                    
                    Chapter 1: Foundation
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="../foundation/applications.html">
            
                <a href="../foundation/applications.html">
            
                    
                    1.1 Applications
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="../foundation/requirements.html">
            
                <a href="../foundation/requirements.html">
            
                    
                    1.2 Requirements
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="../foundation/architecture.html">
            
                <a href="../foundation/architecture.html">
            
                    
                    1.3 Architecture
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.4" data-path="../foundation/software.html">
            
                <a href="../foundation/software.html">
            
                    
                    1.4 Software
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.5" data-path="../foundation/performance.html">
            
                <a href="../foundation/performance.html">
            
                    
                    1.5 Performance
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.6" data-path="../foundation/summary.html">
            
                <a href="../foundation/summary.html">
            
                    
                    1.6 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../direct/problem.html">
            
                <a href="../direct/problem.html">
            
                    
                    Chapter 2: Direct Connections
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="../direct/perspective.html">
            
                <a href="../direct/perspective.html">
            
                    
                    2.1 Technology Landscape
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="../direct/encoding.html">
            
                <a href="../direct/encoding.html">
            
                    
                    2.2 Encoding
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3" data-path="../direct/framing.html">
            
                <a href="../direct/framing.html">
            
                    
                    2.3 Framing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4" data-path="../direct/error.html">
            
                <a href="../direct/error.html">
            
                    
                    2.4 Error Detection
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.5" data-path="../direct/reliable.html">
            
                <a href="../direct/reliable.html">
            
                    
                    2.5 Reliable Transmission
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.6" data-path="../direct/ethernet.html">
            
                <a href="../direct/ethernet.html">
            
                    
                    2.6 Multi-Access Networks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.7" data-path="../direct/wireless.html">
            
                <a href="../direct/wireless.html">
            
                    
                    2.7 Wireless Networks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.8" data-path="../direct/access.html">
            
                <a href="../direct/access.html">
            
                    
                    2.8 Access Networks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.9" data-path="../direct/summary.html">
            
                <a href="../direct/summary.html">
            
                    
                    2.9 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="../internetworking/problem.html">
            
                <a href="../internetworking/problem.html">
            
                    
                    Chapter 3: Internetworking
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="../internetworking/switching.html">
            
                <a href="../internetworking/switching.html">
            
                    
                    3.1 Switching and Bridging
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="../internetworking/basic-ip.html">
            
                <a href="../internetworking/basic-ip.html">
            
                    
                    3.2 Basic Internetworking
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3" data-path="../internetworking/routing.html">
            
                <a href="../internetworking/routing.html">
            
                    
                    3.3 Routing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4" data-path="../internetworking/impl.html">
            
                <a href="../internetworking/impl.html">
            
                    
                    3.4 Implementation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.5" data-path="../internetworking/summary.html">
            
                <a href="../internetworking/summary.html">
            
                    
                    3.5 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="../scaling/problem.html">
            
                <a href="../scaling/problem.html">
            
                    
                    Chapter 4: Advanced Internetworking
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.1" data-path="../scaling/global.html">
            
                <a href="../scaling/global.html">
            
                    
                    4.1 Global Internet
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.2" data-path="../scaling/multicast.html">
            
                <a href="../scaling/multicast.html">
            
                    
                    4.2 Multicast
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.3" data-path="../scaling/mpls.html">
            
                <a href="../scaling/mpls.html">
            
                    
                    4.3 Multiprotocol Label Switching
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.4" data-path="../scaling/mobile-ip.html">
            
                <a href="../scaling/mobile-ip.html">
            
                    
                    4.4 Routing Among Mobile Devices
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.5" data-path="../scaling/summary.html">
            
                <a href="../scaling/summary.html">
            
                    
                    4.5 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="../e2e/problem.html">
            
                <a href="../e2e/problem.html">
            
                    
                    Chapter 5: End-to-End Protocols
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.6.1" data-path="../e2e/udp.html">
            
                <a href="../e2e/udp.html">
            
                    
                    5.1 Simple Demultiplexor (UDP)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2" data-path="../e2e/tcp.html">
            
                <a href="../e2e/tcp.html">
            
                    
                    5.2 Reliable Byte Stream (TCP)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.3" data-path="../e2e/rpc.html">
            
                <a href="../e2e/rpc.html">
            
                    
                    5.3 Remote Procedure Call
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.4" data-path="../e2e/rtp.html">
            
                <a href="../e2e/rtp.html">
            
                    
                    5.4 Transport for Real-Time (RTP)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.5" data-path="../e2e/summary.html">
            
                <a href="../e2e/summary.html">
            
                    
                    5.5 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="../congestion/problem.html">
            
                <a href="../congestion/problem.html">
            
                    
                    Chapter 6: Congestion Control
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.1" data-path="../congestion/issues.html">
            
                <a href="../congestion/issues.html">
            
                    
                    6.1 Issues in Resource Allocation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.2" data-path="../congestion/queuing.html">
            
                <a href="../congestion/queuing.html">
            
                    
                    6.2 Queuing Disciplines
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.3" data-path="../congestion/tcpcc.html">
            
                <a href="../congestion/tcpcc.html">
            
                    
                    6.3 TCP Congestion Control
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4" data-path="../congestion/avoidance.html">
            
                <a href="../congestion/avoidance.html">
            
                    
                    6.4 Congestion-Avoidance
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.5" data-path="../congestion/qos.html">
            
                <a href="../congestion/qos.html">
            
                    
                    6.5 Quality of Service
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.6" data-path="../congestion/summary.html">
            
                <a href="../congestion/summary.html">
            
                    
                    6.6 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="problem.html">
            
                <a href="problem.html">
            
                    
                    Chapter 7: End-to-End Data
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter active" data-level="1.8.1" data-path="presentation.html">
            
                <a href="presentation.html">
            
                    
                    7.1 Presentation Formatting
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.2" data-path="multimedia.html">
            
                <a href="multimedia.html">
            
                    
                    7.2 Multimedia Data
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.3" data-path="summary.html">
            
                <a href="summary.html">
            
                    
                    7.3 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="../security/problem.html">
            
                <a href="../security/problem.html">
            
                    
                    Chapter 8: Network Security
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.9.1" data-path="../security/crypto.html">
            
                <a href="../security/crypto.html">
            
                    
                    8.1 Cryptographic Building Blocks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2" data-path="../security/key-distro.html">
            
                <a href="../security/key-distro.html">
            
                    
                    8.2 Key Predistribution
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.3" data-path="../security/authentication.html">
            
                <a href="../security/authentication.html">
            
                    
                    8.3 Authentication Protocols
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.4" data-path="../security/systems.html">
            
                <a href="../security/systems.html">
            
                    
                    8.4 Example Systems
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.5" data-path="../security/summary.html">
            
                <a href="../security/summary.html">
            
                    
                    8.5 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="../applications/problem.html">
            
                <a href="../applications/problem.html">
            
                    
                    Chapter 9: Applications
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.10.1" data-path="../applications/traditional.html">
            
                <a href="../applications/traditional.html">
            
                    
                    9.1 Traditional Applications
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.2" data-path="../applications/multimedia.html">
            
                <a href="../applications/multimedia.html">
            
                    
                    9.2 Multimedia Applications
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.3" data-path="../applications/infrastructure.html">
            
                <a href="../applications/infrastructure.html">
            
                    
                    9.3 Infrastructure Applications
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.4" data-path="../applications/overlays.html">
            
                <a href="../applications/overlays.html">
            
                    
                    9.4 Overlay Networks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.5" data-path="../applications/summary.html">
            
                <a href="../applications/summary.html">
            
                    
                    9.5 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >7.1 Presentation Formatting</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="71-presentation-formatting">7.1 Presentation Formatting</h1>
<p>One of the most common transformations of network data is from the
representation used by the application program into a form that is
suitable for transmission over a network and <em>vice versa</em>. This
transformation is typically called <em>presentation formatting</em>. As
illustrated in <a href="#marshal1">Figure 1</a>, the sending program translates
the data it wants to transmit from the representation it uses internally
into a message that can be transmitted over the network; that is, the
data is <em>encoded</em> in a message. On the receiving side, the application
translates this arriving message into a representation that it can then
process; that is, the message is <em>decoded</em>. Encoding is sometimes called
<em>argument marshalling</em>, and decoding is sometimes called
<em>unmarshalling</em>. This terminology comes from the Remote Procedure Call
(RPC) world, where the client thinks it is invoking a procedure with a
set of arguments, but these arguments are then &quot;brought together and
ordered in an appropriate and effective way&quot; to form a network
message.</p>
<figure class="line">
    <a id="marshal1"></a>
    <img src="figures/f07-01-9780123850591.png" width="400px">
    <figcaption>Presentation formatting involves encoding and decoding
    application data.</figcaption>
</figure>

<p>You might ask what makes this problem challenging enough to warrant a
name like marshalling. One reason is that computers represent data in
different ways. For example, some computers represent floating-point
numbers in IEEE standard 754 format, while some older machines still use
their own nonstandard format. Even for something as simple as integers,
different architectures use different sizes (e.g., 16-bit, 32-bit,
64-bit). To make matters worse, on some machines integers are
represented in <em>big-endian</em> form (the most significant bit of a word is
in the byte with the highest address), while on other machines integers
are represented in <em>little-endian</em> form (the most significant bit is in
the byte with the lowest address). For example, PowerPC processors are
big-endian machines, and the Intel x86 family is a little-endian
architecture. Today, many architectures support both representations
(and so are called <em>bi-endian</em>), but the point is that you can never be
sure how the host you are communicating with stores integers. The
big-endian and little-endian representations of the integer 34,677,374
are given in <a href="#endian">Figure 2</a>.</p>
<figure class="line">
    <a id="endian"></a>
    <img src="figures/f07-02-9780123850591.png" width="500px">
    <figcaption>Big-endian and little-endian byte order for the integer
    34,677,374</figcaption>
</figure>

<p>Another reason that marshalling is difficult is that application
programs are written in different languages, and even when you are using
a single language there may be more than one compiler. For example,
compilers have a fair amount of latitude in how they lay out structures
(records) in memory, such as how much padding they put between the
fields that make up the structure. Thus, you could not simply transmit a
structure from one machine to another, even if both machines were of the
same architecture and the program was written in the same language,
because the compiler on the destination machine might align the fields
in the structure differently.</p>
<h2 id="taxonomy">Taxonomy</h2>
<p>Although argument marshalling is not rocket science is involved&#x2014;it is
a small matter of bit twiddling&#x2014;there are a surprising number of
design choices that you must address. We begin by giving a simple
taxonomy for argument marshalling systems. The following is by no
means the only viable taxonomy, but it is sufficient to cover most of
the interesting alternatives.</p>
<h3 id="data-types">Data Types</h3>
<p>The first question is what data types the system is going to support. In
general, we can classify the types supported by an argument marshalling
mechanism at three levels. Each level complicates the task faced by the
marshalling system.</p>
<p>At the lowest level, a marshalling system operates on some set of <em>base
types</em>. Typically, the base types include integers, floating-point
numbers, and characters. The system might also support ordinal types and
Booleans. As described above, the implication of the set of base types
is that the encoding process must be able to convert each base type from
one representation to another&#x2014;for example, convert an integer from
big-endian to little-endian.</p>
<p>At the next level are <em>flat types</em>&#x2014;structures and arrays. While flat
types might at first not appear to complicate argument marshalling, the
reality is that they do. The problem is that the compilers used to
compile application programs sometimes insert padding between the fields
that make up the structure so as to align these fields on word
boundaries. The marshalling system typically <em>packs</em> structures so that
they contain no padding.</p>
<p>At the highest level, the marshalling system might have to deal with
<em>complex types</em>&#x2014;those types that are built using pointers. That is,
the data structure that one program wants to send to another might not
be contained in a single structure, but might instead involve pointers
from one structure to another. A tree is a good example of a complex
type that involves pointers. Clearly, the data encoder must prepare the
data structure for transmission over the network because pointers are
implemented by memory addresses, and just because a structure lives at a
certain memory address on one machine does not mean it will live at the
same address on another machine. In other words, the marshalling system
must <em>serialize</em> (flatten) complex data structures.</p>
<p>In summary, depending on how complicated the type system is, the task of
argument marshalling usually involves converting the base types, packing
the structures, and linearizing the complex data structures, all to form
a contiguous message that can be transmitted over the network.
<a href="#marshal2">Figure 3</a> illustrates this task.</p>
<figure class="line">
    <a id="marshal2"></a>
    <img src="figures/f07-03-9780123850591.png" width="400px">
    <figcaption>Argument marshalling: converting, packing, and
    linearizing</figcaption>
</figure>

<h3 id="conversion-strategy">Conversion Strategy</h3>
<p>Once the type system is established, the next issue is what conversion
strategy the argument marshaller will use. There are two general
options: <em>canonical intermediate form</em> and <em>receiver-makes-right</em>. We
consider each, in turn.</p>
<p>The idea of canonical intermediate form is to settle on an external
representation for each type; the sending host translates from its
internal representation to this external representation before sending
data, and the receiver translates from this external representation into
its local representation when receiving data. To illustrate the idea,
consider integer data; other types are treated in a similar manner. You
might declare that the big-endian format will be used as the external
representation for integers. The sending host must translate each
integer it sends into big-endian form, and the receiving host must
translate big-endian integers into whatever representation it uses.
(This is what is done in the Internet for protocol headers.) Of course,
a given host might already use big-endian form, in which case no
conversion is necessary.</p>
<p>The alternative, receiver-makes-right, has the sender transmit data in
its own internal format; the sender does not convert the base types, but
usually has to pack and flatten more complex data structures. The
receiver is then responsible for translating the data from the sender&apos;s
format into its own local format. The problem with this strategy is that
every host must be prepared to convert data from all other machine
architectures. In networking, this is known as an <em>N-by-N solution</em>:
Each of N machine architectures must be able to handle all N
architectures. In contrast, in a system that uses a canonical
intermediate form, each host needs to know only how to convert between
its own representation and a single other representation&#x2014;the external
one.</p>
<p>Using a common external format is clearly the correct thing to do,
right? This has certainly been the conventional wisdom in the networking
community for over 30 years. The answer is not cut and dried,
however. It turns out that there are not that many different
representations for the various base classes, or, said another way, N
is not that large. In addition, the most common case is for two machines
of the same type to be communicating with each other. In this situation,
it seems silly to translate data from that architecture&apos;s representation
into some foreign external representation, only to have to translate the
data back into the same architecture&apos;s representation on the receiver.</p>
<p>A third option, although we know of no existing system that exploits it,
is to use receiver-makes-right if the sender knows that the destination
has the same architecture; the sender would use some canonical
intermediate form if the two machines use different architectures. How
would a sender learn the receiver&apos;s architecture? It could learn this
information either from a name server or by first using a simple test
case to see if the appropriate result occurs.</p>
<h3 id="tags">Tags</h3>
<p>The third issue in argument marshalling is how the receiver knows what
kind of data is contained in the message it receives. There are two
common approaches: <em>tagged</em> and <em>untagged</em> data. The tagged approach is
more intuitive, so we describe it first.</p>
<p>A tag is any additional information included in a message&#x2014;beyond the
concrete representation of the base types&#x2014;that helps the receiver
decode the message. There are several possible tags that might be
included in a message. For example, each data item might be augmented
with a <em>type</em> tag. A type tag indicates that the value that follows is
an integer, a floating-point number, or whatever. Another example is a
<em>length</em> tag. Such a tag is used to indicate the number of elements in
an array or the size of an integer. A third example is an <em>architecture</em>
tag, which might be used in conjunction with the receiver-makes-right
strategy to specify the architecture on which the data contained in the
message was generated. <a href="#tags">Figure 4</a> depicts how a simple 32-bit
integer might be encoded in a tagged message.</p>
<figure class="line">
    <a id="tags"></a>
    <img src="figures/f07-04-9780123850591.png" width="400px">
    <figcaption>A 32-bit integer encoded in a tagged
    message.</figcaption>
</figure>

<p>The alternative, of course, is not to use tags. How does the receiver
know how to decode the data in this case? It knows because it was
programmed to know. In other words, if you call a remote procedure that
takes two integers and a floating-point number as arguments, then there
is no reason for the remote procedure to inspect tags to know what it
has just received. It simply assumes that the message contains two
integers and a float and decodes it accordingly. Note that, while this
works for most cases, the one place it breaks down is when sending
variable-length arrays. In such a case, a length tag is commonly used to
indicate how long the array is.</p>
<p>It is also worth noting that the untagged approach means that the
presentation formatting is truly end to end. It is not possible for some
intermediate agent to interpret the message unless the data is tagged.
Why would an intermediate agent need to interpret a message, you might
ask? Stranger things have happened, mostly resulting from <em>ad hoc</em>
solutions to unexpected problems that the system was not engineered to
handle. Poor network design is beyond the scope of this book.</p>
<h3 id="stubs">Stubs</h3>
<p>A stub is the piece of code that implements argument marshalling. Stubs
are typically used to support RPC. On the client side, the stub marshals
the procedure arguments into a message that can be transmitted by means
of the RPC protocol. On the server side, the stub converts the message
back into a set of variables that can be used as arguments to call the
remote procedure. Stubs can either be interpreted or compiled.</p>
<p>In a compilation-based approach, each procedure has a customized client
and server stub. While it is possible to write stubs by hand, they are
typically generated by a stub compiler, based on a description of the
procedure&apos;s interface. This situation is illustrated in
<a href="#stubs">Figure 5</a>. Since the stub is compiled, it is usually very
efficient. In an interpretation-based approach, the system provides
generic client and server stubs that have their parameters set by a
description of the procedure&apos;s interface. Because it is easy to change
this description, interpreted stubs have the advantage of being
flexible. Compiled stubs are more common in practice.</p>
<figure class="line">
    <a id="stubs"></a>
    <img src="figures/f07-05-9780123850591.png" width="500px">
    <figcaption>Stub compiler takes interface description as input and
    outputs client and server stubs.</figcaption>
</figure>

<h2 id="examples-xdr-asn1-ndr">Examples (XDR, ASN.1, NDR)</h2>
<p>We now briefly describe three popular network data representations in
terms of this taxonomy. We use the integer base type to illustrate how
each system works.</p>
<h3 id="xdr">XDR</h3>
<p>External Data Representation (XDR) is the network format used with
SunRPC. In the taxonomy just introduced, XDR</p>
<ul>
<li><p>Supports the entire C-type system with the exception of function
  pointers</p>
</li>
<li><p>Defines a canonical intermediate form</p>
</li>
<li><p>Does not use tags (except to indicate array lengths)</p>
</li>
<li><p>Uses compiled stubs</p>
</li>
</ul>
<p>An XDR integer is a 32-bit data item that encodes a C integer. It is
represented in twos complement notation, with the most significant byte
of the C integer in the first byte of the XDR integer and the least
significant byte of the C integer in the fourth byte of the XDR integer.
That is, XDR uses big-endian format for integers. XDR supports both
signed and unsigned integers, just as C does.</p>
<p>XDR represents variable-length arrays by first specifying an unsigned
integer (4 bytes) that gives the number of elements in the array,
followed by that many elements of the appropriate type. XDR encodes the
components of a structure in the order of their declaration in the
structure. For both arrays and structures, the size of each
element/component is represented in a multiple of 4 bytes. Smaller data
types are padded out to 4 bytes with 0s. The exception to this &quot;pad to
4 bytes&quot; rule is made for characters, which are encoded one per byte.</p>
<figure class="line">
    <a id="xdr"></a>
    <img src="figures/f07-06-9780123850591.png" width="500px">
    <figcaption>Example encoding of a structure in XDR.</figcaption>
</figure>

<p>The following code fragment gives an example C structure (<code>item</code>) and
the XDR routine that encodes/decodes this structure (<code>xdr_item</code>).
<a href="#xdr">Figure 6</a> schematically depicts XDR&apos;s on-the-wire representation
of this structure when the field <code>name</code> is seven characters long and
the array <code>list</code> has three values in it.</p>
<p>In this example, <code>xdr_array</code>, <code>xdr_int</code>, and <code>xdr_string</code> are
three primitive functions provided by XDR to
encode and decode arrays, integers, and character strings, respectively.
Argument <code>xdrs</code> is a context variable that XDR uses to keep track of
where it is in the message being processed; it includes a flag that
indicates whether this routine is being used to encode or decode the
message. In other words, routines like <code>xdr_item</code> are used on both
the client and the server. Note that the application programmer can
either write the routine <code>xdr_item</code> by hand or use a stub compiler called
<code>rpcgen</code> (not shown) to generate this encoding/decoding routine. In
the latter case, <code>rpcgen</code> takes the remote procedure that defines the
data structure <code>item</code> as input and outputs the corresponding stub.</p>
<pre><code class="lang-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXNAME 256;</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXLIST 100;</span>

<span class="hljs-keyword">struct</span> item {
   <span class="hljs-keyword">int</span>     count;
   <span class="hljs-keyword">char</span>    name[MAXNAME];
   <span class="hljs-keyword">int</span>     <span class="hljs-built_in">list</span>[MAXLIST];
};

<span class="hljs-keyword">bool_t</span>
xdr_item(XDR *xdrs, <span class="hljs-keyword">struct</span> item *ptr)
{
    <span class="hljs-keyword">return</span>(xdr_int(xdrs, &amp;ptr-&gt;count) &amp;&amp;
       xdr_string(xdrs, &amp;ptr-&gt;name, MAXNAME) &amp;&amp;
       xdr_array(xdrs, &amp;ptr-&gt;<span class="hljs-built_in">list</span>, &amp;ptr-&gt;count, MAXLIST,
                 <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>), xdr_int));
}
</code></pre>
<p>Exactly how XDR performs depends, of course, on the complexity of the
data. In a simple case of an array of integers, where each integer has
to be converted from one byte order to another, an average of three
instructions are required for each byte, meaning that converting the
whole array is likely to be limited by the memory bandwidth of the
machine. More complex conversions that require significantly more
instructions per byte will be CPU limited and thus perform at a data
rate less than the memory bandwidth.</p>
<h3 id="asn1">ASN.1</h3>
<p>Abstract Syntax Notation One (ASN.1) is an ISO standard that defines,
among other things, a representation for data sent over a network. The
representation-specific part of ASN.1 is called the <em>Basic Encoding
Rules</em> (BER). ASN.1 supports the C-type system without function
pointers, defines a canonical intermediate form, and uses type tags. Its
stubs can be either interpreted or compiled. One of the claims to fame
of ASN.1 BER is that it is used by the Internet standard Simple Network
Management Protocol (SNMP).</p>
<p>ASN.1 represents each data item with a triple of the form</p>
<pre><code class="lang-pseudo">(tag, length, value)
</code></pre>
<p>The <code>tag</code> is typically an 8-bit field, although ASN.1 allows for the
definition of multibyte tags. The <code>length</code> field specifies how many
bytes make up the <code>value</code>; we discuss <code>length</code> more below. Compound
data types, such as structures, can be constructed by nesting primitive
types, as illustrated in <a href="#ber1">Figure 7</a>.</p>
<figure class="line">
    <a id="ber1"></a>
    <img src="figures/f07-07-9780123850591.png" width="600px">
    <figcaption>Compound types created by means of nesting in ASN.1
    BER.</figcaption>
</figure>

<figure class="line">
    <a id="ber2"></a>
    <img src="figures/f07-08-9780123850591.png" width="400px">
    <figcaption>ASN.1 BER representation for a 4-byte integer.</figcaption>
</figure>

<p>If the <code>value</code> is 127 or fewer bytes long, then the <code>length</code> is
specified in a single byte. Thus, for example, a 32-bit integer is
encoded as a 1-byte <code>type</code>, a 1-byte <code>length</code>, and the 4 bytes that
encode the integer, as illustrated in <a href="#ber2">Figure 8</a>. The <code>value</code>
itself, in the case of an integer, is represented in twos complement
notation and big-endian form, just as in XDR. Keep in mind that, even
though the <code>value</code> of the integer is represented in exactly the same
way in both XDR and ASN.1, the XDR representation has neither the
<code>type</code> nor the <code>length</code> tags associated with that integer. These two
tags both take up space in the message and, more importantly, require
processing during marshalling and unmarshalling. This is one reason why
ASN.1 is not as efficient as XDR. Another is that the very fact that
each data value is preceded by a <code>length</code> field means that the data
value is unlikely to fall on a natural byte boundary (e.g., an integer
beginning on a word boundary). This complicates the encoding/decoding
process.</p>
<p>If the <code>value</code> is 128 or more bytes long, then multiple bytes are used
to specify its <code>length</code>. At this point you may be asking why a byte
can specify a length of up to 127 bytes rather than 256. The reason is
that 1 bit of the <code>length</code> field is used to denote how long the
<code>length</code> field is. A 0 in the eighth bit indicates a 1-byte <code>length</code>
field. To specify a longer <code>length</code>, the eighth bit is set to 1, and
the other 7 bits indicate how many additional bytes make up the
<code>length</code>. <a href="#ber3">Figure 9</a> illustrates a simple 1-byte <code>length</code>
and a multibyte <code>length</code>.</p>
<figure class="line">
    <a id="ber3"></a>
    <img src="figures/f07-09-9780123850591.png" width="400px">
    <figcaption>ASN.1 BER representation for length: (a) 1 byte;
    (b) multibyte.</figcaption>
</figure>

<h3 id="ndr">NDR</h3>
<p>Network Data Representation (NDR) is the data-encoding standard used in
the Distributed Computing Environment (DCE). Unlike XDR and ASN.1, NDR
uses receiver-makes-right. It does this by inserting an architecture
tag at the front of each message; individual data items are
untagged. NDR uses a compiler to generate stubs. This compiler takes a
description of a program written in the Interface Definition Language
(IDL) and generates the necessary stubs. IDL looks pretty much like C,
and so essentially supports the C-type system.</p>
<figure class="line">
    <a id="ndr"></a>
    <img src="figures/f07-10-9780123850591.png" width="600px">
    <figcaption>NDR&apos;s architecture tag.</figcaption>
</figure>

<p><a href="#ndr">Figure 10</a> illustrates the 4-byte architecture definition tag
that is included at the front of each NDR-encoded message. The first
byte contains two 4-bit fields. The first field, <code>IntegrRep</code>, defines
the format for all integers contained in the message. A 0 in this field
indicates big-endian integers, and a 1 indicates little-endian integers.
The <code>CharRep</code> field indicates what character format is used: 0 means
ASCII (American Standard Code for Information Interchange) and 1 means
EBCDIC (an older, IBM-defined alternative to ASCII). Next, the
<code>FloatRep</code> byte defines which floating-point representation is being
used: 0 means IEEE 754, 1 means VAX, 2 means Cray, and 3 means IBM. The
final 2 bytes are reserved for future use. Note that, in simple cases
such as arrays of integers, NDR does the same amount of work as XDR, and
so it is able to achieve the same performance.</p>
<h2 id="markup-languages-xml">Markup Languages (XML)</h2>
<p>Although we have been discussing the presentation formatting problem
from the perspective of RPC&#x2014;that is, how does one encode primitive
data types and compound data structures so they can be sent from a
client program to a server program&#x2014;the same basic problem occurs in
other settings. For example, how does a web server describe a Web page
so that any number of different browsers know what to display on the
screen? In this specific case, the answer is the HyperText Markup
Language (HTML), which indicates that certain character strings should
be displayed in bold or italics, what font type and size should be used,
and where images should be positioned.</p>
<p>The availability of all sorts of Web applications and data have
also created a situation in which different Web applications need to
communicate with each other and understand each other&apos;s data. For
example, an e-commerce website might need to talk to a shipping
company&apos;s website to allow a customer to track a package without ever
leaving the e-commerce website. This quickly starts to look a lot
like RPC, and the approach taken in the Web today to enable such
communication among web servers is based on the <em>Extensible Markup
Language</em> (XML)&#x2014;a way to describe the data being exchanged between
Web apps.</p>
<p>Markup languages, of which HTML and XML are both examples, take the
tagged data approach to the extreme. Data is represented as text, and
text tags known as <em>markup</em> are intermingled with the data text to
express information about the data. In the case of HTML, markup
indicates how the text should be displayed; other markup languages
like XML can express the type and structure of the data.</p>
<p>XML is actually a framework for defining different markup languages for
different kinds of data. For example, XML has been used to define a
markup language that is roughly equivalent to HTML called <em>Extensible
HyperText Markup Language</em> (XHTML). XML defines a basic syntax for
mixing markup with data text, but the designer of a specific markup
language has to name and define its markup. It is common practice to
refer to individual XML-based languages simply as XML, but we will
emphasize the distinction in this introductory material.</p>
<p>XML syntax looks much like HTML. For example, an employee record in a
hypothetical XML-based language might look like the following XML
<em>document</em>, which might be stored in a file named <code>employee.xml</code>. The
first line indicates the version of XML being used, and the remaining
lines represent four fields that make up the employee record, the last
of which (<code>hiredate</code>) contains three subfields. In other words, XML
syntax provides for a nested structure of tag/value pairs, which is
equivalent to a tree structure for the represented data (with
<code>employee</code> as the root). This is similar to XDR, ASN.1, and NDR&apos;s
ability to represent compound types, but in a format that can be both
processed by programs and read by humans. More importantly, programs
such as parsers can be used across different XML-based languages,
because the definitions of those languages are themselves expressed as
machine-readable data that can be input to the programs.</p>
<pre><code class="lang-xml"><span class="php"><span class="hljs-meta">&lt;?</span>xml version=<span class="hljs-string">&quot;1.0&quot;</span><span class="hljs-meta">?&gt;</span></span>
<span class="hljs-tag">&lt;<span class="hljs-name">employee</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>John Doe<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Head Bottle Washer<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>123456789<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">hiredate</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">day</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">day</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">month</span>&gt;</span>June<span class="hljs-tag">&lt;/<span class="hljs-name">month</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">year</span>&gt;</span>1986<span class="hljs-tag">&lt;/<span class="hljs-name">year</span>&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">hiredate</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">employee</span>&gt;</span>
</code></pre>
<p>Although the markup and the data in this document are highly suggestive
to the human reader, it is the definition of the employee record
language that actually determines what tags are legal, what they mean,
and what data types they imply. Without some formal definition of the
tags, a human reader (or a computer) can&apos;t tell whether <code>1986</code> in the
<code>year</code> field, for example, is a string, an integer, an unsigned
integer, or a floating point number.</p>
<p>The definition of a specific XML-based language is given by a <em>schema</em>,
which is a database term for a specification of how to interpret a
collection of data. Several schema languages have been defined for XML;
we will focus here on the leading standard, known by the
none-too-surprising name <em>XML Schema</em>. An individual schema defined
using XML Schema is known as an <em>XML Schema Document</em> (XSD). The
following is an XSD for the example; in other words, it defines the
language to which the example document conforms. It might be stored in a
file named <code>employee.xsd</code>.</p>
<pre><code class="lang-xml"><span class="php"><span class="hljs-meta">&lt;?</span>xml version=<span class="hljs-string">&quot;1.0&quot;</span><span class="hljs-meta">?&gt;</span></span>
<span class="hljs-tag">&lt;<span class="hljs-name">schema</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">element</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;employee&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">complexType</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">sequence</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">element</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;string&quot;</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">element</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;title&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;string&quot;</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">element</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;string&quot;</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">element</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hiredate&quot;</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">complexType</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">sequence</span>&gt;</span>
              <span class="hljs-tag">&lt;<span class="hljs-name">element</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;day&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;integer&quot;</span>/&gt;</span>
              <span class="hljs-tag">&lt;<span class="hljs-name">element</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;month&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;string&quot;</span>/&gt;</span>
              <span class="hljs-tag">&lt;<span class="hljs-name">element</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;year&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;integer&quot;</span>/&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">sequence</span>&gt;</span>
          <span class="hljs-tag">&lt;/<span class="hljs-name">complexType</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">element</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">sequence</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">complexType</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">element</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">schema</span>&gt;</span>
</code></pre>
<p>This XSD looks superficially similar to our example document
<code>employee.xml</code>, and for good reason: XML Schema is itself an XML-based
language. There is an obvious relationship between this XSD and the
document defined above. For example,</p>
<pre><code class="lang-xml"><span class="hljs-tag">&lt;<span class="hljs-name">element</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;title&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;string&quot;</span>/&gt;</span>
</code></pre>
<p>indicates that the value bracketed by the markup <code>title</code> is to be
interpreted as a string. The sequence and nesting of that line in the
XSD indicate that a <code>title</code> field must be the second item in an
employee record.</p>
<p>Unlike some schema languages, XML Schema provides datatypes such
as string, integer, decimal, and Boolean. It allows the datatypes to be
combined in sequences or nested, as in <code>employee.xsd</code>, to create
compound data types. So an XSD defines more than a syntax; it defines
its own abstract data model. A document that conforms to the XSD
represents a collection of data that conforms to the data model.</p>
<p>The significance of an XSD defining an abstract data model and not just
a syntax is that there can be other ways besides XML of representing
data that conforms to the model. And XML does, after all, have some
shortcomings as an on-the-wire representation: it is not as compact as
other data representations, and it is relatively slow to parse. A number
of alternative representations described as binary are in use. The
International Standards Organization (ISO) has published one called
<em>Fast Infoset</em>, while the World Wide Web Consortium (W3C) has produced
the <em>Efficient XML Interchange</em> (EXI) proposal. Binary representations
sacrifice human readability for greater compactness and faster parsing.</p>
<h3 id="xml-namespaces">XML Namespaces</h3>
<p>XML has to solve a common problem, that of name clashes. The problem
arises because schema languages such as XML Schema support modularity in
the sense that a schema can be reused as part of another schema. Suppose
two XSDs are defined independently, and both happen to define the markup
name <em>idNumber</em>. Perhaps one XSD uses that name to identify employees of
a company, and the other XSD uses it to identify laptop computers owned
by the company. We might like to reuse those two XSDs in a third XSD for
describing which assets are associated with which employees, but to do
that we need some mechanism for distinguishing employees&apos; idNumbers from
laptop idNumbers.</p>
<p>XML&apos;s solution to this problem is <em>XML namespaces</em>. A namespace is a
collection of names. Each XML namespace is identified by a Uniform
Resource Identifier (URI). URIs will be described in some detail in a
later chapter; for now, all you really need to know is that URIs are a
form of globally unique identifier. (An HTTP URL is a particular type
of UNI.) A simple markup name like
<em>idNumber</em> can be added to a namespace as long as it is unique within
that namespace. Since the namespace is globally unique and the simple
name is unique within the namespace, the combination of the two is a
globally unique <em>qualified name</em> that cannot clash.</p>
<p>An XSD usually specifies a <em>target namespace</em> with a line like the
following:</p>
<pre><code class="lang-xml">targetNamespace=&quot;http://www.example.com/employee&quot;
</code></pre>
<p>is a Uniform Resource Identifier, identifying a made-up namespace. All
the new markup defined in that XSD will belong to that namespace.</p>
<p>Now, if an XSD wants to reference names that have been defined in other
XSDs, it can do so by qualifying those names with a namespace prefix.
This prefix is a short abbreviation for the full URI that actually
identifies the namespace. For example, the following line assigns
<code>emp</code> as the namespace prefix for the employee namespace:</p>
<pre><code class="lang-xml">xmlns:emp=&quot;http://www.example.com/employee&quot;
</code></pre>
<p>Any markup from that namespace would be qualified by prefixing it with
<code>emp:</code> , as is <code>title</code> in the following line:</p>
<pre><code class="lang-xml"><span class="hljs-tag">&lt;<span class="hljs-name">emp:title</span>&gt;</span>Head Bottle Washer<span class="hljs-tag">&lt;/<span class="hljs-name">emp:title</span>&gt;</span>
</code></pre>
<p>In other words, <code>emp:title</code> is a qualified name, which will not clash
with the name <code>title</code> from some other namespace.</p>
<p>It is remarkable how widely XML is now used in applications that range
from RPC-style communication among Web-based services to office
productivity tools to instant messaging. It is certainly one of the
core protocols on which the upper layers of the Internet now depend.</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="problem.html" class="navigation navigation-prev " aria-label="Previous page: Chapter 7: End-to-End Data">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="multimedia.html" class="navigation navigation-next " aria-label="Next page: 7.2 Multimedia Data">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"7.1 Presentation Formatting","level":"1.8.1","depth":2,"next":{"title":"7.2 Multimedia Data","level":"1.8.2","depth":2,"path":"data/multimedia.md","ref":"data/multimedia.md","articles":[]},"previous":{"title":"Chapter 7: End-to-End Data","level":"1.8","depth":1,"path":"data/problem.md","ref":"data/problem.md","articles":[{"title":"7.1 Presentation Formatting","level":"1.8.1","depth":2,"path":"data/presentation.md","ref":"data/presentation.md","articles":[]},{"title":"7.2 Multimedia Data","level":"1.8.2","depth":2,"path":"data/multimedia.md","ref":"data/multimedia.md","articles":[]},{"title":"7.3 Summary","level":"1.8.3","depth":2,"path":"data/summary.md","ref":"data/summary.md","articles":[]}]},"dir":"ltr"},"config":{"plugins":["anchorjs","katex","block-align","sequence-diagrams","creativecommons","custom-favicon","smart-nav-collapse"],"root":".","styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css"},"pluginsConfig":{"block-align":{},"search":{},"sequence-diagrams":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"katex":{},"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"favicon":"bridge.ico","custom-favicon":{},"creativecommons":{},"smart-nav-collapse":{},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false},"anchorjs":{}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{"branch":"master"},"title":"Computer Networks: A Systems Approach","gitbook":"*"},"file":{"path":"data/presentation.md","mtime":"2018-09-29T15:18:36.000Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2018-11-30T20:44:28.688Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.1.1/anchor.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-anchorjs/anchor-style.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-smart-nav-collapse/smart-nav-collapse.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

