
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>8.1 Cryptographic Building Blocks Â· Computer Networks: A Systems Approach</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-katex/katex.min.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-block-align/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-smart-nav-collapse/smart-nav-collapse.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
        <link rel="stylesheet" href="../styles/website.css">
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="key-distro.html" />
    
    
    <link rel="prev" href="problem.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Preface
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../foundation/problem.html">
            
                <a href="../foundation/problem.html">
            
                    
                    Chapter 1: Foundation
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="../foundation/applications.html">
            
                <a href="../foundation/applications.html">
            
                    
                    1.1 Applications
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="../foundation/requirements.html">
            
                <a href="../foundation/requirements.html">
            
                    
                    1.2 Requirements
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="../foundation/architecture.html">
            
                <a href="../foundation/architecture.html">
            
                    
                    1.3 Architecture
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.4" data-path="../foundation/software.html">
            
                <a href="../foundation/software.html">
            
                    
                    1.4 Software
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.5" data-path="../foundation/performance.html">
            
                <a href="../foundation/performance.html">
            
                    
                    1.5 Performance
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.6" data-path="../foundation/summary.html">
            
                <a href="../foundation/summary.html">
            
                    
                    1.6 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../direct/problem.html">
            
                <a href="../direct/problem.html">
            
                    
                    Chapter 2: Direct Connections
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="../direct/perspective.html">
            
                <a href="../direct/perspective.html">
            
                    
                    2.1 Technology Landscape
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="../direct/encoding.html">
            
                <a href="../direct/encoding.html">
            
                    
                    2.2 Encoding
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3" data-path="../direct/framing.html">
            
                <a href="../direct/framing.html">
            
                    
                    2.3 Framing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4" data-path="../direct/error.html">
            
                <a href="../direct/error.html">
            
                    
                    2.4 Error Detection
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.5" data-path="../direct/reliable.html">
            
                <a href="../direct/reliable.html">
            
                    
                    2.5 Reliable Transmission
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.6" data-path="../direct/ethernet.html">
            
                <a href="../direct/ethernet.html">
            
                    
                    2.6 Multi-Access Networks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.7" data-path="../direct/wireless.html">
            
                <a href="../direct/wireless.html">
            
                    
                    2.7 Wireless Networks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.8" data-path="../direct/access.html">
            
                <a href="../direct/access.html">
            
                    
                    2.8 Access Networks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.9" data-path="../direct/summary.html">
            
                <a href="../direct/summary.html">
            
                    
                    2.9 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="../internetworking/problem.html">
            
                <a href="../internetworking/problem.html">
            
                    
                    Chapter 3: Internetworking
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="../internetworking/switching.html">
            
                <a href="../internetworking/switching.html">
            
                    
                    3.1 Switching and Bridging
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="../internetworking/basic-ip.html">
            
                <a href="../internetworking/basic-ip.html">
            
                    
                    3.2 Basic Internetworking
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3" data-path="../internetworking/routing.html">
            
                <a href="../internetworking/routing.html">
            
                    
                    3.3 Routing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4" data-path="../internetworking/impl.html">
            
                <a href="../internetworking/impl.html">
            
                    
                    3.4 Implementation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.5" data-path="../internetworking/summary.html">
            
                <a href="../internetworking/summary.html">
            
                    
                    3.5 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="../scaling/problem.html">
            
                <a href="../scaling/problem.html">
            
                    
                    Chapter 4: Advanced Internetworking
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.1" data-path="../scaling/global.html">
            
                <a href="../scaling/global.html">
            
                    
                    4.1 Global Internet
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.2" data-path="../scaling/multicast.html">
            
                <a href="../scaling/multicast.html">
            
                    
                    4.2 Multicast
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.3" data-path="../scaling/mpls.html">
            
                <a href="../scaling/mpls.html">
            
                    
                    4.3 Multiprotocol Label Switching
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.4" data-path="../scaling/mobile-ip.html">
            
                <a href="../scaling/mobile-ip.html">
            
                    
                    4.4 Routing Among Mobile Devices
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.5" data-path="../scaling/summary.html">
            
                <a href="../scaling/summary.html">
            
                    
                    4.5 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="../e2e/problem.html">
            
                <a href="../e2e/problem.html">
            
                    
                    Chapter 5: End-to-End Protocols
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.6.1" data-path="../e2e/udp.html">
            
                <a href="../e2e/udp.html">
            
                    
                    5.1 Simple Demultiplexor (UDP)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2" data-path="../e2e/tcp.html">
            
                <a href="../e2e/tcp.html">
            
                    
                    5.2 Reliable Byte Stream (TCP)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.3" data-path="../e2e/rpc.html">
            
                <a href="../e2e/rpc.html">
            
                    
                    5.3 Remote Procedure Call
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.4" data-path="../e2e/rtp.html">
            
                <a href="../e2e/rtp.html">
            
                    
                    5.4 Transport for Real-Time Applications (RTP)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.5" data-path="../e2e/summary.html">
            
                <a href="../e2e/summary.html">
            
                    
                    5.5 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="../congestion/problem.html">
            
                <a href="../congestion/problem.html">
            
                    
                    Chapter 6: Congestion Control and Resource Allocation
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.1" data-path="../congestion/issues.html">
            
                <a href="../congestion/issues.html">
            
                    
                    6.1 Issues in Resource Allocation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.2" data-path="../congestion/queuing.html">
            
                <a href="../congestion/queuing.html">
            
                    
                    6.2 Queuing Disciplines
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.3" data-path="../congestion/tcpcc.html">
            
                <a href="../congestion/tcpcc.html">
            
                    
                    6.3 TCP Congestion Control
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4" data-path="../congestion/avoidance.html">
            
                <a href="../congestion/avoidance.html">
            
                    
                    6.4 Congestion-Avoidance Mechanisms
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.5" data-path="../congestion/qos.html">
            
                <a href="../congestion/qos.html">
            
                    
                    6.5 Quality of Service
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.6" data-path="../congestion/summary.html">
            
                <a href="../congestion/summary.html">
            
                    
                    6.6 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="../data/problem.html">
            
                <a href="../data/problem.html">
            
                    
                    Chapter 7: End-to-End Data
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.8.1" data-path="../data/presentation.html">
            
                <a href="../data/presentation.html">
            
                    
                    7.1 Presentation Formatting
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.2" data-path="../data/multimedia.html">
            
                <a href="../data/multimedia.html">
            
                    
                    7.2 Multimedia Data
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.3" data-path="../data/summary.html">
            
                <a href="../data/summary.html">
            
                    
                    7.3 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="problem.html">
            
                <a href="problem.html">
            
                    
                    Chapter 8: Network Security
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter active" data-level="1.9.1" data-path="crypto.html">
            
                <a href="crypto.html">
            
                    
                    8.1 Cryptographic Building Blocks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2" data-path="key-distro.html">
            
                <a href="key-distro.html">
            
                    
                    8.2 Key Predistribution
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.3" data-path="authentication.html">
            
                <a href="authentication.html">
            
                    
                    8.3 Authentication Protocols
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.4" data-path="systems.html">
            
                <a href="systems.html">
            
                    
                    8.4 Example Systems
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.5" data-path="summary.html">
            
                <a href="summary.html">
            
                    
                    8.5 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="../applications/problem.html">
            
                <a href="../applications/problem.html">
            
                    
                    Chapter 9: Applications
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.10.1" data-path="../applications/traditional.html">
            
                <a href="../applications/traditional.html">
            
                    
                    9.1 Traditional Applications
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.2" data-path="../applications/multimedia.html">
            
                <a href="../applications/multimedia.html">
            
                    
                    9.2 Multimedia Applications
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.3" data-path="../applications/infrastructure.html">
            
                <a href="../applications/infrastructure.html">
            
                    
                    9.3 Infrastructure Applications
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.4" data-path="../applications/overlays.html">
            
                <a href="../applications/overlays.html">
            
                    
                    9.4 Overlay Networks
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.5" data-path="../applications/summary.html">
            
                <a href="../applications/summary.html">
            
                    
                    9.5 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >8.1 Cryptographic Building Blocks</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="81-cryptographic-building-blocks">8.1 Cryptographic Building Blocks</h1>
<p>We introduce the concepts of cryptography-based security step by step.
The first step is the cryptographic algorithms&#x2014;ciphers and
cryptographic hashes&#x2014;that are introduced in this section. They are not
a solution in themselves, but rather building blocks from which a
solution can be built. Cryptographic algorithms are parameterized by
<em>keys</em>, and a later section then addresses the problem of distributing
the keys. In the next step, we describe how to incorporate the
cryptographic building blocks into protocols that provide secure
communication between participants who possess the correct keys. A final
section then examines several complete security protocols and systems in
current use.</p>
<h2 id="principles-of-ciphers">Principles of Ciphers</h2>
<p>Encryption transforms a message in such a way that it becomes
unintelligible to any party that does not have the secret of how to
reverse the transformation. The sender applies an <em>encryption</em> function
to the original <em>plaintext</em> message, resulting in a <em>ciphertext</em> message
that is sent over the network, as shown in <a href="#genericCrypto">Figure 1</a>.
The receiver applies a secret <em>decryption</em> function&#x2014;the inverse of the
encryption function&#x2014;to recover the original plaintext. The ciphertext
transmitted across the network is unintelligible to any eavesdropper,
assuming the eavesdropper doesn&apos;t know the decryption function. The
transformation represented by an encryption function and its
corresponding decryption function is called a <em>cipher</em>.</p>
<figure class="line">
    <a id="genericCrypto"></a>
    <img src="figures/f08-01-9780123850591.png" width="500px">
    <figcaption>Symmetric-key encryption and decryption.</figcaption>
</figure>

<p>Cryptographers have been led to the principle, first stated in 1883,
that encryption and decryption functions should be parameterized by a
<em>key</em>, and furthermore that the functions should be considered public
knowledge&#x2014;only the key need be secret. Thus, the ciphertext produced
for a given plaintext message depends on both the encryption function
and the key. One reason for this principle is that if you depend on the
cipher being kept secret, then you have to retire the cipher (not just
the keys) when you believe it is no longer secret. This means
potentially frequent changes of cipher, which is problematic since it
takes a lot of work to develop a new cipher. Also, one of the best ways
to know that a cipher is secure is to use it for a long time&#x2014;if no one
breaks it, it&apos;s probably secure. (Fortunately, there are plenty of
people who will try to break ciphers and who will let it be widely known
when they have succeeded, so no news is generally good news.) Thus,
there is considerable cost and risk in deploying a new cipher. Finally,
parameterizing a cipher with keys provides us with what is in effect a
very large family of ciphers; by switching keys, we essentially switch
ciphers, thereby limiting the amount of data that a <em>cryptanalyst</em>
(code-breaker) can use to try to break our key/cipher and the amount she
can read if she succeeds.</p>
<p>The basic requirement for an encryption algorithm is that it turn
plaintext into ciphertext in such a way that only the intended
recipient&#x2014;the holder of the decryption key&#x2014;can recover the
plaintext. What this means is that encrypted messages cannot be read by
people who do not hold the key.</p>
<p>It is important to realize that when a potential attacker receives a
piece of ciphertext, he may have more information at his disposal than
just the ciphertext itself. For example, he may know that the plaintext
was written in English, which means that the letter <em>e</em> occurs more
often in the plaintext that any other letter; the frequency of many
other letters and common letter combinations can also be predicted. This
information can greatly simplify the task of finding the key. Similarly,
he may know something about the likely contents of the message; for
example, the word &quot;login&quot; is likely to occur at the start of a remote
login session. This may enable a <em>known plaintext</em> attack, which has a
much higher chance of success than a <em>ciphertext only</em> attack. Even
better is a <em>chosen plaintext</em> attack, which may be enabled by feeding
some information to the sender that you know the sender is likely to
transmit&#x2014;such things have happened in wartime, for example.</p>
<p>The best cryptographic algorithms, therefore, can prevent the attacker
from deducing the key even when the individual knows both the plaintext
and the ciphertext. This leaves the attacker with no choice but to try
all the possible keys&#x2014;exhaustive, &quot;brute force&quot; search. If keys have
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span> bits, then there are 2<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow></mrow><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.664392em;"></span><span class="strut bottom" style="height:0.664392em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span></span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathit mtight">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span>&#x200B;</span></span></span></span></span></span></span> possible values for a key (each of the
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span> bits could be either a zero or a one). An attacker could be so lucky
as to try the correct value immediately, or so unlucky as to try every
incorrect value before finally trying the correct value of the key,
having tried all 2<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow></mrow><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.664392em;"></span><span class="strut bottom" style="height:0.664392em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span></span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathit mtight">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span>&#x200B;</span></span></span></span></span></span></span> possible values; the average number of guesses to
discover the correct value is halfway between those extremes, 2<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow></mrow><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.664392em;"></span><span class="strut bottom" style="height:0.664392em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span></span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathit mtight">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span>&#x200B;</span></span></span></span></span></span></span>/2.
This can be made computationally impractical by choosing a sufficiently
large key space and by making the operation of checking a key reasonably
costly. What makes this difficult is that computing speeds keep
increasing, making formerly infeasible computations feasible.
Furthermore, although we are concentrating on the security of data as it
moves through the network&#x2014;that is, the data is sometimes vulnerable
for only a short period of time&#x2014;in general, security people have to
consider the vulnerability of data that needs to be stored in archives
for tens of years. This argues for a generously large key size. On the
other hand, larger keys make encryption and decryption slower.</p>
<p>Most ciphers are <em>block ciphers</em>; they are defined to take as input a
plaintext block of a certain fixed size, typically 64 to 128 bits. Using
a block cipher to encrypt each block independently&#x2014;known as
<em>electronic codebook (ECB) mode</em> encryption&#x2014;has the weakness that a
given plaintext block value will always result in the same ciphertext
block. Hence, recurring block values in the plaintext are recognizable
as such in the ciphertext, making it much easier for a cryptanalyst to
break the cipher.</p>
<p>To prevent this, block ciphers are always augmented to make the
ciphertext for a block vary depending on context. Ways in which a block
cipher may be augmented are called <em>modes of operation</em>. A common mode
of operation is <em>cipher block chaining</em> (CBC), in which each plaintext
block is XORed with the previous block&apos;s ciphertext before being
encrypted. The result is that each block&apos;s ciphertext depends in part on
the preceding blocks (i.e., on its context). Since the first plaintext
block has no preceding block, it is XORed with a random number. That
random number, called an <em>initialization vector</em> (IV), is included with
the series of ciphertext blocks so that the first ciphertext block can
be decrypted. This mode is illustrated in <a href="#cbc">Figure 2</a>. Another
mode of operation is <em>counter mode</em>, in which successive values of a
counter (e.g., 1, 2, 3, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&#x2026;</mo></mrow><annotation encoding="application/x-tex">\ldots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.12em;"></span><span class="strut bottom" style="height:0.12em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="minner">&#x2026;</span></span></span></span>) are incorporated into the encryption
of successive blocks of plaintext.</p>
<figure class="line">
    <a id="cbc"></a>
    <img src="figures/f08-02-9780123850591.png" width="500px">
    <figcaption>Cipher Block Chaining.</figcaption>
</figure>

<h2 id="symmetric-key-ciphers">Symmetric-Key Ciphers</h2>
<p>In a symmetric-key cipher, both participants in a communication
share the same key. In other words, if a message is encrypted using a
particular key, the same key is required for decrypting the message. If
the cipher illustrated in <a href="#genericCrypto">Figure 1</a> were a
symmetric-key cipher, then the encryption and decryption keys would be
identical. Symmetric-key ciphers are also known as secret-key ciphers
since the shared key must be known only to the participants. (We&apos;ll take
a look at the alternative, public-key ciphers, shortly.)</p>
<blockquote>
<p>We use the term <em>participant</em> for the parties involved in a secure 
communication since that is the term we have been using throughout 
the book to identify the two endpoints of a channel. In the security 
world, they are typically called <em>principals</em>. </p>
</blockquote>
<p>The U.S. National Institute of Standards and Technology (NIST) has
issued standards for a series of symmetric-key ciphers. <em>Data Encryption
Standard</em> (DES) was the first, and it has stood the test of time in that
no cryptanalytic attack better than brute force search has been
discovered. Brute force search, however, has gotten faster. DES&apos;s keys
(56 independent bits) are now too small given current processor speeds.
DES keys have 56 independent bits (although they have 64 bits in total;
the last bit of every byte is a parity bit). As noted above, you would,
on average, have to search half of the space of 2<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow></mrow><mrow><mn>5</mn><mn>6</mn></mrow></msup></mrow><annotation encoding="application/x-tex">^{56}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span></span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathrm mtight">5</span><span class="mord mathrm mtight">6</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span>&#x200B;</span></span></span></span></span></span></span> possible keys
to find the right one, giving 2<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow></mrow><mrow><mn>5</mn><mn>5</mn></mrow></msup></mrow><annotation encoding="application/x-tex">^{55}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span></span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathrm mtight">5</span><span class="mord mathrm mtight">5</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span>&#x200B;</span></span></span></span></span></span></span> = 3.6 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&#xD7;</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.58333em;"></span><span class="strut bottom" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord">&#xD7;</span></span></span></span> 10<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow></mrow><mrow><mn>1</mn><mn>6</mn></mrow></msup></mrow><annotation encoding="application/x-tex">^{16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span></span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathrm mtight">1</span><span class="mord mathrm mtight">6</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span>&#x200B;</span></span></span></span></span></span></span>
keys. That may sound like a lot, but such a search is highly parallelizable,
so it&apos;s possible to throw as many computers at the task as you can get your
hands on&#x2014;and these days it&apos;s easy to lay your hands on thousands of
computers (Amazon.com will rent them to you for a few cents an hour, for
example). By the late 1990s, it was already possible to recover a DES
key after a few hours. Consequently, NIST updated the DES standard in
1999 to indicate that DES should only be used for legacy systems.</p>
<p>NIST also standardized the cipher <em>Triple DES</em> (3DES), which leverages
the cryptanalysis resistance of DES while in effect increasing the key
size. A 3DES key has 168 (= 3 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&#xD7;</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.58333em;"></span><span class="strut bottom" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord">&#xD7;</span></span></span></span> 56)
independent bits, and is used as three DES keys; let&apos;s call them
DES-key1, DES-key2, and DES-key3. 3DES encryption of a block is
performed by first DES encrypting the block using DES-key1, then DES
<em>de</em>crypting the result using DES-key2, and finally DES encrypting that
result using DES-key3. Decryption involves decrypting using DES-key3,
then encrypting using DES-key2, then decrypting using DES-key1.</p>
<blockquote>
<p>The reason 3DES encryption uses DES <em>de</em>cryption with DES-key2 is 
to interoperate with legacy DES systems. If a legacy DES system uses 
a single key, then a 3DES system can perform the same encryption 
function by using that key for each of DES-key1, DES-key2, and 
DES-key3; in the first two steps, we encrypt and then decrypt with 
the same key, producing the original plaintext, which we then 
encrypt again.</p>
</blockquote>
<p>Although 3DES solves DES&apos;s key-length problem, it inherits some other
shortcomings. Software implementations of DES/3DES are slow because it
was originally designed, by IBM, for implementation in hardware. Also,
DES/3DES uses a 64-bit block size; a larger block size is more efficient
and more secure.</p>
<p>3DES is being superseded by the <em>Advanced Encryption Standard</em> (AES)
standard issued by NIST in 2001. The cipher selected to become that
standard (with a few minor modifications) was originally named Rijndael
(pronounced roughly like &quot;Rhine dahl&quot;) based on the names of its
inventors, Daemen and Rijmen. AES supports key lengths of 128, 192, or
256 bits, and the block length is 128 bits. AES permits fast
implementations in both software and hardware. It doesn&apos;t require much
memory, which makes it suitable for small mobile devices. AES has some
mathematically proven security properties and, as of the time of
writing, has not suffered from any significant successful attacks.</p>
<blockquote>
<p>Since anything that can recover the plaintext with less 
computational effort than sheer brute force is technically 
classified as an attack, there are some forms of attack on AES that 
have been published. While they do somewhat better than brute force,
they remain computationally very expensive. </p>
</blockquote>
<h2 id="public-key-ciphers">Public-Key Ciphers</h2>
<p>An alternative to symmetric-key ciphers is asymmetric, or public-key,
ciphers. Instead of a single key shared by two participants, a
public-key cipher uses a pair of related keys, one for encryption and a
different one for decryption. The pair of keys is &quot;owned&quot; by just one
participant. The owner keeps the decryption key secret so that only the
owner can decrypt messages; that key is called the <em>private key</em>. The
owner makes the encryption key public, so that anyone can encrypt
messages for the owner; that key is called the <em>public key</em>. Obviously,
for such a scheme to work, it must not be possible to deduce the private
key from the public key. Consequently, any participant can get the
public key and send an encrypted message to the owner of the keys, and
only the owner has the private key necessary to decrypt it. This
scenario is depicted in <a href="#public">Figure 3</a>.</p>
<figure class="line">
    <a id="public"></a>
    <img src="figures/f08-03-9780123850591.png" width="500px">
    <figcaption>Public-key encryption.</figcaption>
</figure>

<p>Because it is somewhat unintuitive, we emphasize that the public
encryption key is useless for decrypting a message&#x2014;you couldn&apos;t even
decrypt a message that you yourself had just encrypted unless you had
the private decryption key. If we think of keys as defining a
communication channel between participants, then another difference
between public-key and symmetric-key ciphers is the topology of the
channels. A key for a symmetric-key cipher provides a channel that is
two-way between two participants&#x2014;each participant holds the same
(symmetric) key that either one can use to encrypt or decrypt messages
in either direction. A public/private key pair, in contrast, provides a
channel that is one way and many to one from everyone who has the public
key to the (unique) owner of the private key, as illustrated in
<a href="#public">Figure 3</a>.</p>
<p>An important additional property of public-key ciphers is that the
private &quot;decryption&quot; key can be used with the encryption algorithm to
encrypt messages so that they can only be decrypted using the public
&quot;encryption&quot; key. This property clearly wouldn&apos;t be useful for
confidentiality since anyone with the public key could decrypt such a
message. (Indeed, for two-way confidentiality between two participants,
each participant needs its own pair of keys, and each encrypts messages
using the other&apos;s public key.) This property is, however, useful for
authentication since it tells the receiver of such a message that it
could only have been created by the owner of the keys (subject to
certain assumptions that we will get into later). This is illustrated in
<a href="#pksign">Figure 4</a>. It should be clear from the figure that anyone
with the public key can decrypt the encrypted message, and, assuming
that the result of the decryption matches the expected result, it can be
concluded that the private key must have been used to perform the
encryption. Exactly how this operation is used to provide authentication
is the topic of a later section. As we will see, public-key ciphers are
used primarily for authentication and to confidentially distribute
symmetric keys, leaving the rest of confidentiality to symmetric-key
ciphers.</p>
<figure class="line">
    <a id="pksign"></a>
    <img src="figures/f08-04-9780123850591.png" width="500px">
    <figcaption>Authentication using public keys.</figcaption>
</figure>

<p>A bit of interesting history: The concept of public-key ciphers was
first published in 1976 by Diffie and Hellman. Subsequently, however,
documents have come to light proving that Britain&apos;s
Communications-Electronics Security Group had discovered public-key
ciphers by 1970, and the U.S. National Security Agency (NSA) claims to
have discovered them in the mid-1960s.</p>
<p>The best-known public-key cipher is RSA, named after its inventors:
Rivest, Shamir, and Adleman. RSA relies on the high computational cost
of factoring large numbers. The problem of finding an efficient way to
factor numbers is one that mathematicians have worked on unsuccessfully
since long before RSA appeared in 1978, and RSA&apos;s subsequent resistance
to cryptanalysis has further bolstered confidence in its security.
Unfortunately, RSA needs relatively large keys, at least 1024 bits, to
be secure. This is larger than keys for symmetric-key ciphers because it
is faster to break an RSA private key by factoring the large number on
which the pair of keys is based than by exhaustively searching the key
space.</p>
<p>Another public-key cipher is ElGamal. Like RSA, it relies on a
mathematical problem, the discrete logarithm problem, for which no
efficient solution has been found, and requires keys of at least 1024
bits. There is a variation of the discrete logarithm problem, arising
when the input is an elliptic curve, that is thought to be even more
difficult to compute; cryptographic schemes based on this problem are
referred to as <em>elliptic curve cryptography</em>.</p>
<p>Public-key ciphers are, unfortunately, several orders of magnitude
slower than symmetric-key ciphers. Consequently, symmetric-key ciphers
are used for the vast majority of encryption, while public-key ciphers
are reserved for use in authentication and session key establishment.</p>
<h2 id="authenticators">Authenticators</h2>
<p>Encryption alone does not provide data integrity. For example, just
randomly modifying a ciphertext message could turn it into something
that decrypts into valid-looking plaintext, in which case the tampering
would be undetectable by the receiver. Nor does encryption alone provide
authentication. It is not much use to say that a message came from a
certain participant if the contents of the message have been modified
after that participant created it. In a sense, integrity and
authentication are fundamentally inseparable.</p>
<p>An <em>authenticator</em> is a value, to be included in a transmitted message,
that can be used to verify simultaneously the authenticity and the data
integrity of a message. We will see how authenticators can be used in
protocols. For now, we focus on the algorithms that produce
authenticators.</p>
<p>You should recall that in earlier chapters we looked at checksums and
cyclic redundancy checks (CRCs)&#x2014;added pieces of information sent with
the original message&#x2014;as ways of detecting when a message has been
inadvertently modified by bit errors. A similar concept applies to
authenticators, with the added challenge that the corruption of the
message is likely to be deliberately performed by someone who wants the
corruption to go undetected. To support authentication, an authenticator
includes some proof that whoever created the authenticator knows a
secret that is known only to the alleged sender of the message; for
example, the secret could be a key, and the proof could be some value
encrypted using the key. There is a mutual dependency between the form
of the redundant information and the form of the proof of secret
knowledge. We discuss several workable combinations.</p>
<p>We initially assume that the original message need not be
confidential&#x2014;that a transmitted message will consist of the plaintext
of the original message plus an authenticator. Later we will consider
the case where confidentiality is desired.</p>
<p>One kind of authenticator combines encryption and a <em>cryptographic hash
function</em>. Cryptographic hash algorithms are treated as public
knowledge, as with cipher algorithms. A cryptographic hash function
(also known as a <em>cryptographic checksum</em>) is a function that outputs
sufficient redundant information about a message to expose any
tampering. Just as a checksum or CRC exposes bit errors introduced by
noisy links, a cryptographic checksum is designed to expose deliberate
corruption of messages by an adversary. The value it outputs is called a
<em>message digest</em> and, like an ordinary checksum, is appended to the
message. All the message digests produced by a given hash have the same
number of bits regardless of the length of the original message. Since
the space of possible input messages is larger than the space of
possible message digests, there will be different input messages that
produce the same message digest, like collisions in a hash table.</p>
<p>An authenticator can be created by encrypting the message digest. The
receiver computes a digest of the plaintext part of the message and
compares that to the decrypted message digest. If they are equal, then
the receiver would conclude that the message is indeed from its alleged
sender (since it would have to have been encrypted with the right key)
and has not been tampered with. No adversary could get away with sending
a bogus message with a matching bogus digest because she would not have
the key to encrypt the bogus digest correctly. An adversary could,
however, obtain the plaintext original message and its encrypted digest
by eavesdropping. The adversary could then (since the hash function is
public knowledge) compute the digest of the original message and
generate alternative messages looking for one with the same message
digest. If she finds one, she could undetectably send the new message
with the old authenticator. Therefore, security requires that the hash
function have the <em>one-way</em> property: It must be computationally
infeasible for an adversary to find any plaintext message that has the
same digest as the original.</p>
<p>For a hash function to meet this requirement, its outputs must be fairly
randomly distributed. For example, if digests are 128 bits long and
randomly distributed, then you would need to try 2<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow></mrow><mrow><mn>1</mn><mn>2</mn><mn>7</mn></mrow></msup></mrow><annotation encoding="application/x-tex">^{127}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span></span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathrm mtight">1</span><span class="mord mathrm mtight">2</span><span class="mord mathrm mtight">7</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span>&#x200B;</span></span></span></span></span></span></span> messages, on
average, before finding a second message whose digest matches that of a
given message. If the outputs are not randomly distributed&#x2014;that is, if
some outputs are much more likely than others&#x2014;then for some messages
you could find another message with the same digest much more easily
than this, which would reduce the security of the algorithm. If you were
instead just trying to find any <em>collision</em>&#x2014;any two messages that
produce the same digest&#x2014;then you would need to compute the digests of
only 2<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow></mrow><mrow><mn>6</mn><mn>4</mn></mrow></msup></mrow><annotation encoding="application/x-tex">^{64}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span></span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathrm mtight">6</span><span class="mord mathrm mtight">4</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span>&#x200B;</span></span></span></span></span></span></span> messages, on average. This surprising fact is the basis of
the &quot;birthday attack&quot;&#x2014;see the exercises for more details.</p>
<p>There are several common cryptographic hash algorithms, including
Message Digest 5 (MD5) and Secure Hash Algorithm 1 (SHA-1). MD5 outputs
a 128-bit digest, and SHA-1 outputs a 160-bit digest. Weaknesses of MD5
have been known for some time, which led to recommendations to shift
from MD5 to SHA-1. More recently, researchers have discovered techniques
that find SHA-1 collisions somewhat more efficiently than brute force,
but they are not yet computationally feasible. Although <em>collision
attacks</em> (attacks based on finding any collision) are not as great a
risk as <em>preimage attacks</em> (attacks based on finding a second message
that collides with a given first message), these are nonetheless serious
weaknesses. NIST recommended phasing out SHA-1 by 2010, in favor of four
variants of SHA that are collectively known as SHA-2. There is an
ongoing competition to devise a new hash known as SHA-3.</p>
<p>When generating an encrypted message digest, the digest encryption could
use either a symmetric-key cipher or a public-key cipher. If a
public-key cipher is used, the digest would be encrypted using the
sender&apos;s private key (the one we normally think of as being used for
decryption), and the receiver&#x2014;or anyone else&#x2014;could decrypt the
digest using the sender&apos;s public key.</p>
<p>A digest encrypted with a public key algorithm but using the private key
is called a <em>digital signature</em> because it provides nonrepudiation like
a written signature. The receiver of a message with a digital signature
can prove to any third party that the sender really sent that message,
because the third party can use the sender&apos;s public key to check for
herself. (Symmetric-key encryption of a digest does not have this
property because only the two participants know the key; furthermore,
since both participants know the key, the alleged receiver could have
created the message herself.) Any public-key cipher can be used for
digital signatures. <em>Digital Signature Standard</em> (DSS) is a digital
signature format that has been standardized by NIST. DSS signatures may
use any one of three public-key ciphers, one based on RSA, another on
ElGamal, and a third called the <em>Elliptic Curve Digital Signature
Algorithm</em>.</p>
<p>Another kind of authenticator is similar, but instead of encrypting a
hash it uses a hash-like function that takes a secret value (known to
only the sender and the receiver) as a parameter, as illustrated in
<a href="#macAndHmac">Figure 5</a>. Such a function outputs an authenticator
called a <em>message authentication code</em> (MAC). The sender appends the MAC
to her plaintext message. The receiver recomputes the MAC using the
plaintext and the secret value and compares that recomputed MAC to the
received MAC.</p>
<figure class="line">
    <a id="macAndHmac"></a>
    <img src="figures/f08-05-9780123850591.png" width="600px">
    <figcaption>Computing a MAC (a) versus computing an HMAC (b).</figcaption>
</figure>

<p>A common variation on MACs is to apply a cryptographic hash (such as MD5
or SHA-1) to the concatenation of the plaintext message and the secret
value, as illustrated in <a href="#macAndHmac">Figure 5</a>. The resulting digest
is called a <em>hashed message authentication code</em> (HMAC) since it is
essentially a MAC. The HMAC, but not the secret value, is appended to
the plaintext Only a receiver who knows the secret value can compute the
correct HMAC to compare with the received HMAC. If it weren&apos;t for the
one-way property of the hash, an adversary might be able to find the
input that generated the HMAC and compare it to the plaintext message to
determine the secret value.</p>
<p>Up to this point, we have been assuming that the message wasn&apos;t
confidential, so the original message could be transmitted as plaintext.
To add confidentiality to a message with an authenticator, it suffices
to encrypt the concatenation of the entire message including its
authenticator&#x2014;the MAC, HMAC, or encrypted digest. Remember that, in
practice, confidentiality is implemented using symmetric-key ciphers
because they are so much faster than public-key ciphers. Furthermore, it
costs little to include the authenticator in the encryption, and it
increases security. A common simplification is to encrypt the message
with its (raw) digest, such that the digest is only encrypted once; in
this case, the entire ciphertext message is considered to be an
authenticator.</p>
<p>Although authenticators may seem to solve the authentication problem, we
will see in a later section that they are only the foundation of a
solution. First, however, we address the issue of how participants
obtain keys in the first place.</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="problem.html" class="navigation navigation-prev " aria-label="Previous page: Chapter 8: Network Security">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="key-distro.html" class="navigation navigation-next " aria-label="Next page: 8.2 Key Predistribution">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"8.1 Cryptographic Building Blocks","level":"1.9.1","depth":2,"next":{"title":"8.2 Key Predistribution","level":"1.9.2","depth":2,"path":"security/key-distro.md","ref":"security/key-distro.md","articles":[]},"previous":{"title":"Chapter 8: Network Security","level":"1.9","depth":1,"path":"security/problem.md","ref":"security/problem.md","articles":[{"title":"8.1 Cryptographic Building Blocks","level":"1.9.1","depth":2,"path":"security/crypto.md","ref":"security/crypto.md","articles":[]},{"title":"8.2 Key Predistribution","level":"1.9.2","depth":2,"path":"security/key-distro.md","ref":"security/key-distro.md","articles":[]},{"title":"8.3 Authentication Protocols","level":"1.9.3","depth":2,"path":"security/authentication.md","ref":"security/authentication.md","articles":[]},{"title":"8.4 Example Systems","level":"1.9.4","depth":2,"path":"security/systems.md","ref":"security/systems.md","articles":[]},{"title":"8.5 Summary","level":"1.9.5","depth":2,"path":"security/summary.md","ref":"security/summary.md","articles":[]}]},"dir":"ltr"},"config":{"plugins":["anchorjs","katex","block-align","sequence-diagrams","creativecommons","custom-favicon","smart-nav-collapse"],"root":".","styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css"},"pluginsConfig":{"block-align":{},"search":{},"sequence-diagrams":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"katex":{},"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"favicon":"bridge.ico","custom-favicon":{},"creativecommons":{},"smart-nav-collapse":{},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false},"anchorjs":{}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{"branch":"master"},"title":"Computer Networks: A Systems Approach","gitbook":"*"},"file":{"path":"security/crypto.md","mtime":"2018-08-15T22:11:03.000Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2018-09-10T22:04:53.604Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.1.1/anchor.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-anchorjs/anchor-style.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-smart-nav-collapse/smart-nav-collapse.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

