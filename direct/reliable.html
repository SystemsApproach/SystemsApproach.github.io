

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>2.5 Reliable Transmission &mdash; Computer Networks: A Systems Approach Version 6.1-dev documentation</title>
  

  
  
    <link rel="shortcut icon" href="../static/bridge.ico"/>
  
  
  

  
  <script type="text/javascript" src="../static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../static/documentation_options.js"></script>
        <script type="text/javascript" src="../static/jquery.js"></script>
        <script type="text/javascript" src="../static/underscore.js"></script>
        <script type="text/javascript" src="../static/doctools.js"></script>
        <script type="text/javascript" src="../static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../static/css/rtd_theme_mods.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="2.6 Multi-Access Networks" href="ethernet.html" />
    <link rel="prev" title="2.4 Error Detection" href="error.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Computer Networks: A Systems Approach
          

          
          </a>

          
            
            
              <div class="version">
                Version 6.1-dev
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Table of Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../preface.html">Preface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../foundation.html">Chapter 1:  Foundation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../direct.html">Chapter 2:  Direct Links</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="problem.html">Problem: Connecting to a Network</a></li>
<li class="toctree-l2"><a class="reference internal" href="perspective.html">2.1 Technology Landscape</a></li>
<li class="toctree-l2"><a class="reference internal" href="encoding.html">2.2 Encoding</a></li>
<li class="toctree-l2"><a class="reference internal" href="framing.html">2.3 Framing</a></li>
<li class="toctree-l2"><a class="reference internal" href="error.html">2.4 Error Detection</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">2.5 Reliable Transmission</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#stop-and-wait">Stop-and-Wait</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sliding-window">Sliding Window</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#the-sliding-window-algorithm">The Sliding Window Algorithm</a></li>
<li class="toctree-l4"><a class="reference internal" href="#finite-sequence-numbers-and-sliding-window">Finite Sequence Numbers and Sliding Window</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implementation-of-sliding-window">Implementation of Sliding Window</a></li>
<li class="toctree-l4"><a class="reference internal" href="#frame-order-and-flow-control">Frame Order and Flow Control</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#concurrent-logical-channels">Concurrent Logical Channels</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ethernet.html">2.6 Multi-Access Networks</a></li>
<li class="toctree-l2"><a class="reference internal" href="wireless.html">2.7 Wireless Networks</a></li>
<li class="toctree-l2"><a class="reference internal" href="access.html">2.8 Access Networks</a></li>
<li class="toctree-l2"><a class="reference internal" href="trend.html">Perspective: Race to the Edge</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../internetworking.html">Chapter 3:  Internetworking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scaling.html">Chapter 4:  Advanced Internetworking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../e2e.html">Chapter 5:  End-to-End Protocols</a></li>
<li class="toctree-l1"><a class="reference internal" href="../congestion.html">Chapter 6:  Congestion Control</a></li>
<li class="toctree-l1"><a class="reference internal" href="../data.html">Chapter 7: End-to-End Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security.html">Chapter 8: Network Security</a></li>
<li class="toctree-l1"><a class="reference internal" href="../applications.html">Chapter 9: Applications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../README.html">About This Book</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Computer Networks: A Systems Approach</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../direct.html">Chapter 2:  Direct Links</a> &raquo;</li>
        
      <li>2.5 Reliable Transmission</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/direct/reliable.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="reliable-transmission">
<h1>2.5 Reliable Transmission<a class="headerlink" href="#reliable-transmission" title="Permalink to this headline">¶</a></h1>
<p>As we saw in the previous section, frames are sometimes corrupted while
in transit, with an error code like CRC used to detect such errors.
While some error codes are strong enough also to correct errors, in
practice the overhead is typically too large to handle the range of bit
and burst errors that can be introduced on a network link. Even when
error-correcting codes are used (e.g., on wireless links) some errors
will be too severe to be corrected. As a result, some corrupt frames
must be discarded. A link-level protocol that wants to deliver frames
reliably must somehow recover from these discarded (lost) frames.</p>
<p>It’s worth noting that reliability is a function that <em>may</em> be provided
at the link level, but many modern link technologies omit this function.
Furthermore, reliable delivery is frequently provided at higher levels,
including both transport and sometimes, the application layer. Exactly
where it should be provided is a matter of some debate and depends on
many factors. We describe the basics of reliable delivery here, since
the principles are common across layers, but you should be aware that
we’re not just talking about a link-layer function.</p>
<p>Reliable delivery is usually accomplished using a combination of two
fundamental mechanisms—<em>acknowledgments</em> and <em>timeouts</em>. An
acknowledgment (ACK for short) is a small control frame that a protocol
sends back to its peer saying that it has received an earlier frame. By
control frame we mean a header without any data, although a protocol can
<em>piggyback</em> an ACK on a data frame it just happens to be sending in the
opposite direction. The receipt of an acknowledgment indicates to the
sender of the original frame that its frame was successfully delivered.
If the sender does not receive an acknowledgment after a reasonable
amount of time, then it <em>retransmits</em> the original frame. This action of
waiting a reasonable amount of time is called a <em>timeout</em>.</p>
<p>The general strategy of using acknowledgments and timeouts to implement
reliable delivery is sometimes called <em>automatic repeat request</em>
(abbreviated ARQ). This section describes three different ARQ algorithms
using generic language; that is, we do not give detailed information
about a particular protocol’s header fields.</p>
<div class="section" id="stop-and-wait">
<h2>Stop-and-Wait<a class="headerlink" href="#stop-and-wait" title="Permalink to this headline">¶</a></h2>
<p>The simplest ARQ scheme is the <em>stop-and-wait</em> algorithm. The idea of
stop-and-wait is straightforward: After transmitting one frame, the
sender waits for an acknowledgment before transmitting the next frame.
If the acknowledgment does not arrive after a certain period of time,
the sender times out and retransmits the original frame.</p>
<div class="figure align-center" id="id1">
<span id="fig-ack-timeout"></span><a class="reference internal image-reference" href="../_images/f02-17-9780123850591.png"><img alt="../_images/f02-17-9780123850591.png" src="../_images/f02-17-9780123850591.png" style="width: 500px;" /></a>
<p class="caption"><span class="caption-number">Figure 34. </span><span class="caption-text">Timeline showing four different scenarios for the
stop-and-wait algorithm. (a)&nbsp;The ACK is received before the timer
expires; (b)&nbsp;the original frame is lost; (c)&nbsp;the ACK is lost;
(d)&nbsp;the timeout fires too soon.</span></p>
</div>
<p><a class="reference internal" href="#fig-ack-timeout"><span class="std std-numref">Figure 34</span></a> illustrates timelines for four
different scenarios that result from this basic algorithm. The sending
side is represented on the left, the receiving side is depicted on the
right, and time flows from top to bottom. <a class="reference internal" href="#fig-ack-timeout"><span class="std std-numref">Figure 34(a)</span></a> shows the situation in which the ACK is received
before the timer expires; (b) and (c) show the situation in which the
original frame and the ACK, respectively, are lost; and (d) shows the
situation in which the timeout fires too soon. Recall that by “lost”
we mean that the frame was corrupted while in transit, that this
corruption was detected by an error code on the receiver, and that the
frame was subsequently discarded.</p>
<p>The packet timelines shown in this section are examples of a frequently
used tool in teaching, explaining, and designing protocols. They are
useful because they capture visually the behavior over time of a
distributed system—something that can be quite hard to analyze. When
designing a protocol, you often have to be prepared for the unexpected—a
system crashes, a message gets lost, or something that you expected to
happen quickly turns out to take a long time. These sorts of diagrams
can often help us understand what might go wrong in such cases and thus
help a protocol designer be prepared for every eventuality.</p>
<p>There is one important subtlety in the stop-and-wait
algorithm. Suppose the sender sends a frame and the receiver
acknowledges it, but the acknowledgment is either lost or delayed in
arriving. This situation is illustrated in timelines (c) and (d) of
<a class="reference internal" href="#fig-ack-timeout"><span class="std std-numref">Figure 34</span></a>. In both cases, the sender times
out and retransmits the original frame, but the receiver will think
that it is the next frame, since it correctly received and
acknowledged the first frame. This has the potential to cause
duplicate copies of a frame to be delivered. To address this problem,
the header for a stop-and-wait protocol usually includes a 1-bit
sequence number—that is, the sequence number can take on the values 0
and 1—and the sequence numbers used for each frame alternate, as
illustrated in <a class="reference internal" href="#fig-stop-wait"><span class="std std-numref">Figure 35</span></a>. Thus, when the
sender retransmits frame 0, the receiver can determine that it is
seeing a second copy of frame 0 rather than the first copy of frame 1
and therefore can ignore it (the receiver still acknowledges it, in
case the first ACK was lost).</p>
<div class="figure align-center" id="id2">
<span id="fig-stop-wait"></span><a class="reference internal image-reference" href="../_images/f02-18-9780123850591.png"><img alt="../_images/f02-18-9780123850591.png" src="../_images/f02-18-9780123850591.png" style="width: 250px;" /></a>
<p class="caption"><span class="caption-number">Figure 35. </span><span class="caption-text">Timeline for stop-and-wait with 1-bit sequence
number.</span></p>
</div>
<p>The main shortcoming of the stop-and-wait algorithm is that it allows
the sender to have only one outstanding frame on the link at a time, and
this may be far below the link’s capacity. Consider, for example, a
1.5-Mbps link with a 45-ms round-trip time. This link has a delay ×
bandwidth product of 67.5&nbsp;Kb, or approximately 8&nbsp;KB. Since the sender
can send only one frame per RTT, and assuming a frame size of 1&nbsp;KB, this
implies a maximum sending rate of</p>
<p class="centered">
<strong>Bits-Per-Frame / Time-Per-Frame = 1024 x 8 / 0.045 = 182 kbps</strong></p><p>or about one-eighth of the link’s capacity. To use the link fully, then,
we’d like the sender to be able to transmit up to eight frames before
having to wait for an acknowledgment.</p>
<div class="admonition-key-takeaway admonition">
<p class="first admonition-title">Key Takeaway</p>
<p class="last">The significance of the delay × bandwidth product is that it
represents the amount of data that could be in transit. We would like
to be able to send this much data without waiting for the first
acknowledgment. The principle at work here is often referred to as
<em>keeping the pipe full</em>. The algorithms presented in the following
two subsections do exactly this.</p>
</div>
</div>
<div class="section" id="sliding-window">
<h2>Sliding Window<a class="headerlink" href="#sliding-window" title="Permalink to this headline">¶</a></h2>
<p>Consider again the scenario in which the link has a delay × bandwidth
product of 8&nbsp;KB and frames are 1&nbsp;KB in size. We would like the sender to
be ready to transmit the ninth frame at pretty much the same moment that
the ACK for the first frame arrives. The algorithm that allows us to do
this is called <em>sliding window</em>, and an illustrative timeline is given
in <a class="reference internal" href="#fig-slide-win"><span class="std std-numref">Figure 36</span></a>.</p>
<div class="figure align-center" id="id3">
<span id="fig-slide-win"></span><a class="reference internal image-reference" href="../_images/f02-19-9780123850591.png"><img alt="../_images/f02-19-9780123850591.png" src="../_images/f02-19-9780123850591.png" style="width: 250px;" /></a>
<p class="caption"><span class="caption-number">Figure 36. </span><span class="caption-text">Timeline for the sliding window algorithm.</span></p>
</div>
<div class="section" id="the-sliding-window-algorithm">
<h3>The Sliding Window Algorithm<a class="headerlink" href="#the-sliding-window-algorithm" title="Permalink to this headline">¶</a></h3>
<p>The sliding window algorithm works as follows. First, the sender assigns
a <em>sequence number</em>, denoted <code class="docutils literal notranslate"><span class="pre">SeqNum</span></code>, to each frame. For now, let’s
ignore the fact that <code class="docutils literal notranslate"><span class="pre">SeqNum</span></code> is implemented by a finite-size header
field and instead assume that it can grow infinitely large. The sender
maintains three variables: The <em>send window size</em>, denoted <code class="docutils literal notranslate"><span class="pre">SWS</span></code>,
gives the upper bound on the number of outstanding (unacknowledged)
frames that the sender can transmit; <code class="docutils literal notranslate"><span class="pre">LAR</span></code> denotes the sequence number
of the <em>last acknowledgment received</em>; and <code class="docutils literal notranslate"><span class="pre">LFS</span></code> denotes the sequence
number of the <em>last frame sent</em>. The sender also maintains the following
invariant:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">LFS</span> <span class="o">-</span> <span class="n">LAR</span> <span class="o">&lt;=</span> <span class="n">SWS</span>
</pre></div>
</div>
<p>This situation is illustrated in <a class="reference internal" href="#fig-sw-sender"><span class="std std-numref">Figure 37</span></a>.</p>
<div class="figure align-center" id="id4">
<span id="fig-sw-sender"></span><a class="reference internal image-reference" href="../_images/f02-20-9780123850591.png"><img alt="../_images/f02-20-9780123850591.png" src="../_images/f02-20-9780123850591.png" style="width: 400px;" /></a>
<p class="caption"><span class="caption-number">Figure 37. </span><span class="caption-text">Sliding window on sender.</span></p>
</div>
<p>When an acknowledgment arrives, the sender moves <code class="docutils literal notranslate"><span class="pre">LAR</span></code> to the right,
thereby allowing the sender to transmit another frame. Also, the sender
associates a timer with each frame it transmits, and it retransmits the
frame should the timer expire before an ACK is received. Notice that the
sender has to be willing to buffer up to <code class="docutils literal notranslate"><span class="pre">SWS</span></code> frames since it must be
prepared to retransmit them until they are acknowledged.</p>
<p>The receiver maintains the following three variables: The <em>receive
window size</em>, denoted <code class="docutils literal notranslate"><span class="pre">RWS</span></code>, gives the upper bound on the number of
out-of-order frames that the receiver is willing to accept; <code class="docutils literal notranslate"><span class="pre">LAF</span></code>
denotes the sequence number of the <em>largest acceptable frame</em>; and
<code class="docutils literal notranslate"><span class="pre">LFR</span></code> denotes the sequence number of the <em>last frame received</em>. The
receiver also maintains the following invariant:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">LAF</span> <span class="o">-</span> <span class="n">LFR</span> <span class="o">&lt;=</span> <span class="n">RWS</span>
</pre></div>
</div>
<p>This situation is illustrated in <a class="reference internal" href="#fig-sw-rcvr"><span class="std std-numref">Figure 38</span></a>.</p>
<div class="figure align-center" id="id5">
<span id="fig-sw-rcvr"></span><a class="reference internal image-reference" href="../_images/f02-21-9780123850591.png"><img alt="../_images/f02-21-9780123850591.png" src="../_images/f02-21-9780123850591.png" style="width: 400px;" /></a>
<p class="caption"><span class="caption-number">Figure 38. </span><span class="caption-text">Sliding window on receiver.</span></p>
</div>
<p>When a frame with sequence number <code class="docutils literal notranslate"><span class="pre">SeqNum</span></code> arrives, the receiver takes
the following action. If <code class="docutils literal notranslate"><span class="pre">SeqNum</span> <span class="pre">&lt;=</span> <span class="pre">LFR</span></code> or <code class="docutils literal notranslate"><span class="pre">SeqNum</span> <span class="pre">&gt;</span> <span class="pre">LAF</span></code>, then the
frame is outside the receiver’s window and it is discarded. If
<code class="docutils literal notranslate"><span class="pre">LFR</span> <span class="pre">&lt;</span> <span class="pre">SeqNum</span> <span class="pre">&lt;=</span> <span class="pre">LAF</span></code>, then the frame is within the receiver’s window
and it is accepted. Now the receiver needs to decide whether or not to
send an ACK. Let <code class="docutils literal notranslate"><span class="pre">SeqNumToAck</span></code> denote the largest sequence number not
yet acknowledged, such that all frames with sequence numbers less than
or equal to <code class="docutils literal notranslate"><span class="pre">SeqNumToAck</span></code> have been received. The receiver
acknowledges the receipt of <code class="docutils literal notranslate"><span class="pre">SeqNumToAck</span></code>, even if higher numbered
packets have been received. This acknowledgment is said to be
cumulative. It then sets <code class="docutils literal notranslate"><span class="pre">LFR</span> <span class="pre">=</span> <span class="pre">SeqNumToAck</span></code> and adjusts
<code class="docutils literal notranslate"><span class="pre">LAF</span> <span class="pre">=</span> <span class="pre">LFR</span> <span class="pre">+</span> <span class="pre">RWS</span></code>.</p>
<p>For example, suppose <code class="docutils literal notranslate"><span class="pre">LFR</span> <span class="pre">=</span> <span class="pre">5</span></code> (i.e., the last ACK the receiver sent
was for sequence number 5), and <code class="docutils literal notranslate"><span class="pre">RWS</span> <span class="pre">=</span> <span class="pre">4</span></code>. This implies that
<code class="docutils literal notranslate"><span class="pre">LAF</span> <span class="pre">=</span> <span class="pre">9</span></code>. Should frames&nbsp;7 and 8 arrive, they will be buffered because
they are within the receiver’s window. However, no ACK needs to be sent
since frame&nbsp;6 has yet to arrive. Frames&nbsp;7 and 8 are said to have arrived
out of order. (Technically, the receiver could resend an ACK for frame&nbsp;5
when frames&nbsp;7 and 8 arrive.) Should frame&nbsp;6 then arrive—perhaps it is
late because it was lost the first time and had to be retransmitted, or
perhaps it was simply delayed—the receiver acknowledges frame&nbsp;8, bumps
<code class="docutils literal notranslate"><span class="pre">LFR</span></code> to 8, and sets <code class="docutils literal notranslate"><span class="pre">LAF</span></code> to 12. If frame&nbsp;6 was in fact lost, then
a timeout will have occurred at the sender, causing it to retransmit
frame&nbsp;6.</p>
<blockquote>
<div>It’s unlikely that a packet could be delayed on a point-to-point
link, this same algorithm is used on multi-hop connections where such
delays are possible.</div></blockquote>
<p>We observe that when a timeout occurs, the amount of data in transit
decreases, since the sender is unable to advance its window until
frame&nbsp;6 is acknowledged. This means that when packet losses occur, this
scheme is no longer keeping the pipe full. The longer it takes to notice
that a packet loss has occurred, the more severe this problem becomes.</p>
<p>Notice that, in this example, the receiver could have sent a <em>negative
acknowledgment</em> (NAK) for frame&nbsp;6 as soon as frame 7 arrived. However,
this is unnecessary since the sender’s timeout mechanism is sufficient
to catch this situation, and sending NAKs adds additional complexity to
the receiver. Also, as we mentioned, it would have been legitimate to
send additional acknowledgments of frame&nbsp;5 when frames&nbsp;7 and 8 arrived;
in some cases, a sender can use duplicate ACKs as a clue that a frame
was lost. Both approaches help to improve performance by allowing early
detection of packet losses.</p>
<p>Yet another variation on this scheme would be to use <em>selective
acknowledgments</em>. That is, the receiver could acknowledge exactly those
frames it has received rather than just the highest numbered frame
received in order. So, in the above example, the receiver could
acknowledge the receipt of frames&nbsp;7 and 8. Giving more information to
the sender makes it potentially easier for the sender to keep the pipe
full but adds complexity to the implementation.</p>
<p>The sending window size is selected according to how many frames we want
to have outstanding on the link at a given time; <code class="docutils literal notranslate"><span class="pre">SWS</span></code> is easy to
compute for a given delay × bandwidth product. On the other hand, the
receiver can set <code class="docutils literal notranslate"><span class="pre">RWS</span></code> to whatever it wants. Two common settings are
<code class="docutils literal notranslate"><span class="pre">RWS</span> <span class="pre">=</span> <span class="pre">1</span></code>, which implies that the receiver will not buffer any frames
that arrive out of order, and <code class="docutils literal notranslate"><span class="pre">RWS</span> <span class="pre">=</span> <span class="pre">SWS</span></code>, which implies that the
receiver can buffer any of the frames the sender transmits. It makes no
sense to set <code class="docutils literal notranslate"><span class="pre">RWS</span> <span class="pre">&gt;</span> <span class="pre">SWS</span></code> since it’s impossible for more than <code class="docutils literal notranslate"><span class="pre">SWS</span></code>
frames to arrive out of order.</p>
</div>
<div class="section" id="finite-sequence-numbers-and-sliding-window">
<h3>Finite Sequence Numbers and Sliding Window<a class="headerlink" href="#finite-sequence-numbers-and-sliding-window" title="Permalink to this headline">¶</a></h3>
<p>We now return to the one simplification we introduced into the
algorithm—our assumption that sequence numbers can grow infinitely
large. In practice, of course, a frame’s sequence number is specified in
a header field of some finite size. For example, a 3-bit field means
that there are eight possible sequence numbers, 0..7. This makes it
necessary to reuse sequence numbers or, stated another way, sequence
numbers wrap around. This introduces the problem of being able to
distinguish between different incarnations of the same sequence numbers,
which implies that the number of possible sequence numbers must be
larger than the number of outstanding frames allowed. For example,
stop-and-wait allowed one outstanding frame at a time and had two
distinct sequence numbers.</p>
<p>Suppose we have one more number in our space of sequence numbers than we
have potentially outstanding frames; that is, <code class="docutils literal notranslate"><span class="pre">SWS</span> <span class="pre">&lt;=</span> <span class="pre">MaxSeqNum</span> <span class="pre">-</span> <span class="pre">1</span></code>,
where <code class="docutils literal notranslate"><span class="pre">MaxSeqNum</span></code> is the number of available sequence numbers. Is this
sufficient? The answer depends on <code class="docutils literal notranslate"><span class="pre">RWS</span></code>. If <code class="docutils literal notranslate"><span class="pre">RWS</span> <span class="pre">=</span>&#160; <span class="pre">1</span></code>, then
<code class="docutils literal notranslate"><span class="pre">MaxSeqNum</span> <span class="pre">&gt;=</span> <span class="pre">SWS</span> <span class="pre">+</span> <span class="pre">1</span></code> is sufficient. If <code class="docutils literal notranslate"><span class="pre">RWS</span></code> is equal to <code class="docutils literal notranslate"><span class="pre">SWS</span></code>,
then having a <code class="docutils literal notranslate"><span class="pre">MaxSeqNum</span></code> just one greater than the sending window
size is not good enough. To see this, consider the situation in which we
have the eight sequence numbers 0 through 7, and <code class="docutils literal notranslate"><span class="pre">SWS</span> <span class="pre">=</span> <span class="pre">RWS</span> <span class="pre">=</span> <span class="pre">7</span></code>.
Suppose the sender transmits frames&nbsp;0..6, they are successfully
received, but the ACKs are lost. The receiver is now expecting frames&nbsp;7,
0..5, but the sender times out and sends frames&nbsp;0..6. Unfortunately, the
receiver is expecting the second incarnation of frames 0..5 but gets the
first incarnation of these frames. This is exactly the situation we
wanted to avoid.</p>
<p>It turns out that the sending window size can be no more than half as
big as the number of available sequence numbers when <code class="docutils literal notranslate"><span class="pre">RWS</span> <span class="pre">=</span> <span class="pre">SWS</span></code>, or
stated more precisely,</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">SWS</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">MaxSeqNum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span> <span class="mi">2</span>
</pre></div>
</div>
<p>Intuitively, what this is saying is that the sliding window protocol
alternates between the two halves of the sequence number space, just as
stop-and-wait alternates between sequence numbers 0 and 1. The only
difference is that it continually slides between the two halves rather
than discretely alternating between them.</p>
<p>Note that this rule is specific to the situation where <code class="docutils literal notranslate"><span class="pre">RWS</span> <span class="pre">=</span> <span class="pre">SWS</span></code>. We
leave it as an exercise to determine the more general rule that works
for arbitrary values of <code class="docutils literal notranslate"><span class="pre">RWS</span></code> and <code class="docutils literal notranslate"><span class="pre">SWS</span></code>. Also note that the
relationship between the window size and the sequence number space
depends on an assumption that is so obvious that it is easy to overlook,
namely that frames are not reordered in transit. This cannot happen on a
direct point-to-point link since there is no way for one frame to
overtake another during transmission. However, we will see the sliding
window algorithm used in a different environments, and we will need to
devise another rule.</p>
</div>
<div class="section" id="implementation-of-sliding-window">
<h3>Implementation of Sliding Window<a class="headerlink" href="#implementation-of-sliding-window" title="Permalink to this headline">¶</a></h3>
<p>The following routines illustrate how we might implement the sending and
receiving sides of the sliding window algorithm. The routines are taken
from a working protocol named, appropriately enough, Sliding Window
Protocol (SWP). So as not to concern ourselves with the adjacent
protocols in the protocol graph, we denote the protocol sitting above
SWP as the high-level protocol (HLP) and the protocol sitting below SWP
as the link-level protocol (LLP).</p>
<p>We start by defining a pair of data structures. First, the frame header
is very simple: It contains a sequence number (<code class="docutils literal notranslate"><span class="pre">SeqNum</span></code>) and an
acknowledgment number (<code class="docutils literal notranslate"><span class="pre">AckNum</span></code>). It also contains a <code class="docutils literal notranslate"><span class="pre">Flags</span></code> field
that indicates whether the frame is an ACK or carries data.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="n">u_char</span> <span class="n">SwpSeqno</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">SwpSeqno</span>   <span class="n">SeqNum</span><span class="p">;</span>   <span class="cm">/* sequence number of this frame */</span>
    <span class="n">SwpSeqno</span>   <span class="n">AckNum</span><span class="p">;</span>   <span class="cm">/* ack of received frame */</span>
    <span class="n">u_char</span>     <span class="n">Flags</span><span class="p">;</span>           <span class="cm">/* up to 8 bits worth of flags */</span>
<span class="p">}</span> <span class="n">SwpHdr</span><span class="p">;</span>
</pre></div>
</div>
<p>Next, the state of the sliding window algorithm has the following
structure. For the sending side of the protocol, this state includes
variables <code class="docutils literal notranslate"><span class="pre">LAR</span></code> and <code class="docutils literal notranslate"><span class="pre">LFS</span></code>, as described earlier in this section, as
well as a queue that holds frames that have been transmitted but not yet
acknowledged (<code class="docutils literal notranslate"><span class="pre">sendQ</span></code>). The sending state also includes a <em>counting
semaphore</em> called <code class="docutils literal notranslate"><span class="pre">sendWindowNotFull</span></code>. We will see how this is used
below, but generally a semaphore is a synchronization primitive that
supports <code class="docutils literal notranslate"><span class="pre">semWait</span></code> and <code class="docutils literal notranslate"><span class="pre">semSignal</span></code> operations. Every invocation of
<code class="docutils literal notranslate"><span class="pre">semSignal</span></code> increments the semaphore by 1, and every invocation of
<code class="docutils literal notranslate"><span class="pre">semWait</span></code> decrements <code class="docutils literal notranslate"><span class="pre">s</span></code> by 1, with the calling process blocked
(suspended) should decrementing the semaphore cause its value to become
less than 0. A process that is blocked during its call to <code class="docutils literal notranslate"><span class="pre">semWait</span></code>
will be allowed to resume as soon as enough <code class="docutils literal notranslate"><span class="pre">semSignal</span></code> operations
have been performed to raise the value of the semaphore above&nbsp;0.</p>
<p>For the receiving side of the protocol, the state includes the variable
<code class="docutils literal notranslate"><span class="pre">NFE</span></code>. This is the <em>next frame expected</em>, the frame with a sequence
number one more that the last frame received (LFR), described earlier in
this section. There is also a queue that holds frames that have been
received out of order (<code class="docutils literal notranslate"><span class="pre">recvQ</span></code>). Finally, although not shown, the
sender and receiver sliding window sizes are defined by constants
<code class="docutils literal notranslate"><span class="pre">SWS</span></code> and <code class="docutils literal notranslate"><span class="pre">RWS</span></code>, respectively.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="cm">/* sender side state: */</span>
    <span class="n">SwpSeqno</span>    <span class="n">LAR</span><span class="p">;</span>        <span class="cm">/* seqno of last ACK received */</span>
    <span class="n">SwpSeqno</span>    <span class="n">LFS</span><span class="p">;</span>        <span class="cm">/* last frame sent */</span>
    <span class="n">Semaphore</span>   <span class="n">sendWindowNotFull</span><span class="p">;</span>
    <span class="n">SwpHdr</span>      <span class="n">hdr</span><span class="p">;</span>        <span class="cm">/* pre-initialized header */</span>
    <span class="k">struct</span> <span class="n">sendQ_slot</span> <span class="p">{</span>
        <span class="n">Event</span>   <span class="n">timeout</span><span class="p">;</span>    <span class="cm">/* event associated with send-timeout */</span>
        <span class="n">Msg</span>     <span class="n">msg</span><span class="p">;</span>
    <span class="p">}</span>   <span class="n">sendQ</span><span class="p">[</span><span class="n">SWS</span><span class="p">];</span>

    <span class="cm">/* receiver side state: */</span>
    <span class="n">SwpSeqno</span>    <span class="n">NFE</span><span class="p">;</span>       <span class="cm">/* seqno of next frame expected */</span>
    <span class="k">struct</span> <span class="n">recvQ_slot</span> <span class="p">{</span>
        <span class="kt">int</span>     <span class="n">received</span><span class="p">;</span>  <span class="cm">/* is msg valid? */</span>
        <span class="n">Msg</span>     <span class="n">msg</span><span class="p">;</span>
    <span class="p">}</span>   <span class="n">recvQ</span><span class="p">[</span><span class="n">RWS</span><span class="p">];</span>
<span class="p">}</span> <span class="n">SwpState</span><span class="p">;</span>
</pre></div>
</div>
<p>The sending side of SWP is implemented by procedure <code class="docutils literal notranslate"><span class="pre">sendSWP</span></code>. This
routine is rather simple. First, <code class="docutils literal notranslate"><span class="pre">semWait</span></code> causes this process to
block on a semaphore until it is OK to send another frame. Once allowed
to proceed, <code class="docutils literal notranslate"><span class="pre">sendSWP</span></code> sets the sequence number in the frame’s header,
saves a copy of the frame in the transmit queue (<code class="docutils literal notranslate"><span class="pre">sendQ</span></code>), schedules a
timeout event to handle the case in which the frame is not acknowledged,
and sends the frame to the next-lower-level protocol, which we denote as
<code class="docutils literal notranslate"><span class="pre">LINK</span></code>.</p>
<p>One detail worth noting is the call to <code class="docutils literal notranslate"><span class="pre">store_swp_hdr</span></code> just before the
call to <code class="docutils literal notranslate"><span class="pre">msgAddHdr</span></code>. This routine translates the C structure that
holds the SWP header (<code class="docutils literal notranslate"><span class="pre">state-&gt;hdr</span></code>) into a byte string that can be
safely attached&nbsp;to the front of the message (<code class="docutils literal notranslate"><span class="pre">hbuf</span></code>). This routine
(not shown) must translate each integer field in the header into network
byte order and remove any padding that the compiler has added to the C
structure. The issue of byte order is a non-trivial issue, but for now
it is enough to assume that this routine places the most significant bit
of a multiword integer in the byte with the highest address.</p>
<p>Another piece of complexity in this routine is the use of <code class="docutils literal notranslate"><span class="pre">semWait</span></code>
and the <code class="docutils literal notranslate"><span class="pre">sendWindowNotFull</span></code> semaphore. <code class="docutils literal notranslate"><span class="pre">sendWindowNotFull</span></code> is
initialized to the size of the sender’s sliding window, <code class="docutils literal notranslate"><span class="pre">SWS</span></code> (this
initialization is not shown). Each time the sender transmits a frame,
the <code class="docutils literal notranslate"><span class="pre">semWait</span></code> operation decrements this count and blocks the sender
should the count go to 0. Each time an ACK is received, the
<code class="docutils literal notranslate"><span class="pre">semSignal</span></code> operation invoked in <code class="docutils literal notranslate"><span class="pre">deliverSWP</span></code> (see below) increments
this count, thus unblocking any waiting sender.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span>
<span class="nf">sendSWP</span><span class="p">(</span><span class="n">SwpState</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span> <span class="n">Msg</span> <span class="o">*</span><span class="n">frame</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">sendQ_slot</span> <span class="o">*</span><span class="n">slot</span><span class="p">;</span>
    <span class="n">hbuf</span><span class="p">[</span><span class="n">HLEN</span><span class="p">];</span>

    <span class="cm">/* wait for send window to open */</span>
    <span class="n">semWait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">sendWindowNotFull</span><span class="p">);</span>
    <span class="n">state</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">SeqNum</span> <span class="o">=</span> <span class="o">++</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">LFS</span><span class="p">;</span>
    <span class="n">slot</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">sendQ</span><span class="p">[</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">SeqNum</span> <span class="o">%</span> <span class="n">SWS</span><span class="p">];</span>
    <span class="n">store_swp_hdr</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">,</span> <span class="n">hbuf</span><span class="p">);</span>
    <span class="n">msgAddHdr</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">hbuf</span><span class="p">,</span> <span class="n">HLEN</span><span class="p">);</span>
    <span class="n">msgSaveCopy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slot</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">,</span> <span class="n">frame</span><span class="p">);</span>
    <span class="n">slot</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">evSchedule</span><span class="p">(</span><span class="n">swpTimeout</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">SWP_SEND_TIMEOUT</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">send</span><span class="p">(</span><span class="n">LINK</span><span class="p">,</span> <span class="n">frame</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Before continuing to the receive side of SWP, we need to reconcile a
seeming inconsistency. On the one hand, we have been saying that a
high-level protocol invokes the services of a low-level protocol by
calling the <code class="docutils literal notranslate"><span class="pre">send</span></code> operation, so we would expect that a protocol that
wants to send a message via SWP would call <code class="docutils literal notranslate"><span class="pre">send(SWP,</span> <span class="pre">packet)</span></code>. On the
other hand, the procedure that implements SWP’s send operation is called
<code class="docutils literal notranslate"><span class="pre">sendSWP</span></code>, and its first argument is a state variable (<code class="docutils literal notranslate"><span class="pre">SwpState</span></code>).
What gives? The answer is that the operating system provides glue code
that translates the generic call to <code class="docutils literal notranslate"><span class="pre">send</span></code> into a protocol-specific
call to <code class="docutils literal notranslate"><span class="pre">sendSWP</span></code>. This glue code maps the first argument to <code class="docutils literal notranslate"><span class="pre">send</span></code>
(the magic protocol variable <code class="docutils literal notranslate"><span class="pre">SWP</span></code>) into both a function pointer to
<code class="docutils literal notranslate"><span class="pre">sendSWP</span></code> and a pointer to the protocol state that SWP needs to do its
job. The reason we have the high-level protocol indirectly invoke the
protocol-specific function through the generic function call is that we
want to limit how much information the high-level protocol has coded in
it about the low-level protocol. This makes it easier to change the
protocol graph configuration at some time in the future.</p>
<p>Now we move on to SWP’s protocol-specific implementation of the
<code class="docutils literal notranslate"><span class="pre">deliver</span></code> operation, which is given in procedure <code class="docutils literal notranslate"><span class="pre">deliverSWP</span></code>. This
routine actually handles two different kinds of incoming messages: ACKs
for frames sent earlier from this node and data frames arriving at this
node. In a sense, the ACK half of this routine is the counterpart to the
sender side of the algorithm given in <code class="docutils literal notranslate"><span class="pre">sendSWP</span></code>. A decision as to
whether the incoming message is an ACK or a data frame is made by
checking the <code class="docutils literal notranslate"><span class="pre">Flags</span></code> field in the header. Note that this particular
implementation does not support piggybacking ACKs on data frames.</p>
<p>When the incoming frame is an ACK, <code class="docutils literal notranslate"><span class="pre">deliverSWP</span></code> simply finds the slot
in the transmit queue (<code class="docutils literal notranslate"><span class="pre">sendQ</span></code>) that corresponds to the ACK, cancels
the timeout event, and frees the frame saved in that slot. This work is
actually done in a loop since the ACK may be cumulative. The only other
thing to notice about this case is the call to subroutine
<code class="docutils literal notranslate"><span class="pre">swpInWindow</span></code>. This subroutine, which is given below, ensures that the
sequence number for the frame being acknowledged is within the range of
ACKs that the sender currently expects to receive.</p>
<p>When the incoming frame contains data, <code class="docutils literal notranslate"><span class="pre">deliverSWP</span></code> first calls
<code class="docutils literal notranslate"><span class="pre">msgStripHdr</span></code> and <code class="docutils literal notranslate"><span class="pre">load_swp_hdr</span></code> to extract the header from the
frame. Routine <code class="docutils literal notranslate"><span class="pre">load_swp_hdr</span></code> is the counterpart to <code class="docutils literal notranslate"><span class="pre">store_swp_hdr</span></code>
discussed earlier; it translates a byte string into the C data structure
that holds the SWP header. <code class="docutils literal notranslate"><span class="pre">deliverSWP</span></code> then calls <code class="docutils literal notranslate"><span class="pre">swpInWindow</span></code> to
make sure the sequence number of the frame is within the range of
sequence numbers that it expects. If it is, the routine loops over the
set of consecutive frames it has received and passes them up to the
higher-level protocol by invoking the <code class="docutils literal notranslate"><span class="pre">deliverHLP</span></code> routine. It also
sends a cumulative ACK back to the sender, but does so by looping over
the receive queue (it does not use the <code class="docutils literal notranslate"><span class="pre">SeqNumToAck</span></code> variable used in
the prose description given earlier in this section).</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span>
<span class="nf">deliverSWP</span><span class="p">(</span><span class="n">SwpState</span> <span class="n">state</span><span class="p">,</span> <span class="n">Msg</span> <span class="o">*</span><span class="n">frame</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">SwpHdr</span>   <span class="n">hdr</span><span class="p">;</span>
    <span class="kt">char</span>     <span class="o">*</span><span class="n">hbuf</span><span class="p">;</span>

    <span class="n">hbuf</span> <span class="o">=</span> <span class="n">msgStripHdr</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">HLEN</span><span class="p">);</span>
    <span class="n">load_swp_hdr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hdr</span><span class="p">,</span> <span class="n">hbuf</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">Flags</span> <span class="o">&amp;</span> <span class="n">FLAG_ACK_VALID</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="cm">/* received an acknowledgment—do SENDER side */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">swpInWindow</span><span class="p">(</span><span class="n">hdr</span><span class="p">.</span><span class="n">AckNum</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">LAR</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">LFS</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="k">do</span>
            <span class="p">{</span>
                <span class="k">struct</span> <span class="n">sendQ_slot</span> <span class="o">*</span><span class="n">slot</span><span class="p">;</span>

                <span class="n">slot</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">sendQ</span><span class="p">[</span><span class="o">++</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">LAR</span> <span class="o">%</span> <span class="n">SWS</span><span class="p">];</span>
                <span class="n">evCancel</span><span class="p">(</span><span class="n">slot</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">);</span>
                <span class="n">msgDestroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slot</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">);</span>
                <span class="n">semSignal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">sendWindowNotFull</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">LAR</span> <span class="o">!=</span> <span class="n">hdr</span><span class="p">.</span><span class="n">AckNum</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">hdr</span><span class="p">.</span><span class="n">Flags</span> <span class="o">&amp;</span> <span class="n">FLAG_HAS_DATA</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">struct</span> <span class="n">recvQ_slot</span> <span class="o">*</span><span class="n">slot</span><span class="p">;</span>

        <span class="cm">/* received data packet—do RECEIVER side */</span>
        <span class="n">slot</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">recvQ</span><span class="p">[</span><span class="n">hdr</span><span class="p">.</span><span class="n">SeqNum</span> <span class="o">%</span> <span class="n">RWS</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">swpInWindow</span><span class="p">(</span><span class="n">hdr</span><span class="p">.</span><span class="n">SeqNum</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">NFE</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">NFE</span> <span class="o">+</span> <span class="n">RWS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="cm">/* drop the message */</span>
            <span class="k">return</span> <span class="n">SUCCESS</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">msgSaveCopy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slot</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">,</span> <span class="n">frame</span><span class="p">);</span>
        <span class="n">slot</span><span class="o">-&gt;</span><span class="n">received</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">hdr</span><span class="p">.</span><span class="n">SeqNum</span> <span class="o">==</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">NFE</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Msg</span> <span class="n">m</span><span class="p">;</span>

            <span class="k">while</span> <span class="p">(</span><span class="n">slot</span><span class="o">-&gt;</span><span class="n">received</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">deliver</span><span class="p">(</span><span class="n">HLP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">slot</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">);</span>
                <span class="n">msgDestroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slot</span><span class="o">-&gt;</span><span class="n">msg</span><span class="p">);</span>
                <span class="n">slot</span><span class="o">-&gt;</span><span class="n">received</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
                <span class="n">slot</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">recvQ</span><span class="p">[</span><span class="o">++</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">NFE</span> <span class="o">%</span> <span class="n">RWS</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="cm">/* send ACK: */</span>
            <span class="n">prepare_ack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">NFE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
            <span class="n">send</span><span class="p">(</span><span class="n">LINK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
            <span class="n">msgDestroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Finally,<code class="docutils literal notranslate"><span class="pre">swpInWindow</span></code> is a simple subroutine that checks to see if a
given sequence number falls between some minimum and maximum sequence
number.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">bool</span>
<span class="nf">swpInWindow</span><span class="p">(</span><span class="n">SwpSeqno</span> <span class="n">seqno</span><span class="p">,</span> <span class="n">SwpSeqno</span> <span class="n">min</span><span class="p">,</span> <span class="n">SwpSeqno</span> <span class="n">max</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">SwpSeqno</span> <span class="n">pos</span><span class="p">,</span> <span class="n">maxpos</span><span class="p">;</span>

    <span class="n">pos</span>    <span class="o">=</span> <span class="n">seqno</span> <span class="o">-</span> <span class="n">min</span><span class="p">;</span>       <span class="cm">/* pos *should* be in range [0..MAX) */</span>
    <span class="n">maxpos</span> <span class="o">=</span> <span class="n">max</span> <span class="o">-</span> <span class="n">min</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>     <span class="cm">/* maxpos is in range [0..MAX] */</span>
    <span class="k">return</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="n">maxpos</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="frame-order-and-flow-control">
<h3>Frame Order and Flow Control<a class="headerlink" href="#frame-order-and-flow-control" title="Permalink to this headline">¶</a></h3>
<p>The sliding window protocol is perhaps the best known algorithm in
computer networking. What is easily confused about the algorithm,
however, is that it can be used to serve three different roles. The
first role is the one we have been concentrating on in this section—to
reliably deliver frames across an unreliable link. (In general, the
algorithm can be used to reliably deliver messages across an unreliable
network.) This is the core function of the algorithm.</p>
<p>The second role that the sliding window algorithm can serve is to
preserve the order in which frames are transmitted. This is easy to do
at the receiver—since each frame has a sequence number, the receiver
just makes sure that it does not pass a frame up to the
next-higher-level protocol until it has already passed up all frames
with a smaller sequence number. That is, the receiver buffers (i.e.,
does not pass along) out-of-order frames. The version of the sliding
window algorithm described in this section does preserve frame order,
although we could imagine a variation in which the receiver passes
frames to the next protocol without waiting for all earlier frames to be
delivered. A question we should ask ourselves is whether we really need
the sliding window protocol to keep the frames in order at the link
level, or whether, instead, this functionality should be implemented by
a protocol higher in the stack.</p>
<p>The third role that the sliding window algorithm sometimes plays is to
support <em>flow control</em>—a feedback mechanism by which the receiver is
able to throttle the sender. Such a mechanism is used to keep the sender
from over-running the receiver—that is, from transmitting more data than
the receiver is able to process. This is usually accomplished by
augmenting the sliding window protocol so that the receiver not only
acknowledges frames it has received but also informs the sender of how
many frames it has room to receive. The number of frames that the
receiver is capable of receiving corresponds to how much free buffer
space it has. As in the case of ordered delivery, we need to make sure
that flow control is necessary at the link level before incorporating it
into the sliding window protocol.</p>
<div class="admonition-key-takeaway admonition">
<p class="first admonition-title">Key Takeaway</p>
<p class="last">One important concept to take away from this discussion is the system
design principle we call <em>separation of concerns</em>. That is, you must
be careful to distinguish between different functions that are
sometimes rolled together in one mechanism, and you must make sure
that each function is necessary and being supported in the most
effective way. In this particular case, reliable delivery, ordered
delivery, and flow control are sometimes combined in a single sliding
window protocol, and we should ask ourselves if this is the right
thing to do at the link level.</p>
</div>
</div>
</div>
<div class="section" id="concurrent-logical-channels">
<h2>Concurrent Logical Channels<a class="headerlink" href="#concurrent-logical-channels" title="Permalink to this headline">¶</a></h2>
<p>The data link protocol used in the original ARPANET provides an
interesting alternative to the sliding window protocol, in that it is
able to keep the pipe full while still using the simple stop-and-wait
algorithm. One important consequence of this approach is that the frames
sent over a given link are not kept in any particular order. The
protocol also implies nothing about flow control.</p>
<p>The idea underlying the ARPANET protocol, which we refer to as
<em>concurrent logical channels</em>, is to multiplex several logical channels
onto a single point-to-point link and to run the stop-and-wait algorithm
on each of these logical channels. There is no relationship maintained
among the frames sent on any of the logical channels, yet because a
different frame can be outstanding on each of the several logical
channels the sender can keep the link&nbsp;full.</p>
<p>More precisely, the sender keeps 3&nbsp;bits of state for each channel: a
boolean, saying whether the channel is currently busy; the 1-bit
sequence number to use the next time a frame is sent on this logical
channel; and the next sequence number to expect on a frame that arrives
on this channel. When the node has a frame to send, it uses the lowest
idle channel, and otherwise it behaves just like stop-and-wait.</p>
<p>In practice, the ARPANET supported 8 logical channels over each ground
link and 16 over each satellite link. In the ground-link case, the
header for each frame included a 3-bit channel number and a 1-bit
sequence number, for a total of 4&nbsp;bits. This is exactly the number of
bits the sliding window protocol requires to support up to 8 outstanding
frames on the link when <code class="docutils literal notranslate"><span class="pre">RWS</span> <span class="pre">=</span> <span class="pre">SWS</span></code>.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="ethernet.html" class="btn btn-neutral float-right" title="2.6 Multi-Access Networks" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="error.html" class="btn btn-neutral float-left" title="2.4 Error Detection" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>
