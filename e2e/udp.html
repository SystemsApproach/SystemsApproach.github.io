

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>5.1 Simple Demultiplexor (UDP) &mdash; Computer Networks: A Systems Approach Version 6.2-dev documentation</title>
  

  
  
    <link rel="shortcut icon" href="../static/bridge.ico"/>
  
  
  

  
  <script type="text/javascript" src="../static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../static/documentation_options.js"></script>
        <script type="text/javascript" src="../static/jquery.js"></script>
        <script type="text/javascript" src="../static/underscore.js"></script>
        <script type="text/javascript" src="../static/doctools.js"></script>
        <script type="text/javascript" src="../static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../static/css/rtd_theme_mods.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="5.2 Reliable Byte Stream (TCP)" href="tcp.html" />
    <link rel="prev" title="Problem: Getting Processes to Communicate" href="problem.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Computer Networks: A Systems Approach
          

          
          </a>

          
            
            
              <div class="version">
                Version 6.2-dev
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Table of Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../preface.html">Preface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../foundation.html">Chapter 1:  Foundation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../direct.html">Chapter 2:  Direct Links</a></li>
<li class="toctree-l1"><a class="reference internal" href="../internetworking.html">Chapter 3:  Internetworking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scaling.html">Chapter 4:  Advanced Internetworking</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../e2e.html">Chapter 5:  End-to-End Protocols</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="problem.html">Problem: Getting Processes to Communicate</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">5.1 Simple Demultiplexor (UDP)</a></li>
<li class="toctree-l2"><a class="reference internal" href="tcp.html">5.2 Reliable Byte Stream (TCP)</a></li>
<li class="toctree-l2"><a class="reference internal" href="rpc.html">5.3 Remote Procedure Call</a></li>
<li class="toctree-l2"><a class="reference internal" href="rtp.html">5.4 Transport for Real-Time (RTP)</a></li>
<li class="toctree-l2"><a class="reference internal" href="trend.html">Perspective: HTTP is the New Narrow Waist</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../congestion.html">Chapter 6:  Congestion Control</a></li>
<li class="toctree-l1"><a class="reference internal" href="../data.html">Chapter 7: End-to-End Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security.html">Chapter 8: Network Security</a></li>
<li class="toctree-l1"><a class="reference internal" href="../applications.html">Chapter 9: Applications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../supplements.html">Emerging Topics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../README.html">About This Book</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Computer Networks: A Systems Approach</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../e2e.html">Chapter 5:  End-to-End Protocols</a> &raquo;</li>
        
      <li>5.1 Simple Demultiplexor (UDP)</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/e2e/udp.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="simple-demultiplexor-udp">
<h1>5.1 Simple Demultiplexor (UDP)<a class="headerlink" href="#simple-demultiplexor-udp" title="Permalink to this headline">¶</a></h1>
<p>The simplest possible transport protocol is one that extends the
host-to-host delivery service of the underlying network into a
process-to-process communication service. There are likely to be many
processes running on any given host, so the protocol needs to add a
level of demultiplexing, thereby allowing multiple application processes
on each host to share the network. Aside from this requirement, the
transport protocol adds no other functionality to the best-effort
service provided by the underlying network. The Internet’s User Datagram
Protocol is an example of such a transport protocol.</p>
<p>The only interesting issue in such a protocol is the form of the address
used to identify the target process. Although it is possible for
processes to <em>directly</em> identify each other with an OS-assigned process
id (pid), such an approach is only practical in a closed distributed
system in which a single OS runs on all hosts and assigns each process a
unique id. A more common approach, and the one used by UDP, is for
processes to <em>indirectly</em> identify each other using an abstract locater,
usually called a <em>port</em>. The basic idea is for a source process to send
a message to a port and for the destination process to receive the
message from a port.</p>
<p>The header for an end-to-end protocol that implements this
demultiplexing function typically contains an identifier (port) for
both the sender (source) and the receiver (destination) of the
message. For example, the UDP header is given in <a class="reference internal" href="#fig-udp-format"><span class="std std-numref">Figure 125</span></a>.  Notice that the UDP port field is only 16&nbsp;bits
long. This means that there are up to 64K possible ports, clearly not
enough to identify all the processes on all the hosts in the
Internet. Fortunately, ports are not interpreted across the entire
Internet, but only on a single host. That is, a process is really
identified by a port on some particular host: a (port, host)
pair. This pair constitutes the demultiplexing key for the UDP
protocol.</p>
<p>The next issue is how a process learns the port for the process to which
it wants to send a message. Typically, a client process initiates a
message exchange with a server process. Once a client has contacted a
server, the server knows the client’s port (from the <code class="docutils literal notranslate"><span class="pre">SrcPrt</span></code> field
contained in the message header) and can reply to it. The real problem,
therefore, is how the client learns the server’s port in the first
place. A common approach is for the server to accept messages at a
<em>well-known port</em>. That is, each server receives its messages at some
fixed port that is widely published, much like the emergency telephone
service available in the United States at the well-known phone number
911. In the Internet, for example, the Domain Name Server (DNS) receives
messages at well-known port&nbsp;53 on each host, the mail service listens
for messages at port&nbsp;25, and the Unix <code class="docutils literal notranslate"><span class="pre">talk</span></code> program accepts messages
at well-known port&nbsp;517, and so on. This mapping is published
periodically in an RFC and is available on most Unix systems in file
<code class="docutils literal notranslate"><span class="pre">/etc/services</span></code>. Sometimes a well-known port is just the starting
point for communication: The client and server use the well-known port
to agree on some other port that they will use for subsequent
communication, leaving the well-known port free for other clients.</p>
<div class="figure align-center" id="id1">
<span id="fig-udp-format"></span><a class="reference internal image-reference" href="../_images/f05-01-9780123850591.png"><img alt="../_images/f05-01-9780123850591.png" src="../_images/f05-01-9780123850591.png" style="width: 400px;" /></a>
<p class="caption"><span class="caption-number">Figure 125. </span><span class="caption-text">Format for UDP header.</span></p>
</div>
<p>An alternative strategy is to generalize this idea, so that there is
only a single well-known port—the one at which the <em>port mapper</em> service
accepts messages. A client would send a message to the port mapper’s
well-known port asking for the port it should use to talk to the
“whatever” service, and the port mapper returns the appropriate port.
This strategy makes it easy to change the port associated with different
services over time and for each host to use a different port for the
same service.</p>
<p>As just mentioned, a port is purely an abstraction. Exactly how it is
implemented differs from system to system, or more precisely, from OS
to OS. For example, the socket API described in Chapter&nbsp;1 is an
example implementation of ports. Typically, a port is implemented by a
message queue, as illustrated in <a class="reference internal" href="#fig-udp-queue"><span class="std std-numref">Figure 126</span></a>. When a message arrives, the protocol (e.g., UDP)
appends the message to the end of the queue. Should the queue be full,
the message is discarded. There is no flow-control mechanism in UDP to
tell the sender to slow down. When an application process wants to
receive a message, one is removed from the front of the queue. If the
queue is empty, the process blocks until a message becomes available.</p>
<div class="figure align-center" id="id2">
<span id="fig-udp-queue"></span><a class="reference internal image-reference" href="../_images/f05-02-9780123850591.png"><img alt="../_images/f05-02-9780123850591.png" src="../_images/f05-02-9780123850591.png" style="width: 400px;" /></a>
<p class="caption"><span class="caption-number">Figure 126. </span><span class="caption-text">UDP message queue.</span></p>
</div>
<p>Finally, although UDP does not implement flow control or
reliable/ordered delivery, it does provide one more function aside from
demultiplexing messages to some application process—it also ensures the
correctness of the message by the use of a checksum. (The UDP checksum
is optional in IPv4 but is mandatory in IPv6.) The basic UDP checksum
algorithm is the same one used for IP—that is, it adds up a set of
16-bit words using ones’ complement arithmetic and takes the ones’
complement of the result. But the input data that is used for the
checksum is a little counterintuitive.</p>
<p>The UDP checksum takes as input the UDP header, the contents of the
message body, and something called the <em>pseudoheader</em>. The pseudoheader
consists of three fields from the IP header—protocol number, source IP
address, and destination IP address—plus the UDP length field. (Yes, the
UDP length field is included twice in the checksum calculation.) The
motivation behind having the pseudoheader is to verify that this message
has been delivered between the correct two endpoints. For example, if
the destination IP address was modified while the packet was in transit,
causing the packet to be misdelivered, this fact would be detected by
the UDP checksum.</p>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="tcp.html" class="btn btn-neutral float-right" title="5.2 Reliable Byte Stream (TCP)" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="problem.html" class="btn btn-neutral float-left" title="Problem: Getting Processes to Communicate" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>
